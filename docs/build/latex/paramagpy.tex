%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[a4paper,10pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsable pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage[,maxlistdepth=6]{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}

\setcounter{tocdepth}{1}

\title{paramagpy Documentation}
\date{Sep 20, 2021}
\release{1.2}
\author{Henry Orton}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}

\begin{quote}\begin{description}
\item[{Release}] \leavevmode
\sphinxAtStartPar
1.2

\item[{Date}] \leavevmode
\sphinxAtStartPar
Sep 20, 2021

\end{description}\end{quote}


\chapter{Introduction}
\label{\detokenize{index:introduction}}
\noindent\sphinxincludegraphics{{/Users/henryorton/Dropbox/PhD/git/paramagpy/docs/build/doctrees/images/5aae9591d8e1eb91b77981ab97e3ac89b96eea93/130321289}.svg}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{icon}.png}
\caption{\sphinxstyleemphasis{Please, not the eyes!} \sphinxhyphen{} Canberra cyclist}\label{\detokenize{index:id1}}\end{figure}
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{Please, not the eyes!} \sphinxhyphen{} Canberra cyclist
\end{quote}


\chapter{Features}
\label{\detokenize{index:features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Support for PDB protein structures with models

\item {} 
\sphinxAtStartPar
Combined SVD gridsearch and gradient descent algorithms for solving PCS tensors

\item {} 
\sphinxAtStartPar
Optional fitting of reference offset parameter for PCS datasets

\item {} 
\sphinxAtStartPar
Support for Residual Anisotropic Chemical Shielding (RACS) and Residual Anisotropic Dipolar Shielding (RADS) corrections to PCS

\item {} 
\sphinxAtStartPar
Lanthanide parameter templates available

\item {} 
\sphinxAtStartPar
Plotting of correlation between experiment/calculated values

\item {} 
\sphinxAtStartPar
Plotting of tensor isosurfaces compatible with PyMol

\item {} 
\sphinxAtStartPar
Q\sphinxhyphen{}factor calculations

\item {} 
\sphinxAtStartPar
Error analysis of tensor fit quality by Monte\sphinxhyphen{}Carlo or Bootstrap methods

\item {} 
\sphinxAtStartPar
Optimisation of multiple PCS/PRE/CCR datasets to a common position

\item {} 
\sphinxAtStartPar
Unique tensor representation compatible with Numbat (program)

\item {} 
\sphinxAtStartPar
Fitting of RDC tensor by SVD algorithm

\item {} 
\sphinxAtStartPar
PRE calculations by Solomon and Curie spin mechanisms

\item {} 
\sphinxAtStartPar
Spectral power density tensor fitting for anisotropic dipolar PREs

\item {} 
\sphinxAtStartPar
CSA cross\sphinxhyphen{}correlation correction to PRE calculations

\item {} 
\sphinxAtStartPar
Dipole\sphinxhyphen{}dipole/Curie spin cross\sphinxhyphen{}correlated relaxation calculations

\item {} 
\sphinxAtStartPar
Fitting of tensor parameters to PRE/CCR data

\item {} 
\sphinxAtStartPar
Macro scripts for integration with CCPNMR and Sparky

\end{itemize}


\chapter{Documentation}
\label{\detokenize{index:documentation}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxurl{https://henryorton.github.io/paramagpy/}

\end{itemize}


\chapter{Citing paramagpy}
\label{\detokenize{index:citing-paramagpy}}
\sphinxAtStartPar
Paramagpy is published in Magnetic Resonance \sphinxurl{https://doi.org/10.5194/mr-1-1-2020}


\chapter{Contents}
\label{\detokenize{index:contents}}

\section{Installation Guide}
\label{\detokenize{install:installation-guide}}\label{\detokenize{install::doc}}

\subsection{Requirements}
\label{\detokenize{install:requirements}}
\sphinxAtStartPar
Paramagpy is written for python 3. It requires packages:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{http://numpy.scipy.org}{NumPy}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://www.scipy.org}{SciPy}

\item {} 
\sphinxAtStartPar
\sphinxhref{http://matplotlib.org/}{matplotlib}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://biopython.org/}{BioPython}

\end{itemize}


\subsection{Unix/OSX Installation}
\label{\detokenize{install:unix-osx-installation}}
\sphinxAtStartPar
Install directly using pip:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} pip install paramagpy
\end{sphinxVerbatim}

\sphinxAtStartPar
Or, download the \sphinxhref{https://github.com/henryorton/paramagpy}{source code} and run:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} python setup.py install
\end{sphinxVerbatim}

\sphinxAtStartPar
within the source directory.


\subsection{Windows Installation}
\label{\detokenize{install:windows-installation}}
\sphinxAtStartPar
Paramagpy has never been tested on windows, but theoretically it should work. Good luck!


\subsection{Running the GUI}
\label{\detokenize{install:running-the-gui}}
\sphinxAtStartPar
Once you have installed paramagpy, see {\hyperref[\detokenize{paramagpy_gui:paramagpy-gui}]{\sphinxcrossref{\DUrole{std,std-ref}{Graphic User Interface (GUI)}}}} for how to run the GUI.


\section{Examples}
\label{\detokenize{examples/index:examples}}\label{\detokenize{examples/index:examples-index}}\label{\detokenize{examples/index::doc}}
\sphinxAtStartPar
Note that all these examples are for scripted calculations using the Paramagpy python module. Most of this functionality is also available by the GUI {\hyperref[\detokenize{paramagpy_gui:paramagpy-gui}]{\sphinxcrossref{\DUrole{std,std-ref}{Graphic User Interface (GUI)}}}}


\subsection{PCS data}
\label{\detokenize{examples/index:pcs-data}}

\subsubsection{Fit Tensor to PCS Data}
\label{\detokenize{examples/pcs_fit:fit-tensor-to-pcs-data}}\label{\detokenize{examples/pcs_fit:pcs-fit}}\label{\detokenize{examples/pcs_fit::doc}}
\sphinxAtStartPar
This example shows how to fit a \({\Delta\chi}\)\sphinxhyphen{}tensor to experimental PCS data for the protein calbindin D9k. These data contain amide 1H and 15N chemical shifts between diamagnetic and paramagnetic states with the lanthanide Er3+ bound.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_fit.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit:script-explanation}}
\sphinxAtStartPar
Firstly, the necessary modules are imported from paramagpy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\end{sphinxVerbatim}

\sphinxAtStartPar
The protein is then loaded from a PDB file using {\hyperref[\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy.protein.load_pdb}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.load\_pdb()}}}}} into the variable \sphinxcode{\sphinxupquote{prot}}. This returns a \sphinxcode{\sphinxupquote{CustomStructure}} object which is closely based on the \sphinxcode{\sphinxupquote{Structure}} object from \sphinxhref{https://biopython.org/}{BioPython} and contains the atomic coordinates. The object, and how to access atomic coordinates is discussed at this \sphinxhref{https://biopython.org/wiki/The\_Biopython\_Structural\_Bioinformatics\_FAQ}{link}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The PCS data is then loaded from a \sphinxcode{\sphinxupquote{.npc}} file using the function {\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.read\_pcs()}}}}} into the variable \sphinxcode{\sphinxupquote{rawData}}. This is a dictionary of \sphinxcode{\sphinxupquote{(PCS, Error)}} tuples which may be accessed by \sphinxcode{\sphinxupquote{rawData{[}(seq, atom){]}}} where \sphinxcode{\sphinxupquote{seq}} is an integer specifying the sequence and \sphinxcode{\sphinxupquote{atom}} is the atom name e.g \sphinxcode{\sphinxupquote{(3,\textquotesingle{}HA\textquotesingle{})}}. Note that these should match the corresponding sequence and atom in the PDB file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
To associate the experimental PCS value with atoms of the PDB structure, the method {\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}} is called on \sphinxcode{\sphinxupquote{rawData}}. The returned array \sphinxcode{\sphinxupquote{parsedData}} has a row for each atom with columns \sphinxcode{\sphinxupquote{{[}mdl,atm,exp,cal,err,idx{]}}}, where \sphinxcode{\sphinxupquote{mdl}} is the model number from the PDB file, \sphinxcode{\sphinxupquote{atm}} is an atom object from the BioPython PDB structure, \sphinxcode{\sphinxupquote{exp}} and \sphinxcode{\sphinxupquote{cal}} are the experimental and calculated values, \sphinxcode{\sphinxupquote{err}} is the experimental uncertainty and \sphinxcode{\sphinxupquote{idx}} is the atom index, used to define ensemble averaging behaviour.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
An initial \({\Delta\chi}\)\sphinxhyphen{}tensor is defined by initialising a {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal}}}}} object. The initial position is known to be near the binding site, which is set to the CA atom of residue 56. Note that the \sphinxcode{\sphinxupquote{position}} attribute is always in Angstrom units.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}
\end{sphinxVerbatim}

\sphinxAtStartPar
A quick gridsearch is conducted in a sphere of 10 Angstrom with 10 points per radius using the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.svd\_gridsearch\_fit\_metal\_from\_pcs()}}}}}. This requires two lists containing the starting metals \sphinxcode{\sphinxupquote{mStart}} and parsed experimental dataArray \sphinxcode{\sphinxupquote{parsedData}}. This function returns lists containing a new fitted metal object, the calculated PCS values from the fitted model.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate an initial tensor from an SVD gridsearch}
\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This is then refined using a non\sphinxhyphen{}linear regression gradient descent with the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Refine the tensor using non\PYGZhy{}linear regression}
\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The Q\sphinxhyphen{}factor is then calculated using the function :py:func\textasciigrave{}paramagpy.fit.qfactor\textasciigrave{}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the Q\PYGZhy{}factor}
\PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fitted tensor parameters are saved by calling the method {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy.metal.Metal.save}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.save()}}}}}. Alterntaively they may be displayed using \sphinxcode{\sphinxupquote{print(mFit.info())}}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Save the fitted tensor to file}
\PYG{n}{mFit}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ax    | 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}8.688
rh    | 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}4.192
x     |   1E\PYGZhy{}10 m :    25.517
y     |   1E\PYGZhy{}10 m :     8.652
z     |   1E\PYGZhy{}10 m :     6.358
a     |       deg :   116.011
b     |       deg :   138.058
g     |       deg :    43.492
mueff |        Bm :     0.000
shift |       ppm :     0.000
B0    |         T :    18.790
temp  |         K :   298.150
t1e   |        ps :     0.000
taur  |        ns :     0.000
\end{sphinxVerbatim}

\sphinxAtStartPar
These experimental/calculated PCS values are then plotted in a correlation plot to assess the fit. This is achieved using standard functions of the plotting module \sphinxhref{https://matplotlib.org/}{matplotlib}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q\PYGZhy{}factor = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit}.png}


\subsubsection{Calculate PCSs from known tensor}
\label{\detokenize{examples/pcs_calc:calculate-pcss-from-known-tensor}}\label{\detokenize{examples/pcs_calc:pcs-calc}}\label{\detokenize{examples/pcs_calc::doc}}
\sphinxAtStartPar
This example shows how calculate PCSs from a known \({\Delta\chi}\)\sphinxhyphen{}tensor that is stored in a file.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_calc:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Tb\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_calc.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_calc:script-explanation}}
\sphinxAtStartPar
This simple script reads the \({\Delta\chi}\)\sphinxhyphen{}tensor from a file and calcualtes the PCS for all atoms in a PDB file. The calculated PCS is then written to an \sphinxcode{\sphinxupquote{.npc}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Read tensor}
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Open a file to write }
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}calc.npc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
	\PYG{c+c1}{\PYGZsh{} Loop over atoms in PDB and calculate PCS}
	\PYG{k}{for} \PYG{n}{atom} \PYG{o+ow}{in} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{get\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{data} \PYG{o}{=} \PYG{p}{\PYGZob{}}
			\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{atom}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,}
			\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{seq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{atom}\PYG{o}{.}\PYG{n}{parent}\PYG{o}{.}\PYG{n}{id}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}
			\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pcs}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{)}
		\PYG{p}{\PYGZcb{}}
		\PYG{n}{line} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}seq:4d\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}name:5s\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}pcs:8.5f\PYGZcb{}}\PYG{l+s+s2}{ 0.0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{o}{*}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}
		\PYG{n}{f}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Plot PCS isosurface (PyMol view)}
\label{\detokenize{examples/pcs_plot_isosurface:plot-pcs-isosurface-pymol-view}}\label{\detokenize{examples/pcs_plot_isosurface:pcs-plot-isosurface}}\label{\detokenize{examples/pcs_plot_isosurface::doc}}
\sphinxAtStartPar
This example shows how to plot the PCS isosurface of a fitted \({\Delta\chi}\)\sphinxhyphen{}tensor for data from the example {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}. The isosurface can be viewed in \sphinxhref{https://pymol.org}{PyMol}.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_plot_isosurface:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/pcs\_plot\_isosurface/pcs\_plot\_isosurface.py}{pcs\_plot\_isosurface.py}

\end{itemize}


\paragraph{Explanation}
\label{\detokenize{examples/pcs_plot_isosurface:explanation}}
\sphinxAtStartPar
The protein and tensor are loaded as described previously in.

\sphinxAtStartPar
The isosurface files are generated using the function {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy.metal.Metal.isomap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.isomap()}}}}}. The contour level can be chosen by setting the \sphinxcode{\sphinxupquote{isoval}} argument. A larger \sphinxcode{\sphinxupquote{density}} value will result in a smoother surface. This function writes two files \sphinxcode{\sphinxupquote{isomap.pml}} and \sphinxcode{\sphinxupquote{isomap.pml.ccp4}} which are the PyMol script and PCS grid files respectively.

\sphinxAtStartPar
The isosurface can be displayed by executing \sphinxcode{\sphinxupquote{pymol isomap.pml}} from a terminal, or by selecting \sphinxcode{\sphinxupquote{File\textgreater{}Run}} and navigating to the script \sphinxcode{\sphinxupquote{isomap.pml}}.


\paragraph{Script}
\label{\detokenize{examples/pcs_plot_isosurface:script}}
\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{pcs\_plot\_isosurface.py}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the fitted tensor}
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the isosurface to be opened in PyMol}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{isomap}\PYG{p}{(}\PYG{n}{prot}\PYG{o}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{density}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{isoval}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Output}
\label{\detokenize{examples/pcs_plot_isosurface:output}}
\sphinxAtStartPar
\sphinxstyleemphasis{PyMol view of isosurface}

\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{pcs\_plot\_isosurface.png}}{]}

\noindent\sphinxincludegraphics{{pcs_plot_isosurface}.png}


\subsubsection{Fit multiple PCS datasets to common position}
\label{\detokenize{examples/pcs_fit_multiple:fit-multiple-pcs-datasets-to-common-position}}\label{\detokenize{examples/pcs_fit_multiple:pcs-fit-multiple}}\label{\detokenize{examples/pcs_fit_multiple::doc}}
\sphinxAtStartPar
This example shows how to fit multiple \({\Delta\chi}\)\sphinxhyphen{}tensors to their respective datasets with a common position, but varied magnitude and orientation. This may arise if several lanthanides were investigated at the same binding site, and the data may be used simultaneously to fit a common position. Data from several PCS datasets for calbindin D9k were used here, and is a generalisation of the previous example: {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_multiple:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}}, \sphinxcode{\sphinxupquote{calbindin\_Tb\_HN\_PCS.npc}}, \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} and \sphinxcode{\sphinxupquote{calbindin\_Yb\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/pcs\_fit\_multiple/pcs\_fit\_multiple.py}{pcs\_fit\_multiple.py}

\end{itemize}


\paragraph{Explanation}
\label{\detokenize{examples/pcs_fit_multiple:explanation}}
\sphinxAtStartPar
The protein and PCS datasets are loaded and parsed. These are placed into a list \sphinxcode{\sphinxupquote{parsedData}}, for which each element is a PCS dataset of a given lanthanide.

\sphinxAtStartPar
The two fitting functions:
\begin{itemize}
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.svd\_gridsearch\_fit\_metal\_from\_pcs()}}}}}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}}

\end{itemize}

\sphinxAtStartPar
can accept a list of metal objects and a list of datasets with arbitrary size. If this list contains more than one element, fitting will be performed to a common position. The starting position is taken only from the first metal of the list.

\sphinxAtStartPar
After fitting, a list of fitted metals is returned. The fitted tensor are then written to files and a correlation plot is made.


\paragraph{Script}
\label{\detokenize{examples/pcs_fit_multiple:script}}
\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{pcs\_fit\_multiple.py}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData1} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData2} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData3} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Yb\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{rd} \PYG{o+ow}{in} \PYG{p}{[}\PYG{n}{rawData1}\PYG{p}{,} \PYG{n}{rawData2}\PYG{p}{,} \PYG{n}{rawData3}\PYG{p}{]}\PYG{p}{:}
	\PYG{n}{parsedData}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rd}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make a list of starting tensors}
\PYG{n}{mStart} \PYG{o}{=} \PYG{p}{[}\PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}

\PYG{c+c1}{\PYGZsh{} Calculate initial tensors from an SVD gridsearch}
\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{datas} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{n}{mStart}\PYG{p}{,} \PYG{n}{parsedData}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Refine the tensors using non\PYGZhy{}linear regression}
\PYG{n}{fitParameters} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{datas} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{parsedData}\PYG{p}{,} \PYG{n}{fitParameters}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the fitted tensors to files}
\PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{metal} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Yb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mFit}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{metal}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tensor\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{.txt}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{k}{for} \PYG{n}{d}\PYG{p}{,} \PYG{n}{name}\PYG{p}{,} \PYG{n}{colour} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{datas}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Yb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{qfactor} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{d}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{d}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{colour}\PYG{p}{,}
		\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}0:\PYGZcb{}}\PYG{l+s+s2}{ \PYGZhy{} }\PYG{l+s+si}{\PYGZob{}1:5.3f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{,} \PYG{n}{qfactor}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Axis labels}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}multiple.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\paragraph{Outputs}
\label{\detokenize{examples/pcs_fit_multiple:outputs}}
\sphinxAtStartPar
\sphinxstyleemphasis{Tb fitted tensor}

\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{tensor\_Tb.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{l+m+mf}{31.096}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{l+m+mf}{12.328}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.937}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.481}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.597}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{151.053}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{152.849}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{69.821}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Er fitted tensor}

\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{tensor\_Er.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.422}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.886}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.937}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.481}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.597}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{126.015}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{142.899}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{41.039}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Yb fitted tensor}

\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{tensor\_Yb.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.392}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.490}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.937}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.481}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.597}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{129.650}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{137.708}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{88.796}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Correlation Plot}

\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{pcs\_fit\_multiple.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_multiple}.png}


\subsubsection{Fit Tensor to PDB with Models}
\label{\detokenize{examples/pcs_fit_models:fit-tensor-to-pdb-with-models}}\label{\detokenize{examples/pcs_fit_models:pcs-fit-models}}\label{\detokenize{examples/pcs_fit_models::doc}}
\sphinxAtStartPar
This example shows how to fit a \({\Delta\chi}\)\sphinxhyphen{}tensor to experimental PCS data using an NMR structure that contains multiple models. Data for calbindin D9k are used as in the previous example {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}.

\sphinxAtStartPar
There are 3 fitting options available in paramagpy for fitting:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Averaged fit: A tensor is fit to each model independently, and then all fitted tensors are averaged together. This is a good choice if models in your PDB represent structural uncertainty.

\item {} 
\sphinxAtStartPar
Ensemble averaged fit: A single tensor is fit simultaneously to all models by averaging calculated PCS values during fitting. This is a good choice if models in your PDB represent dynamics as comes from a molecular dynamics simulation.

\item {} 
\sphinxAtStartPar
Separate model fit: A tensor is fit to each model independently and the best fitting model is taken. This is a good choice if you are only looking for the best fit model in a PDB containing many models.

\end{enumerate}


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_models:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{2bcb.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_models.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_models:script-explanation}}
\sphinxAtStartPar
Firstly, the standard preamble and loading of data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load data}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/2bcb.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
If all models are provided in the \sphinxcode{\sphinxupquote{parsedData}} argument, the default functionality for all fitting methods such as {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}} is to fit using method 1, meaning a tensor is fit to each model and the averaged tensor is returned. This is equivalent to setting the \sphinxcode{\sphinxupquote{ensebleAverage}} argument to \sphinxcode{\sphinxupquote{False}}. This is done below. Averaging behaviour can be controlled through the \sphinxcode{\sphinxupquote{idx}} column of \sphinxcode{\sphinxupquote{parsedData}}. The \sphinxcode{\sphinxupquote{idx}} array contains common integers for corresponding atoms to be averaged, and defaults to the atom’s serial number found in the PDB file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Averaged fit to all models \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{avg} \PYG{o}{=} \PYG{n}{qfac}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{mFit}
\end{sphinxVerbatim}

\sphinxAtStartPar
Method 2 can be followed by the same method, except setting the \sphinxcode{\sphinxupquote{ensebleAverage}} argument to \sphinxcode{\sphinxupquote{True}}. At each stage of the fitting process, all PCS calculations are then averaged before fitting of a single tensor to all the data simultaneously. The ensemble averaging behaviour can be set through the \sphinxcode{\sphinxupquote{idx}} column of the input data for {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pcs()}}}}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Ensembled averaged fit to all models \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{n}{e\PYGZus{}avg} \PYG{o}{=} \PYG{n}{qfac}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{mFit}
\end{sphinxVerbatim}

\sphinxAtStartPar
Method 3 can be achieved by constructing a \sphinxcode{\sphinxupquote{for}} loop over the PDB models and fitting a separate tensor to the data from each model. The model which achieves the lowest Q\sphinxhyphen{}factor can then be extracted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Seperate fit for each model \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{n}{sep} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{model} \PYG{o+ow}{in} \PYG{n}{prot}\PYG{p}{:}
    \PYG{n}{singleModelData} \PYG{o}{=} \PYG{n}{parsedData}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mdl}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{==}\PYG{n}{model}\PYG{o}{.}\PYG{n}{id}\PYG{p}{]}
    \PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{singleModelData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
    \PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{singleModelData}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
    \PYG{n}{sep}\PYG{p}{[}\PYG{n}{model}\PYG{o}{.}\PYG{n}{id}\PYG{p}{]} \PYG{o}{=} \PYG{n}{qfac}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{mFit}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally we plot three sets of data:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The averaged fit calculated over all models (green)

\item {} 
\sphinxAtStartPar
The ensemble average of the calculated values of the ensemble fit (red)

\item {} 
\sphinxAtStartPar
The best fitting single model (blue)

\end{itemize}

\sphinxAtStartPar
Note that to calculate the ensemble average of the calculated values we use the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy.fit.ensemble_average}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.ensemble\_average()}}}}}. This can take any number of arguments, and will average values based on common serial numbers of the list of atoms in the first argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot averaged fit correlation}
\PYG{n}{qfac}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{mFit} \PYG{o}{=} \PYG{n}{avg}
\PYG{n}{mFit}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}average.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
    \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Averaged Fit: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot ensemble averaged fit correlation}
\PYG{n}{qfac}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{mFit} \PYG{o}{=} \PYG{n}{e\PYGZus{}avg}
\PYG{n}{mFit}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}ensemble\PYGZus{}average.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Ensemble average the data to get a single point for each model}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{ensemble\PYGZus{}average}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
    \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ensemble Avg. Fit: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot best fit model correlation}
\PYG{c+c1}{\PYGZsh{} Sort fits by Qfactor and take smallest}
\PYG{n}{model}\PYG{p}{,} \PYG{p}{(}\PYG{n}{qfac}\PYG{p}{,} \PYG{n}{data}\PYG{p}{,} \PYG{n}{mFit}\PYG{p}{)} \PYG{o}{=} \PYG{n+nb}{sorted}\PYG{p}{(}\PYG{n}{sep}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{key}\PYG{o}{=}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{n}{mFit}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}best\PYGZus{}model.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
    \PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Best Fit Model }\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{model}\PYG{p}{,} \PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}models.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_models.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_models}.png}


\subsubsection{Constrained Fitting}
\label{\detokenize{examples/pcs_fit_constrained:constrained-fitting}}\label{\detokenize{examples/pcs_fit_constrained:pcs-fit-constrained}}\label{\detokenize{examples/pcs_fit_constrained::doc}}
\sphinxAtStartPar
This example shows how to fit a \({\Delta\chi}\)\sphinxhyphen{}tensor with constraints applied. The two cases here constrain position to fit a tensor to a known metal ion position form an X\sphinxhyphen{}ray structure, and fit an axially symmetric tensor with only 6 of the usual 8 parameters.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_constrained:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_constrained.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_constrained:script-explanation}}
\sphinxAtStartPar
The necessary modules are imported and data is loaded

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load data}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The calcium ion from the X\sphinxhyphen{}ray structure is contained in a heteroatom of the PDB file. We set the starting position of the tensor to this position.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Set the starting position to Calcium ion heteroatom in PDB}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H\PYGZus{} CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+m+mi}{77}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}
\end{sphinxVerbatim}

\sphinxAtStartPar
To fit the the anisotropy and orientation without position, the linear PCS equation can be solved analytically by the SVD gridsearch method but using only one point with a radius of zero. The Q\sphinxhyphen{}factor is then calculated and the tensor is saved.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate tensor by SVD}
\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

\PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

\PYG{n}{mFit}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}position\PYGZus{}constrained.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_constrained.png}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.152}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.911}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{25.786}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{9.515}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.558}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{125.841}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{142.287}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{41.758}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
To fit an axially symmetric tensor, we can used the Non\sphinxhyphen{}linear regression method and specify exactly which parameters we want to fit. This will be the axiality \sphinxcode{\sphinxupquote{ax}}, two Euler angles \sphinxcode{\sphinxupquote{b}} and \sphinxcode{\sphinxupquote{g}} and the position coordinates. Note that in the output, the rhombic \sphinxcode{\sphinxupquote{rh}} and alpha \sphinxcode{\sphinxupquote{a}} parameters are redundant.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate axially symmetric tensor by NRL}
\PYG{p}{[}\PYG{n}{mFitAx}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{dataAx}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{qfacAx} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{dataAx}\PYG{p}{)}

\PYG{n}{mFitAx}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}axially\PYGZus{}symmetric.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_constrained.png}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{9.510}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{24.948}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{8.992}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{3.205}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{134.697}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{180.000}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally we plot the data.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Position constrained: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{dataAx}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dataAx}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Axially symmetric: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfacAx}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}constrained.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_constrained.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_constrained}.png}


\subsubsection{Fit a tensor to PCS data with uncertainties}
\label{\detokenize{examples/pcs_fit_error:fit-a-tensor-to-pcs-data-with-uncertainties}}\label{\detokenize{examples/pcs_fit_error:pcs-fit-error}}\label{\detokenize{examples/pcs_fit_error::doc}}
\sphinxAtStartPar
This example shows how to conduct a weighted fit of a \({\Delta\chi}\)\sphinxhyphen{}tensor to experimental PCS data with experimental errors.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_error:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_errors.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_error.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_error:script-explanation}}
\sphinxAtStartPar
This script follows very closely the script {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}}. The only difference being that errors are included in the fourth column of the .npc file and errorbars are included in the plotting routine.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}errors.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}

\PYG{c+c1}{\PYGZsh{} Calculate an initial tensor from an SVD gridsearch}
\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Refine the tensor using non\PYGZhy{}linear regression}
\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the fitted tensor to file}
\PYG{n}{mFit}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor\PYGZus{}errors.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{errorbar}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{xerr}\PYG{o}{=}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{err}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{fmt}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} 
	\PYG{n}{ecolor}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{capsize}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Q\PYGZhy{}factor = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}error.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fitted tensor:

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor\_errors.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.012}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.125}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}    \PYG{l+m+mf}{24.892}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{8.456}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{6.287}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{112.440}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}   \PYG{l+m+mf}{135.924}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{46.210}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.790}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{298.150}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
And correlation plot:

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pcs\_fit\_error.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_error}.png}


\subsubsection{Fit Atomic Coordinates to PCS data}
\label{\detokenize{examples/pcs_fit_atom:fit-atomic-coordinates-to-pcs-data}}\label{\detokenize{examples/pcs_fit_atom:pcs-fit-atom}}\label{\detokenize{examples/pcs_fit_atom::doc}}
\sphinxAtStartPar
This example shows how to calculate the region in space (also referred to as localisation space) which is likely for atomic coordinates from PCS measurements. The example uses multiple \({\Delta\chi}\)\sphinxhyphen{}tensors are used from different tagging sites in the protein IMP\sphinxhyphen{}1 to localise a tryptophan sidechain in a loop.

\sphinxAtStartPar
The script fits the \({\Delta\chi}\)\sphinxhyphen{}tensors to a crystal structure of IMP\sphinxhyphen{}1 using backbone PCS data and then samples 20 perturbed tensors using a bootstrap fitting. The sampled tensors improve stability of the final calculation. The script then calculates the RMSD between experimental and back\sphinxhyphen{}calculated PCS values for nuclei in the sidechain of tryptophan at residue 28 on a grid of points. The grid, which defines the localisation space, is then viewed in PyMOL.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_atom:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{5ev6AH.pdb}} and all IMP\sphinxhyphen{}1 datasets from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_atom.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_atom:script-explanation}}
\sphinxAtStartPar
After importing modules from Paramagpy, the tagging sites and lanthanoid ions are specified as tuple variables. The PDB file is loaded. The \sphinxcode{\sphinxupquote{atoms}} list contains the atoms of interest (in this case the NH and adjacent CH protons of tryptophan 28). Finally the number of bootstrap iterations are defined.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\PYG{k+kn}{import} \PYG{n+nn}{re}

\PYG{n}{sites} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A53C\PYGZhy{}C2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N172C\PYGZhy{}C2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S204C\PYGZhy{}C2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N172C\PYGZhy{}C12}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{ions} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{pdb\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/5ev6AH.pdb}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{n}{pdb\PYGZus{}path}\PYG{p}{)}
\PYG{n}{atomns} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H07}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H08}\PYG{l+s+s1}{\PYGZsq{}}
\PYG{n}{atoms} \PYG{o}{=} \PYG{p}{[}\PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{28}\PYG{p}{]}\PYG{p}{[}\PYG{n}{atomn}\PYG{p}{]} \PYG{k}{for} \PYG{n}{atomn} \PYG{o+ow}{in} \PYG{n}{atomns}\PYG{p}{]}
\PYG{n}{BOOTSTRAP\PYGZus{}ITER} \PYG{o}{=} \PYG{l+m+mi}{20}
\end{sphinxVerbatim}

\sphinxAtStartPar
Two dictionaries are specified to define the final colours and RMSD contour levels to be plotted in PyMOL.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Isosurface colours}
\PYG{n}{surface\PYGZus{}colours} \PYG{o}{=} \PYG{p}{\PYGZob{}}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{teal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{blue}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{magenta}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{red}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} RMSD contour levels}
\PYG{n}{surface\PYGZus{}contour} \PYG{o}{=} \PYG{p}{\PYGZob{}}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mf}{0.04}\PYG{p}{,}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mf}{0.04}\PYG{p}{,}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mf}{0.016}\PYG{p}{,}
	\PYG{p}{(}\PYG{n}{ions}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{atomns}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:} \PYG{l+m+mf}{0.02}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
A PyMOL script object \sphinxcode{\sphinxupquote{paramagpy.protein.PyMOLScript}} is created and the PDB is added to it. This object makes it easy to add density maps, PDBs and spheres to PyMOL from Paramagpy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pmlscript} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{PyMolScript}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{pmlscript}\PYG{o}{.}\PYG{n}{add\PYGZus{}pdb}\PYG{p}{(}\PYG{n}{path}\PYG{o}{=}\PYG{n}{pdb\PYGZus{}path}\PYG{p}{,} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5ev6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Next is a rather involved loop that iterates of the tagging sites, fits the \({\Delta\chi}\)\sphinxhyphen{}tensor using a simultaneous fit between Tm and Tb data and finally samples the tensor fits using bootstrap. The fitted tensors are bundled into the variable \sphinxcode{\sphinxupquote{mdata}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{site} \PYG{o+ow}{in} \PYG{n}{sites}\PYG{p}{:} \PYG{c+c1}{\PYGZsh{} Loop over sites}
	\PYG{n}{bindingSite} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{re}\PYG{o}{.}\PYG{n}{search}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{d+}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{site}\PYG{p}{)}\PYG{o}{.}\PYG{n}{group}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Get residue number}
	\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
	\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{n}{bindingSite}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position} \PYG{c+c1}{\PYGZsh{} Set strating position}

	\PYG{n}{hnpcss} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{c+c1}{\PYGZsh{} Assemble exp. PCS data for both ions}
	\PYG{k}{for} \PYG{n}{ion} \PYG{o+ow}{in} \PYG{n}{ions}\PYG{p}{:}
		\PYG{n}{hnpcs\PYGZus{}raw} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/IMP1\PYGZus{}HN\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}FREE.npc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{site}\PYG{p}{,} \PYG{n}{ion}\PYG{p}{)}\PYG{p}{)}
		\PYG{n}{hnpcs} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{hnpcs\PYGZus{}raw}\PYG{p}{)}
		\PYG{n}{hnpcss}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{hnpcs}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Fit the tensor by SVD, then NLR}
	\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{,} \PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,} \PYG{n}{hnpcss}\PYG{p}{)}
	\PYG{n}{mFit}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{n}{mGuess}\PYG{p}{,} \PYG{n}{hnpcss}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Sample purturbed tensors by bootstrap}
	\PYG{n}{mSamples}\PYG{p}{,} \PYG{n}{mStd} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{fit\PYGZus{}error\PYGZus{}bootstrap}\PYG{p}{(}
		\PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{,} 
		\PYG{n}{BOOTSTRAP\PYGZus{}ITER}\PYG{p}{,} 
		\PYG{l+m+mf}{0.8}\PYG{p}{,} 
		\PYG{n}{initMetals}\PYG{o}{=}\PYG{n}{mFit}\PYG{p}{,} 
		\PYG{n}{dataArrays}\PYG{o}{=}\PYG{n}{hnpcss}
	\PYG{p}{)}

	\PYG{n}{mdata}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{mSamples}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fitted \({\Delta\chi}\)\sphinxhyphen{}tensors are then unzipped (to allow iterating over each ion) and assembled with the tryptophan PCS data in two lists \sphinxcode{\sphinxupquote{mdata}} and \sphinxcode{\sphinxupquote{trpdata}}. For each data array contained in \sphinxcode{\sphinxupquote{trpdata}} there must be an associated tensor contained in \sphinxcode{\sphinxupquote{mdata}}, so that is why they are constructed side by side.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{for} \PYG{n}{ion}\PYG{p}{,} \PYG{n}{mSamples} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{ions}\PYG{p}{,} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{mdata}\PYG{p}{)}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{trpdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{n}{mdata} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{c+c1}{\PYGZsh{} Loop sites with fitted tensors}
	\PYG{k}{for} \PYG{n}{site}\PYG{p}{,} \PYG{n}{mSample} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{sites}\PYG{p}{,} \PYG{n}{mSamples}\PYG{p}{)}\PYG{p}{:}
		\PYG{c+c1}{\PYGZsh{} Load TRP PCS data}
		\PYG{n}{trppcs\PYGZus{}raw} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/IMP1\PYGZus{}TRP\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{\PYGZus{}FREE.npc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{site}\PYG{p}{,} \PYG{n}{ion}\PYG{p}{)}\PYG{p}{)}
		\PYG{n}{trppcs} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{trppcs\PYGZus{}raw}\PYG{p}{)}

		\PYG{c+c1}{\PYGZsh{} Assemble associated lists of atoms/PCS with tensors}
		\PYG{k}{for} \PYG{n}{atom} \PYG{o+ow}{in} \PYG{n}{atoms}\PYG{p}{:}
			\PYG{n}{dataselect} \PYG{o}{=} \PYG{n}{trppcs}\PYG{p}{[}\PYG{n}{trppcs}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{atom}\PYG{p}{]}
			\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{dataselect}\PYG{p}{)}\PYG{o}{\PYGZgt{}}\PYG{l+m+mi}{0}\PYG{p}{:}
				\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n}{mSample}\PYG{p}{:} 
					\PYG{n}{trpdata}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{dataselect}\PYG{p}{)}
					\PYG{n}{mdata}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The function {\hyperref[\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_from_pcs:paramagpy.fit.gridsearch_fit_atom_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.gridsearch\_fit\_atom\_from\_pcs()}}}}} is called which calculates the PCS RMSD on a grid as defined by the function arguments \sphinxcode{\sphinxupquote{mapSize}} and \sphinxcode{\sphinxupquote{mapDensity}}. This function returns a dictionary which contains keys for the atoms of the PDB files and values of {\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.DensityMap}}}}} which define the grid of PCS RMSD values.

\sphinxAtStartPar
What remains of the script is to add the PCS RMSD grid to the PyMOL script and save it so that it plots with the specified colours and contour levels. What results is a volume which contains all points that have an RMSD less than the specified \sphinxcode{\sphinxupquote{isoVals}} value. Finally some standard PyMOL commands are added to display the protein structure as desired.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
	\PYG{k}{for} \PYG{n}{atom} \PYG{o+ow}{in} \PYG{n}{atoms}\PYG{p}{:}
		\PYG{n}{mapname} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{map}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{atom}\PYG{o}{.}\PYG{n}{id}\PYG{p}{,} \PYG{n}{ion}\PYG{p}{)}
		\PYG{n}{dmapFilePath} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{.ccp4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{mapname}\PYG{p}{)}
		\PYG{n}{gridsVol}\PYG{p}{[}\PYG{n}{atom}\PYG{p}{]}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{dmapFilePath}\PYG{p}{)}
		\PYG{n}{pmlscript}\PYG{o}{.}\PYG{n}{add\PYGZus{}map}\PYG{p}{(}
			\PYG{n}{path}\PYG{o}{=}\PYG{n}{dmapFilePath}\PYG{p}{,}
			\PYG{n}{name}\PYG{o}{=}\PYG{n}{mapname}\PYG{p}{,}
			\PYG{n}{isoVals}\PYG{o}{=}\PYG{p}{[}\PYG{n}{surface\PYGZus{}contour}\PYG{p}{[}\PYG{p}{(}\PYG{n}{ion}\PYG{p}{,} \PYG{n}{atom}\PYG{o}{.}\PYG{n}{id}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
			\PYG{n}{colours}\PYG{o}{=}\PYG{p}{[}\PYG{n}{surface\PYGZus{}colours}\PYG{p}{[}\PYG{p}{(}\PYG{n}{ion}\PYG{p}{,} \PYG{n}{atom}\PYG{o}{.}\PYG{n}{id}\PYG{p}{)}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
			\PYG{n}{surfaceType}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{isodot}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
		\PYG{p}{)}

\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{set dot\PYGZus{}radius, 0.05}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{show sticks, ////28 and sc.}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{show sticks, ////28/CA}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{set bg\PYGZus{}rgb=[1,1,1]}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{set mesh\PYGZus{}width, 0.5}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{zoom ////28/H07}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{set\PYGZus{}view (}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{     0.505656540,   \PYGZhy{}0.827194929,   \PYGZhy{}0.245069817,}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{    \PYGZhy{}0.741597414,   \PYGZhy{}0.561904311,    0.366465807,}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{    \PYGZhy{}0.440846384,   \PYGZhy{}0.003562994,   \PYGZhy{}0.897575319,}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{     0.000152570,    0.000080852,  \PYGZhy{}36.169487000,}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{    48.539413452,   83.819839478,   42.674442291,}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s2}{    26.907037735,   45.422363281,  \PYGZhy{}20.000000000 )}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ray 1600}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript} \PYG{o}{+}\PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{png pcs\PYGZus{}fit\PYGZus{}atom.png}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{pmlscript}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pcs\PYGZus{}fit\PYGZus{}atom.pml}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
This generates the following PyMOL script which allows viewing of the PCS RMSD region. \sphinxcode{\sphinxupquote{pcs\_fit\_atom.pml}}. After opening the script in PyMOL the following image is generated.

\sphinxAtStartPar
{[}\sphinxcode{\sphinxupquote{pcs\_fit\_atom.png}}{]}

\noindent\sphinxincludegraphics{{pcs_fit_atom}.png}


\subsubsection{Propagate Uncertainty to Fitted Tensor Parameters}
\label{\detokenize{examples/pcs_fit_uncertainty:propagate-uncertainty-to-fitted-tensor-parameters}}\label{\detokenize{examples/pcs_fit_uncertainty:pcs-fit-uncertainty}}\label{\detokenize{examples/pcs_fit_uncertainty::doc}}
\sphinxAtStartPar
This example shows the various error analysis functions available in paramagpy for estimating the unceratinty in fitted parameters for a paramagnetic center.


\paragraph{Downloads}
\label{\detokenize{examples/pcs_fit_uncertainty:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{2bcb.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_errors.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pcs\_fit\_uncertainty.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pcs_fit_uncertainty:script-explanation}}
\sphinxAtStartPar
This start of this script follows the script {\hyperref[\detokenize{examples/pcs_fit:pcs-fit}]{\sphinxcrossref{\DUrole{std,std-ref}{Fit Tensor to PCS Data}}}} to fit the tensor.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/2bcb.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the PCS data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}errors.npc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate PCS data with atoms of the PDB}
\PYG{n}{parsedData} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Set the starting position to an atom close to the metal}
\PYG{n}{mStart}\PYG{o}{.}\PYG{n}{position} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{56}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{position}

\PYG{c+c1}{\PYGZsh{} Calculate an initial tensor from an SVD gridsearch}
\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}gridsearch\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{,} \PYG{n}{radius}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n}{points}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Refine the tensor using non\PYGZhy{}linear regression}
\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mGuess}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}


\subparagraph{Uncertainty from structure models}
\label{\detokenize{examples/pcs_fit_uncertainty:uncertainty-from-structure-models}}
\sphinxAtStartPar
The PDB file contains models that capture uncertainty in the structure of the protein. This can be propagated to estimate uncertainty in the fitted tensor parameters using the fnction \sphinxcode{\sphinxupquote{paramagpy.fit.fit\_error\_model()}}. This fits a separate tensor to each model and returns all fitted tensors as well as the standard deviation in the fitted parameters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Estimate uncertainty sourcing noise from the models of the PDB}
\PYG{p}{[}\PYG{n}{mod\PYGZus{}all}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{mod\PYGZus{}std}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{fit\PYGZus{}error\PYGZus{}models}\PYG{p}{(}\PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{,} 
	\PYG{n}{initMetals}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dataArrays}\PYG{o}{=}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{mod\PYGZus{}std}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error\PYGZus{}tensor\PYGZus{}models.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The standard deviation in the fitted tensor parameters is found in the variable \sphinxcode{\sphinxupquote{mod\_std}}. This variation in tensor principle axes can be viewed by a Sanson\sphinxhyphen{}Flamsteed plot.

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{error\_tensor\_models.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.556}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.525}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.756}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.695}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.957}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{7.466}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{9.948}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{19.294}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{models.png}}{]}

\noindent\sphinxincludegraphics{{models}.png}


\subparagraph{Uncertainty from experimental uncertainties}
\label{\detokenize{examples/pcs_fit_uncertainty:uncertainty-from-experimental-uncertainties}}
\sphinxAtStartPar
Experimental uncertainties can be measured. This may arise due to spectral noise in peak heights for PREs, or spectral noise as uncertainties in chemical shifts for PCSs, as is the case here. The function {\hyperref[\detokenize{reference/generated/paramagpy.fit.fit_error_monte_carlo:paramagpy.fit.fit_error_monte_carlo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.fit\_error\_monte\_carlo()}}}}} will repeat the fit for many iterations, each time adding random noise from a uniform distribution scaled by the experimental errors present in the \sphinxcode{\sphinxupquote{err}} column of the dataArray \sphinxcode{\sphinxupquote{parsedData}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Estimate uncertainty sourcing noise from experimental uncertainties}
\PYG{p}{[}\PYG{n}{mc\PYGZus{}all}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{mc\PYGZus{}std}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{fit\PYGZus{}error\PYGZus{}monte\PYGZus{}carlo}\PYG{p}{(}\PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{,} 
	\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{n}{initMetals}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dataArrays}\PYG{o}{=}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{mod\PYGZus{}std}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error\PYGZus{}tensor\PYGZus{}monte\PYGZus{}carlo.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{error\_tensor\_monte\_carlo.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.556}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.525}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.756}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.695}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.957}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{7.466}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{9.948}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{19.294}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{monte\_carlo.png}}{]}

\noindent\sphinxincludegraphics{{monte_carlo}.png}


\subparagraph{Uncertainty from sample fraction}
\label{\detokenize{examples/pcs_fit_uncertainty:uncertainty-from-sample-fraction}}
\sphinxAtStartPar
A final, but generally not recommended method is to source noise from taking a random fraction of the data and conducting the fit for many iterations to then view the deviation in fitted parameters. This method is often called bootstrapping and is desirable if the experimental uncertainties are unknown and the PDB file does not contain models that capture structural unceratinty. The function {\hyperref[\detokenize{reference/generated/paramagpy.fit.fit_error_bootstrap:paramagpy.fit.fit_error_bootstrap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.fit\_error\_bootstrap()}}}}} will repeat the fit for many iterations, each time sampling the desired amount of the experimental data randomly.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Estimate uncertainty sourcing noise from sample fractions}
\PYG{p}{[}\PYG{n}{bs\PYGZus{}all}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{bs\PYGZus{}std}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{fit\PYGZus{}error\PYGZus{}bootstrap}\PYG{p}{(}\PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pcs}\PYG{p}{,} 
	\PYG{l+m+mi}{50}\PYG{p}{,} \PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{n}{initMetals}\PYG{o}{=}\PYG{p}{[}\PYG{n}{mFit}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dataArrays}\PYG{o}{=}\PYG{p}{[}\PYG{n}{parsedData}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{mod\PYGZus{}std}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{error\PYGZus{}tensor\PYGZus{}bootstrap.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{error\_tensor\_bootstrap.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.556}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}     \PYG{l+m+mf}{0.525}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.756}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.695}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.957}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{7.466}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{9.948}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{19.294}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{bootstrap.png}}{]}

\noindent\sphinxincludegraphics{{bootstrap}.png}

\sphinxAtStartPar
This piece of code is used to generate the Sanson\sphinxhyphen{}Flamsteed projection plots

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot Sanson\PYGZhy{}Flamsteed \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}

\PYG{k}{def} \PYG{n+nf}{transform}\PYG{p}{(}\PYG{n}{vector}\PYG{p}{)}\PYG{p}{:}
	\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{vector}
	\PYG{n}{theta} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arctan2}\PYG{p}{(}\PYG{n}{y}\PYG{p}{,} \PYG{n}{x}\PYG{p}{)}
	\PYG{n}{phi} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{np}\PYG{o}{.}\PYG{n}{arccos}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{pi}\PYG{o}{/}\PYG{l+m+mf}{2.}
	\PYG{k}{return} \PYG{n}{theta}\PYG{p}{,} \PYG{n}{phi}

\PYG{k}{for} \PYG{n}{name}\PYG{p}{,} \PYG{n}{mset} \PYG{o+ow}{in} \PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{models}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mod\PYGZus{}all}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monte\PYGZus{}carlo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{mc\PYGZus{}all}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bootstrap}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{bs\PYGZus{}all}\PYG{p}{)}\PYG{p}{]}\PYG{p}{:}
	\PYG{n}{spcoords} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
	\PYG{k}{for} \PYG{n}{m} \PYG{o+ow}{in} \PYG{n}{mset}\PYG{p}{:}
		\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{z} \PYG{o}{=} \PYG{n}{m}\PYG{o}{.}\PYG{n}{rotationMatrix}\PYG{o}{.}\PYG{n}{T}
		\PYG{n}{spcoords}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{tuple}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{n}{transform}\PYG{p}{,} \PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{points} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{spcoords}\PYG{p}{)}
	\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{100}\PYG{p}{)}
	\PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{111}\PYG{p}{,} \PYG{n}{projection}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hammer}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{theta}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{phi}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{grid}\PYG{p}{(}\PYG{p}{)}
	\PYG{k}{for} \PYG{n}{data}\PYG{p}{,} \PYG{n}{col}\PYG{p}{,} \PYG{n}{label} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{points}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
		\PYG{n}{theta}\PYG{p}{,} \PYG{n}{phi} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{data}\PYG{p}{)}
		\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{theta}\PYG{p}{,} \PYG{n}{phi}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mf}{0.4}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{n}{col}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{label}\PYG{p}{,} \PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
	\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}\PYGZcb{}}\PYG{l+s+s2}{.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{name}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Fit to PCS data with offset, RACS and RADS corrections}
\label{\detokenize{examples/pcs_fit_advanced_corrections:fit-to-pcs-data-with-offset-racs-and-rads-corrections}}\label{\detokenize{examples/pcs_fit_advanced_corrections:pcs-fit-advanced-corrections}}\label{\detokenize{examples/pcs_fit_advanced_corrections::doc}}

\subsection{RDC data}
\label{\detokenize{examples/index:rdc-data}}

\subsubsection{Fit Tensor to RDC Data}
\label{\detokenize{examples/rdc_fit:fit-tensor-to-rdc-data}}\label{\detokenize{examples/rdc_fit:rdc-fit}}\label{\detokenize{examples/rdc_fit::doc}}
\sphinxAtStartPar
This example shows how to fit a \({\Delta\chi}\)\sphinxhyphen{}tensor or equivalently, and alignment tensor to experimental RDC data. These data are taken from a Tb3+ tagged ubiquitin mutant:

\sphinxAtStartPar
Benjamin J. G. Pearce, Shereen Jabar, Choy\sphinxhyphen{}Theng Loh, Monika Szabo, Bim Graham, Gottfried Otting (2017) Structure restraints from heteronuclear pseudocontact shifts generated by lanthanide tags at two different sites \sphinxstyleemphasis{J. Biomol. NMR} 68:19\sphinxhyphen{}32


\paragraph{Downloads}
\label{\detokenize{examples/rdc_fit:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{2kox.pdb}}, \sphinxcode{\sphinxupquote{ubiquitin\_a28c\_c1\_Tb\_HN.rdc}} and \sphinxcode{\sphinxupquote{ubiquitin\_s57c\_c1\_Tb\_HN.rdc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{rdc\_fit.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/rdc_fit:script-explanation}}
\sphinxAtStartPar
Firstly, the necessary modules are imported from paramagpy. And the two RDC datasets are loaded. Because this PDB contains over 600 models, loading may take a few seconds

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/2kox.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the RDC data}
\PYG{n}{rawData1} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}rdc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/ubiquitin\PYGZus{}a28c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}HN.rdc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData2} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}rdc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/ubiquitin\PYGZus{}s57c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}HN.rdc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Associate RDC data with atoms of the PDB}
\PYG{n}{parsedData1} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData1}\PYG{p}{)}
\PYG{n}{parsedData2} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData2}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Two starting metals are initialised. It is important here to set the magnetic field strength and temperature.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Define an initial tensor}
\PYG{n}{mStart1} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{308.0}\PYG{p}{)}
\PYG{n}{mStart2} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{18.8}\PYG{p}{,} \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{308.0}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The alignment tensor is solved using the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy.fit.svd_fit_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.svd\_fit\_metal\_from\_rdc()}}}}} which return a tuple of \sphinxcode{\sphinxupquote{(metal, calculated)}}, where metal is the fitted metal, calculated is the calculated RDC values. The tensors are then saved. Note that we set the argument \sphinxcode{\sphinxupquote{ensembleAverage}} to \sphinxcode{\sphinxupquote{True}}. This is important because the PDB structure represents and MD simulation. If set to False, a much smaller tensor would be fit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the tensor using SVD}
\PYG{p}{[}\PYG{n}{sol1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data1}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}rdc}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mStart1}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
\PYG{p}{[}\PYG{n}{sol2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data2}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{svd\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}rdc}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mStart2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{parsedData2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save the fitted tensor to file}
\PYG{n}{sol1}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ubiquitin\PYGZus{}a28c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{sol2}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ubiquitin\PYGZus{}s57c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{ubiquitin\_a28c\_c1\_Tb\_tensor.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.776}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.397}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{16.022}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{52.299}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{83.616}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.800}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{308.000}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{ubiquitin\_s57c\_c1\_Tb\_tensor.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ax}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.930}
\PYG{n}{rh}    \PYG{o}{|} \PYG{l+m+mf}{1E\PYGZhy{}32} \PYG{n}{m}\PYG{o}{\PYGZca{}}\PYG{l+m+mi}{3} \PYG{p}{:}    \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.899}
\PYG{n}{x}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{y}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{z}     \PYG{o}{|}   \PYG{l+m+mf}{1E\PYGZhy{}10} \PYG{n}{m} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{a}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}     \PYG{l+m+mf}{9.976}
\PYG{n}{b}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{99.463}
\PYG{n}{g}     \PYG{o}{|}       \PYG{n}{deg} \PYG{p}{:}    \PYG{l+m+mf}{37.410}
\PYG{n}{mueff} \PYG{o}{|}        \PYG{n}{Bm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{shift} \PYG{o}{|}       \PYG{n}{ppm} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{B0}    \PYG{o}{|}         \PYG{n}{T} \PYG{p}{:}    \PYG{l+m+mf}{18.800}
\PYG{n}{temp}  \PYG{o}{|}         \PYG{n}{K} \PYG{p}{:}   \PYG{l+m+mf}{308.000}
\PYG{n}{t1e}   \PYG{o}{|}        \PYG{n}{ps} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\PYG{n}{taur}  \PYG{o}{|}        \PYG{n}{ns} \PYG{p}{:}     \PYG{l+m+mf}{0.000}
\end{sphinxVerbatim}

\sphinxAtStartPar
The experimental/calculated correlations are then plotted. The tensor is by default fitted to the ensemble averaged calculated values. Backcalculation of all models is shown here, as well as the ensemble average.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax1} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{211}\PYG{p}{)}
\PYG{n}{ax2} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{212}\PYG{p}{)}
\PYG{n}{ax1}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A28C\PYGZhy{}C1\PYGZhy{}Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax2}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{S57C\PYGZhy{}C1\PYGZhy{}Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{sol}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{,} \PYG{n}{data} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{p}{[}\PYG{n}{sol1}\PYG{p}{,}\PYG{n}{sol2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{ax1}\PYG{p}{,}\PYG{n}{ax2}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data1}\PYG{p}{,}\PYG{n}{data2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}

	\PYG{c+c1}{\PYGZsh{} Calculate ensemble averages}
	\PYG{n}{dataEAv} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{ensemble\PYGZus{}average}\PYG{p}{(}\PYG{n}{data}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Calculate the Q\PYGZhy{}factor}
	\PYG{n}{qfac} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{qfactor}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{ensembleAverage}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Plot all models}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{data}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
		\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{All models: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Plot the ensemble average}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{dataEAv}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dataEAv}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} 
		\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Ensemble Average: Q = }\PYG{l+s+si}{\PYGZob{}:5.4f\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{qfac}\PYG{p}{)}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
	\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

	\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
	\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{rdc\PYGZus{}fit.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{rdc\_fit.png}}{]}

\noindent\sphinxincludegraphics{{rdc_fit}.png}


\subsubsection{Calculate RDC from a known Tensor}
\label{\detokenize{examples/rdc_calculate:calculate-rdc-from-a-known-tensor}}\label{\detokenize{examples/rdc_calculate:rdc-calculate}}\label{\detokenize{examples/rdc_calculate::doc}}
\sphinxAtStartPar
This example shows how to calculate theoretical RDC values from a known \({\Delta\chi}\)\sphinxhyphen{}tensor which has been fitted from PCS data. Paramagpy allows seamless calculation of one PCS/PRE/RDC/CCR effect from a tensor fitted from another effect.


\paragraph{Downloads}
\label{\detokenize{examples/rdc_calculate:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}} and \sphinxcode{\sphinxupquote{calbindin\_Er\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{rdc\_calculate.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/rdc_calculate:script-explanation}}
\sphinxAtStartPar
First the relevant modules are loaded, the protein is loaded and the metal is loaded from file. The magnetic field strength and temperature are also set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{metal}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load the fitted tensor}
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{18.8}
\end{sphinxVerbatim}

\sphinxAtStartPar
A loop is made over the atoms of the protein. The amide H and N atoms are selected and then the RDC value is calculated. Finally the formated data is appended to list \sphinxcode{\sphinxupquote{forFile}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{forFile} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{atom} \PYG{o+ow}{in} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{get\PYGZus{}atoms}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
	\PYG{k}{if} \PYG{n}{atom}\PYG{o}{.}\PYG{n}{name} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
		\PYG{n}{residue} \PYG{o}{=} \PYG{n}{atom}\PYG{o}{.}\PYG{n}{parent}
		\PYG{n}{seq} \PYG{o}{=} \PYG{n}{residue}\PYG{o}{.}\PYG{n}{id}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
		\PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{residue}\PYG{p}{:}
			\PYG{n}{H} \PYG{o}{=} \PYG{n}{atom}
			\PYG{n}{N} \PYG{o}{=} \PYG{n}{residue}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
			\PYG{n}{rdc} \PYG{o}{=} \PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}rdc}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
			\PYG{n}{line} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}0:2d\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}1:\PYGZca{}3s\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}2:2d\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}3:\PYGZca{}3s\PYGZcb{}}\PYG{l+s+s2}{ }\PYG{l+s+si}{\PYGZob{}4:6.3f\PYGZcb{}}\PYG{l+s+s2}{ 0.0}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}
				\PYG{n}{seq}\PYG{p}{,} \PYG{n}{H}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{seq}\PYG{p}{,} \PYG{n}{N}\PYG{o}{.}\PYG{n}{name}\PYG{p}{,} \PYG{n}{rdc}\PYG{p}{)}
			\PYG{n}{forFile}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The formatted data is written to file:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{calbindin\PYGZus{}Er\PYGZus{}RDC\PYGZus{}calc.rdc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{w}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f}\PYG{p}{:}
	\PYG{n}{f}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{forFile}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_RDC\_calc.rdc}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYG{l+m+mi}{0}  \PYG{n}{H}   \PYG{l+m+mi}{0}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.724} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{1}  \PYG{n}{H}   \PYG{l+m+mi}{1}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.196} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{2}  \PYG{n}{H}   \PYG{l+m+mi}{2}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.993} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{4}  \PYG{n}{H}   \PYG{l+m+mi}{4}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.922} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{5}  \PYG{n}{H}   \PYG{l+m+mi}{5}  \PYG{n}{N}   \PYG{l+m+mf}{1.783} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{6}  \PYG{n}{H}   \PYG{l+m+mi}{6}  \PYG{n}{N}   \PYG{l+m+mf}{0.280} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{7}  \PYG{n}{H}   \PYG{l+m+mi}{7}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.906} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{8}  \PYG{n}{H}   \PYG{l+m+mi}{8}  \PYG{n}{N}   \PYG{l+m+mf}{1.056} \PYG{l+m+mf}{0.0}
 \PYG{l+m+mi}{9}  \PYG{n}{H}   \PYG{l+m+mi}{9}  \PYG{n}{N}   \PYG{l+m+mf}{0.713} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{10}  \PYG{n}{H}  \PYG{l+m+mi}{10}  \PYG{n}{N}   \PYG{l+m+mf}{0.213} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{11}  \PYG{n}{H}  \PYG{l+m+mi}{11}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.881} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{12}  \PYG{n}{H}  \PYG{l+m+mi}{12}  \PYG{n}{N}   \PYG{l+m+mf}{2.712} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{13}  \PYG{n}{H}  \PYG{l+m+mi}{13}  \PYG{n}{N}   \PYG{l+m+mf}{0.614} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{14}  \PYG{n}{H}  \PYG{l+m+mi}{14}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{2.346} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{15}  \PYG{n}{H}  \PYG{l+m+mi}{15}  \PYG{n}{N}   \PYG{l+m+mf}{1.659} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{16}  \PYG{n}{H}  \PYG{l+m+mi}{16}  \PYG{n}{N}   \PYG{l+m+mf}{0.648} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{17}  \PYG{n}{H}  \PYG{l+m+mi}{17}  \PYG{n}{N}   \PYG{l+m+mf}{0.383} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{18}  \PYG{n}{H}  \PYG{l+m+mi}{18}  \PYG{n}{N}   \PYG{l+m+mf}{0.420} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{19}  \PYG{n}{H}  \PYG{l+m+mi}{19}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.863} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{21}  \PYG{n}{H}  \PYG{l+m+mi}{21}  \PYG{n}{N}   \PYG{l+m+mf}{0.973} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{22}  \PYG{n}{H}  \PYG{l+m+mi}{22}  \PYG{n}{N}   \PYG{l+m+mf}{1.026} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{23}  \PYG{n}{H}  \PYG{l+m+mi}{23}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.613} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{24}  \PYG{n}{H}  \PYG{l+m+mi}{24}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.847} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{25}  \PYG{n}{H}  \PYG{l+m+mi}{25}  \PYG{n}{N}   \PYG{l+m+mf}{1.761} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{26}  \PYG{n}{H}  \PYG{l+m+mi}{26}  \PYG{n}{N}   \PYG{l+m+mf}{6.470} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{27}  \PYG{n}{H}  \PYG{l+m+mi}{27}  \PYG{n}{N}   \PYG{l+m+mf}{5.541} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{28}  \PYG{n}{H}  \PYG{l+m+mi}{28}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.334} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{29}  \PYG{n}{H}  \PYG{l+m+mi}{29}  \PYG{n}{N}   \PYG{l+m+mf}{3.624} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{30}  \PYG{n}{H}  \PYG{l+m+mi}{30}  \PYG{n}{N}   \PYG{l+m+mf}{6.673} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{31}  \PYG{n}{H}  \PYG{l+m+mi}{31}  \PYG{n}{N}   \PYG{l+m+mf}{3.952} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{32}  \PYG{n}{H}  \PYG{l+m+mi}{32}  \PYG{n}{N}   \PYG{l+m+mf}{1.658} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{33}  \PYG{n}{H}  \PYG{l+m+mi}{33}  \PYG{n}{N}   \PYG{l+m+mf}{5.449} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{34}  \PYG{n}{H}  \PYG{l+m+mi}{34}  \PYG{n}{N}   \PYG{l+m+mf}{7.370} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{35}  \PYG{n}{H}  \PYG{l+m+mi}{35}  \PYG{n}{N}   \PYG{l+m+mf}{1.033} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{36}  \PYG{n}{H}  \PYG{l+m+mi}{36}  \PYG{n}{N}   \PYG{l+m+mf}{1.136} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{38}  \PYG{n}{H}  \PYG{l+m+mi}{38}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.378} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{39}  \PYG{n}{H}  \PYG{l+m+mi}{39}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{6.979} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{40}  \PYG{n}{H}  \PYG{l+m+mi}{40}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.810} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{41}  \PYG{n}{H}  \PYG{l+m+mi}{41}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{3.187} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{42}  \PYG{n}{H}  \PYG{l+m+mi}{42}  \PYG{n}{N}   \PYG{l+m+mf}{2.415} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{43}  \PYG{n}{H}  \PYG{l+m+mi}{43}  \PYG{n}{N}   \PYG{l+m+mf}{1.710} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{44}  \PYG{n}{H}  \PYG{l+m+mi}{44}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.977} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{45}  \PYG{n}{H}  \PYG{l+m+mi}{45}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.467} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{46}  \PYG{n}{H}  \PYG{l+m+mi}{46}  \PYG{n}{N}   \PYG{l+m+mf}{3.243} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{47}  \PYG{n}{H}  \PYG{l+m+mi}{47}  \PYG{n}{N}   \PYG{l+m+mf}{3.937} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{48}  \PYG{n}{H}  \PYG{l+m+mi}{48}  \PYG{n}{N}   \PYG{l+m+mf}{7.047} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{49}  \PYG{n}{H}  \PYG{l+m+mi}{49}  \PYG{n}{N}   \PYG{l+m+mf}{4.577} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{50}  \PYG{n}{H}  \PYG{l+m+mi}{50}  \PYG{n}{N}   \PYG{l+m+mf}{3.718} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{51}  \PYG{n}{H}  \PYG{l+m+mi}{51}  \PYG{n}{N}   \PYG{l+m+mf}{4.519} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{52}  \PYG{n}{H}  \PYG{l+m+mi}{52}  \PYG{n}{N}   \PYG{l+m+mf}{6.077} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{53}  \PYG{n}{H}  \PYG{l+m+mi}{53}  \PYG{n}{N}   \PYG{l+m+mf}{2.940} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{54}  \PYG{n}{H}  \PYG{l+m+mi}{54}  \PYG{n}{N}   \PYG{l+m+mf}{2.541} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{55}  \PYG{n}{H}  \PYG{l+m+mi}{55}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.493} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{56}  \PYG{n}{H}  \PYG{l+m+mi}{56}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.159} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{57}  \PYG{n}{H}  \PYG{l+m+mi}{57}  \PYG{n}{N}   \PYG{l+m+mf}{4.948} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{58}  \PYG{n}{H}  \PYG{l+m+mi}{58}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.078} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{59}  \PYG{n}{H}  \PYG{l+m+mi}{59}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.759} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{60}  \PYG{n}{H}  \PYG{l+m+mi}{60}  \PYG{n}{N}   \PYG{l+m+mf}{0.161} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{61}  \PYG{n}{H}  \PYG{l+m+mi}{61}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.132} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{62}  \PYG{n}{H}  \PYG{l+m+mi}{62}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.719} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{63}  \PYG{n}{H}  \PYG{l+m+mi}{63}  \PYG{n}{N}   \PYG{l+m+mf}{4.025} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{64}  \PYG{n}{H}  \PYG{l+m+mi}{64}  \PYG{n}{N}   \PYG{l+m+mf}{5.929} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{65}  \PYG{n}{H}  \PYG{l+m+mi}{65}  \PYG{n}{N}   \PYG{l+m+mf}{2.363} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{66}  \PYG{n}{H}  \PYG{l+m+mi}{66}  \PYG{n}{N}   \PYG{l+m+mf}{2.477} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{67}  \PYG{n}{H}  \PYG{l+m+mi}{67}  \PYG{n}{N}   \PYG{l+m+mf}{8.265} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{68}  \PYG{n}{H}  \PYG{l+m+mi}{68}  \PYG{n}{N}   \PYG{l+m+mf}{5.078} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{69}  \PYG{n}{H}  \PYG{l+m+mi}{69}  \PYG{n}{N}   \PYG{l+m+mf}{3.724} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{70}  \PYG{n}{H}  \PYG{l+m+mi}{70}  \PYG{n}{N}   \PYG{l+m+mf}{7.743} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{71}  \PYG{n}{H}  \PYG{l+m+mi}{71}  \PYG{n}{N}   \PYG{l+m+mf}{2.188} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{72}  \PYG{n}{H}  \PYG{l+m+mi}{72}  \PYG{n}{N}   \PYG{l+m+mf}{4.911} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{73}  \PYG{n}{H}  \PYG{l+m+mi}{73}  \PYG{n}{N}   \PYG{l+m+mf}{7.514} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{74}  \PYG{n}{H}  \PYG{l+m+mi}{74}  \PYG{n}{N}  \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.001} \PYG{l+m+mf}{0.0}
\PYG{l+m+mi}{75}  \PYG{n}{H}  \PYG{l+m+mi}{75}  \PYG{n}{N}   \PYG{l+m+mf}{1.119} \PYG{l+m+mf}{0.0}
\end{sphinxVerbatim}


\subsection{PRE data}
\label{\detokenize{examples/index:pre-data}}

\subsubsection{Fit Tensor to PRE Data}
\label{\detokenize{examples/pre_fit_proton:fit-tensor-to-pre-data}}\label{\detokenize{examples/pre_fit_proton:pre-fit-proton}}\label{\detokenize{examples/pre_fit_proton::doc}}
\sphinxAtStartPar
This example demonstrates fitting of the rotational correlation time \({\tau_r}\) to 1H PRE data of calbindin D9k. You can fit any parameters of the \({\chi}\)\sphinxhyphen{}tensor you desire, such as position or magnitude as well.


\paragraph{Downloads}
\label{\detokenize{examples/pre_fit_proton:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}}, \sphinxcode{\sphinxupquote{calbindin\_Er\_H\_R2\_600.npc}} and \sphinxcode{\sphinxupquote{calbindin\_Tb\_H\_R2\_800.npc}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pre\_fit\_proton.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pre_fit_proton:script-explanation}}
\sphinxAtStartPar
Firstly, the necessary modules are imported from paramagpy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\end{sphinxVerbatim}

\sphinxAtStartPar
The protein is then loaded from a PDB file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The PRE data is loaded. Note that the Er data was recorded at 600 MHz and the Tb data was recorded at 800 MHz.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{rawData\PYGZus{}er} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}H\PYGZus{}R2\PYGZus{}600.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{rawData\PYGZus{}tb} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}H\PYGZus{}R2\PYGZus{}800.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The \({\Delta\chi}\)\sphinxhyphen{}tensors that were fitted from PCS data are loaded from file and the relevant \({B_0}\) magnetic field strengths are set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mStart\PYGZus{}er} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mStart\PYGZus{}tb} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{mStart\PYGZus{}er}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{14.1}
\PYG{n}{mStart\PYGZus{}tb}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{18.8}
\end{sphinxVerbatim}

\sphinxAtStartPar
Fitting of the rotational correlation time is done with the function {\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy.fit.nlr_fit_metal_from_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.nlr\_fit\_metal\_from\_pre()}}}}}. To fit position or \({\chi}\)\sphinxhyphen{}tensor magnitude, you can change the \sphinxcode{\sphinxupquote{params}} argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n}{m\PYGZus{}er}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{cal\PYGZus{}er}\PYG{p}{,}\PYG{p}{)} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pre}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart\PYGZus{}er}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data\PYGZus{}er}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{taur}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtypes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{p}{(}\PYG{n}{m\PYGZus{}tb}\PYG{p}{,}\PYG{p}{)}\PYG{p}{,} \PYG{p}{(}\PYG{n}{cal\PYGZus{}tb}\PYG{p}{,}\PYG{p}{)} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pre}\PYG{p}{(}
	\PYG{p}{[}\PYG{n}{mStart\PYGZus{}tb}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data\PYGZus{}tb}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{taur}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{rtypes}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fitted tensors are saved to file. Note that the Er dataset gives a reasonable \({\tau_r}\) of around 4 ns which is close to the literature value of 4.25 ns. However, the Tb dataset gives an unreasonably large value of 18 ns. This is due to magnetisation attenuation due to 1H\sphinxhyphen{}1H RDCs present during the relaxation evolution time as discussed in \sphinxhref{https://doi.org/10.1021/jacs.8b03858}{literature} giving rise to artificially large measured PREs for lanthanides with highly anisotropic \({\Delta\chi}\)\sphinxhyphen{}tensors. This is also reflected in the correlation plot below.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m\PYGZus{}er}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Er\PYGZus{}H\PYGZus{}R2\PYGZus{}600\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{m\PYGZus{}tb}\PYG{o}{.}\PYG{n}{save}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{calbindin\PYGZus{}Tb\PYGZus{}H\PYGZus{}R2\PYGZus{}800\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Er\_H\_R2\_600\_tensor.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ax    | 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}8.152
rh    | 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}4.911
x     |   1E\PYGZhy{}10 m :    25.786
y     |   1E\PYGZhy{}10 m :     9.515
z     |   1E\PYGZhy{}10 m :     6.558
a     |       deg :   125.841
b     |       deg :   142.287
g     |       deg :    41.758
mueff |        Bm :     9.581
shift |       ppm :     0.000
B0    |         T :    14.100
temp  |         K :   298.150
t1e   |        ps :     0.189
taur  |        ns :     3.923
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{calbindin\_Tb\_H\_R2\_800\_tensor.txt}}{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ax    | 1E\PYGZhy{}32 m\PYGZca{}3 :    30.375
rh    | 1E\PYGZhy{}32 m\PYGZca{}3 :    12.339
x     |   1E\PYGZhy{}10 m :    25.786
y     |   1E\PYGZhy{}10 m :     9.515
z     |   1E\PYGZhy{}10 m :     6.558
a     |       deg :   150.957
b     |       deg :   152.671
g     |       deg :    70.311
mueff |        Bm :     9.721
shift |       ppm :     0.000
B0    |         T :    18.800
temp  |         K :   298.150
t1e   |        ps :     0.251
taur  |        ns :    18.917
\end{sphinxVerbatim}

\sphinxAtStartPar
And the results are plotted.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cal\PYGZus{}er}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cal\PYGZus{}er}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Er: taur = }\PYG{l+s+si}{\PYGZob{}:3.1f\PYGZcb{}}\PYG{l+s+s2}{ ns}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mf}{1E9}\PYG{o}{*}\PYG{n}{m\PYGZus{}er}\PYG{o}{.}\PYG{n}{taur}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{cal\PYGZus{}tb}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{cal\PYGZus{}tb}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{cal}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{ms}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{c}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
	\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tb: taur = }\PYG{l+s+si}{\PYGZob{}:3.1f\PYGZcb{}}\PYG{l+s+s2}{ ns}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{l+m+mf}{1E9}\PYG{o}{*}\PYG{n}{m\PYGZus{}tb}\PYG{o}{.}\PYG{n}{taur}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}ylim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pre\PYGZus{}fit\PYGZus{}proton.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{pre_fit_proton}.png}


\subsubsection{Calculate 15N PREs with cross\sphinxhyphen{}correlation effects}
\label{\detokenize{examples/pre_calc_nitrogen:calculate-15n-pres-with-cross-correlation-effects}}\label{\detokenize{examples/pre_calc_nitrogen:pre-calc-nitrogen}}\label{\detokenize{examples/pre_calc_nitrogen::doc}}
\sphinxAtStartPar
This example shows how to PREs for 15N in the presence of CSA\sphinxhyphen{}Curie spin cross\sphinxhyphen{}correlation effects. \({\Delta\chi}\)\sphinxhyphen{}tensors are used from a previous PCS fitting.


\paragraph{Downloads}
\label{\detokenize{examples/pre_calc_nitrogen:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{4icbH\_mut.pdb}}, \sphinxcode{\sphinxupquote{calbindin\_Tb\_N\_R1\_600.pre}} and \sphinxcode{\sphinxupquote{calbindin\_Tb\_HN\_PCS\_tensor.txt}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pre\_calc\_nitrogen.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pre_calc_nitrogen:script-explanation}}
\sphinxAtStartPar
First the relevant modules are loaded, the protein and data are read and the data is parsed by the protein.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{metal}\PYG{p}{,} \PYG{n}{dataparse}

\PYG{c+c1}{\PYGZsh{} Load the PDB file}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/4icbH\PYGZus{}mut.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Load PRE data}
\PYG{n}{rawData} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}N\PYGZus{}R1\PYGZus{}600.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Parse PRE data}
\PYG{n}{data} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rawData}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The Tb tensor fitted from PCS data is loaded and the relevant parameters, in this case the magnetic field strength, temperature and rotational correlation time are set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{met} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{load\PYGZus{}tensor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/calbindin\PYGZus{}Tb\PYGZus{}HN\PYGZus{}PCS\PYGZus{}tensor.txt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{B0} \PYG{o}{=} \PYG{l+m+mf}{14.1}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{T} \PYG{o}{=} \PYG{l+m+mf}{298.0}
\PYG{n}{met}\PYG{o}{.}\PYG{n}{taur} \PYG{o}{=} \PYG{l+m+mf}{4.25E\PYGZhy{}9}
\end{sphinxVerbatim}

\sphinxAtStartPar
A loop is conducted over the nitrogen atoms that are present in the experimental data. The PRE is calculated using the function \sphinxcode{\sphinxupquote{paramagpy.metal.atom\_pre()}}. Calculations without CSA are appended to the list \sphinxcode{\sphinxupquote{cal}} and calculations including CSA cross\sphinxhyphen{}correlation with the Curie\sphinxhyphen{}spin relaxation are appended to the list \sphinxcode{\sphinxupquote{cal\_csa}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{exp} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{cal} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{cal\PYGZus{}csa} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{atom}\PYG{p}{,} \PYG{n}{pre}\PYG{p}{,} \PYG{n}{err} \PYG{o+ow}{in} \PYG{n}{data}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{err}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
	\PYG{n}{exp}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{pre}\PYG{p}{)}
	\PYG{n}{cal}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}pre}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}
	\PYG{n}{cal\PYGZus{}csa}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{met}\PYG{o}{.}\PYG{n}{atom\PYGZus{}pre}\PYG{p}{(}\PYG{n}{atom}\PYG{p}{,} \PYG{n}{rtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{r1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{csa}\PYG{o}{=}\PYG{n}{atom}\PYG{o}{.}\PYG{n}{csa}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally the data are plotted. Clearly CSA cross\sphinxhyphen{}correlation is a big effect for backbone nitrogen atoms and should always be taken into account for Curie\sphinxhyphen{}spin calculations. Also note the existence and correct prediction of negative PREs!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{cal}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Standard Theory}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{,} \PYG{n}{cal\PYGZus{}csa}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CSA x Curie spin}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pre\PYGZus{}calc\PYGZus{}nitrogen.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pre\_calc\_nitrogen.png}}{]}

\noindent\sphinxincludegraphics{{pre_calc_nitrogen}.png}


\subsubsection{Fit spectral power density tensor}
\label{\detokenize{examples/pre_fit_aniso_dipolar:fit-spectral-power-density-tensor}}\label{\detokenize{examples/pre_fit_aniso_dipolar:pre-fit-aniso-dipolar}}\label{\detokenize{examples/pre_fit_aniso_dipolar::doc}}
\sphinxAtStartPar
This example shows how to fit the spectral power density tensor to anisotropic PREs. The data and theory are derived from \sphinxurl{https://doi.org/10.1039/C8CP01332B}.


\paragraph{Downloads}
\label{\detokenize{examples/pre_fit_aniso_dipolar:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{parashift\_Tb.pdb}} and \sphinxcode{\sphinxupquote{parashift\_Tb\_R1\_exp.pre}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{pre\_fit\_aniso\_dipolar.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/pre_fit_aniso_dipolar:script-explanation}}
\sphinxAtStartPar
Load the relevant modules, read the PDB coordinates and experimental PRE values. Parse the values.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{metal}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/parashift\PYGZus{}Tb.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{pre\PYGZus{}exp} \PYG{o}{=} \PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pre}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/parashift\PYGZus{}Tb\PYGZus{}R1\PYGZus{}exp.pre}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{exp} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{pre\PYGZus{}exp}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The spectral power density tensor is written here explicitly and set to the attribute \sphinxcode{\sphinxupquote{g\_tensor}}. The values here are sourced from the original paper, and arise from the robust linear fit to the experimental data. We will use this tensor for comparison to the fit achieved by paramagpy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{taur}\PYG{o}{=}\PYG{l+m+mf}{0.42E\PYGZhy{}9}\PYG{p}{,} \PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{300.0}\PYG{p}{)}
\PYG{n}{m}\PYG{o}{.}\PYG{n}{set\PYGZus{}lanthanide}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{m}\PYG{o}{.}\PYG{n}{g\PYGZus{}tensor} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}
	\PYG{p}{[}\PYG{l+m+mf}{1754.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{859.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{207.0}\PYG{p}{]}\PYG{p}{,}
	\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{859.0}\PYG{p}{,} \PYG{l+m+mf}{2285.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{351.0}\PYG{p}{]}\PYG{p}{,}
	\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{207.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{351.0}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{196.0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)} \PYG{o}{*} \PYG{l+m+mf}{1E\PYGZhy{}60}
\end{sphinxVerbatim}

\sphinxAtStartPar
An starting tensor with no parameters is also initialised and will be used for fitting to the exerimental data with paramagpy.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{m0} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{taur}\PYG{o}{=}\PYG{l+m+mf}{0.42E\PYGZhy{}9}\PYG{p}{,} \PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{1.0}\PYG{p}{,} \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{300.0}\PYG{p}{)}
\PYG{n}{m0}\PYG{o}{.}\PYG{n}{set\PYGZus{}lanthanide}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
The fit is conducted by setting the \sphinxcode{\sphinxupquote{usegsbm}} flag to \sphinxcode{\sphinxupquote{True}}. This uses anisotropic SBM theory to fit the spectral power density tensor in place of the isotropic SBM theory. The relevant fitting parameters must be specified as \sphinxcode{\sphinxupquote{\textquotesingle{}t1e\textquotesingle{}, \textquotesingle{}gax\textquotesingle{}, \textquotesingle{}grh\textquotesingle{}, \textquotesingle{}a\textquotesingle{},\textquotesingle{}b\textquotesingle{},\textquotesingle{}g\textquotesingle{}}} which represent the electronic relaxation time, the axial and rhombic componenets of the power spectral density tensor and the 3 Euler angles alpha, beta and gamma respectively. Note that the fitted \sphinxcode{\sphinxupquote{t1e}} parameter is only an estimate of the electronic relaxation time.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{mfit}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{data}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fit}\PYG{o}{.}\PYG{n}{nlr\PYGZus{}fit\PYGZus{}metal\PYGZus{}from\PYGZus{}pre}\PYG{p}{(}\PYG{p}{[}\PYG{n}{m0}\PYG{p}{]}\PYG{p}{,} \PYG{p}{[}\PYG{n}{exp}\PYG{p}{]}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t1e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{gax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{grh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{,} 
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally the results of the fit are plotted alongside the isotropic theory and the literature fit. Note that the difference in the fit from paramagpy is small, and probably arises because the original paper uses a \sphinxtitleref{Robust} linear fit, which may include weighting with experimental uncertainties. However paramagpy weights values evely here because the experimental uncertainties are unknown.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pos} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{o}{.}\PYG{n}{position} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{exp}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{gam} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{o}{.}\PYG{n}{gamma} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{exp}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{fig} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{figure}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{ax} \PYG{o}{=} \PYG{n}{fig}\PYG{o}{.}\PYG{n}{add\PYGZus{}subplot}\PYG{p}{(}\PYG{l+m+mi}{111}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3200}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3200}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mfit}\PYG{o}{.}\PYG{n}{fast\PYGZus{}sbm\PYGZus{}r1}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{,} \PYG{n}{gam}\PYG{p}{)}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{iso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{mfit}\PYG{o}{.}\PYG{n}{fast\PYGZus{}g\PYGZus{}sbm\PYGZus{}r1}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{,} \PYG{n}{gam}\PYG{p}{)}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{aniso}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{exp}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{m}\PYG{o}{.}\PYG{n}{fast\PYGZus{}g\PYGZus{}sbm\PYGZus{}r1}\PYG{p}{(}\PYG{n}{pos}\PYG{p}{,} \PYG{n}{gam}\PYG{p}{)}\PYG{p}{,} \PYG{n}{marker}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{literature fit}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3200}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3200}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R1 experimental /Hz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{R1 calcualted /Hz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Tb parashift R1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pre\PYGZus{}fit\PYGZus{}aniso\PYGZus{}dipolar.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{pre\_fit\_aniso\_dipolar.png}}{]}

\noindent\sphinxincludegraphics{{pre_fit_aniso_dipolar}.png}


\subsection{CCR data}
\label{\detokenize{examples/index:ccr-data}}

\subsubsection{Calculate Cross\sphinxhyphen{}correlated Relaxation}
\label{\detokenize{examples/ccr_calculate:calculate-cross-correlated-relaxation}}\label{\detokenize{examples/ccr_calculate:ccr-calculate}}\label{\detokenize{examples/ccr_calculate::doc}}
\sphinxAtStartPar
This example shows how to calculate dipole\sphinxhyphen{}dipole/Curie\sphinxhyphen{}spin cross\sphinxhyphen{}correlated relaxation as measured for data in the literature by \sphinxhref{https://doi.org/10.1023/A:1024926126239}{Pintacuda et. al.}


\paragraph{Downloads}
\label{\detokenize{examples/ccr_calculate:downloads}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Download the data files \sphinxcode{\sphinxupquote{1bzrH.pdb}}, \sphinxcode{\sphinxupquote{myoglobin\_cn.ccr}} and \sphinxcode{\sphinxupquote{myoglobin\_f.ccr}} from \sphinxhref{https://github.com/henryorton/paramagpy/tree/master/examples/data\_files/}{here}:

\item {} 
\sphinxAtStartPar
Download the script \sphinxcode{\sphinxupquote{ccr\_calculate.py}}

\end{itemize}


\paragraph{Script + Explanation}
\label{\detokenize{examples/ccr_calculate:script-explanation}}
\sphinxAtStartPar
First the relevant modules are loaded, and the iron atom (paramagnetic centre) is identified as the variable \sphinxcode{\sphinxupquote{ironAtom}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{paramagpy} \PYG{k+kn}{import} \PYG{n}{protein}\PYG{p}{,} \PYG{n}{fit}\PYG{p}{,} \PYG{n}{dataparse}\PYG{p}{,} \PYG{n}{metal}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{c+c1}{\PYGZsh{} Load the PDB file and get iron centre}
\PYG{n}{prot} \PYG{o}{=} \PYG{n}{protein}\PYG{o}{.}\PYG{n}{load\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../data\PYGZus{}files/1bzrH.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{ironAtom} \PYG{o}{=} \PYG{n}{prot}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{H\PYGZus{}HEM}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{154}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\sphinxAtStartPar
Two paramagnetic centres are defined for the high and low spin iron atom. The positions are set to that of the iron centre along with other relevant parameters. The measured isotropic \({\chi}\)\sphinxhyphen{}tensor magnitudes are also set.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{met\PYGZus{}cn} \PYG{o}{=} \PYG{n}{metal}\PYG{o}{.}\PYG{n}{Metal}\PYG{p}{(}\PYG{n}{position}\PYG{o}{=}\PYG{n}{ironAtom}\PYG{o}{.}\PYG{n}{position}\PYG{p}{,} 
					 \PYG{n}{B0}\PYG{o}{=}\PYG{l+m+mf}{18.79}\PYG{p}{,} 
					 \PYG{n}{temperature}\PYG{o}{=}\PYG{l+m+mf}{303.0}\PYG{p}{,}
					 \PYG{n}{taur}\PYG{o}{=}\PYG{l+m+mf}{5.7E\PYGZhy{}9}\PYG{p}{)}
\PYG{n}{met\PYGZus{}f} \PYG{o}{=} \PYG{n}{met\PYGZus{}cn}\PYG{o}{.}\PYG{n}{copy}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{met\PYGZus{}cn}\PYG{o}{.}\PYG{n}{iso} \PYG{o}{=} \PYG{l+m+mf}{4.4E\PYGZhy{}32}
\PYG{n}{met\PYGZus{}f}\PYG{o}{.}\PYG{n}{iso} \PYG{o}{=} \PYG{l+m+mf}{30.1E\PYGZhy{}32}
\end{sphinxVerbatim}

\sphinxAtStartPar
The experimental data are loaded and parsed by the protein.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{data\PYGZus{}cn} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}ccr}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/myoglobin\PYGZus{}cn.ccr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{data\PYGZus{}f} \PYG{o}{=} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}ccr}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{../data\PYGZus{}files/myoglobin\PYGZus{}f.ccr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
A loop is conducted over the atoms contained in the experimental data and the CCR rate is calculated using the function {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy.metal.Metal.atom_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.atom\_ccr()}}}}}. These are appended to lists \sphinxcode{\sphinxupquote{compare\_cn}} and \sphinxcode{\sphinxupquote{compare\_f}}.

\sphinxAtStartPar
Note that the two H and N atoms are provided. The first atom is the nuclear spin undergoing active relaxation. The second atom is the coupling partner. Thus by swapping the H and N atoms to give \sphinxcode{\sphinxupquote{atom\_ccr(N, H)}}, the differential line broadening can be calculated in the indirect dimension.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Calculate the cross\PYGZhy{}correlated realxation}
\PYG{n}{compare\PYGZus{}cn} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{n}{error} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}cn}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atx}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{err}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
	\PYG{n}{delta} \PYG{o}{=} \PYG{n}{met\PYGZus{}cn}\PYG{o}{.}\PYG{n}{atom\PYGZus{}ccr}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
	\PYG{n}{compare\PYGZus{}cn}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{value}\PYG{p}{,} \PYG{n}{delta}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{compare\PYGZus{}f} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{value}\PYG{p}{,} \PYG{n}{error} \PYG{o+ow}{in} \PYG{n}{data\PYGZus{}f}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atm}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{atx}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{exp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{err}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{p}{:}
	\PYG{n}{delta} \PYG{o}{=} \PYG{n}{met\PYGZus{}f}\PYG{o}{.}\PYG{n}{atom\PYGZus{}ccr}\PYG{p}{(}\PYG{n}{H}\PYG{p}{,} \PYG{n}{N}\PYG{p}{)}
	\PYG{n}{compare\PYGZus{}f}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{p}{(}\PYG{n}{value}\PYG{p}{,} \PYG{n}{delta}\PYG{o}{*}\PYG{l+m+mf}{0.5}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Finally a correlation plot is made.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Plot the correlation \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k+kn}{from} \PYG{n+nn}{matplotlib} \PYG{k+kn}{import} \PYG{n}{pyplot} \PYG{k}{as} \PYG{n}{plt}
\PYG{n}{fig}\PYG{p}{,} \PYG{n}{ax} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot the data correlations}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{compare\PYGZus{}cn}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myo\PYGZus{}cn}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{scatter}\PYG{p}{(}\PYG{o}{*}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{n}{compare\PYGZus{}f}\PYG{p}{)}\PYG{p}{,} \PYG{n}{s}\PYG{o}{=}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{myo\PYGZus{}f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Plot a diagonal}
\PYG{n}{l}\PYG{p}{,} \PYG{n}{h} \PYG{o}{=} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{get\PYGZus{}xlim}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZhy{}k}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{zorder}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylim}\PYG{p}{(}\PYG{n}{l}\PYG{p}{,}\PYG{n}{h}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Make axis labels and save figure}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Experiment}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Calculated}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{ax}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{fig}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ccr\PYGZus{}calculate.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstyleemphasis{Output:} {[}\sphinxcode{\sphinxupquote{ccr\_calculate.png}}{]}

\noindent\sphinxincludegraphics{{ccr_calculate}.png}


\section{Graphic User Interface (GUI)}
\label{\detokenize{paramagpy_gui:graphic-user-interface-gui}}\label{\detokenize{paramagpy_gui:paramagpy-gui}}\label{\detokenize{paramagpy_gui::doc}}
\sphinxAtStartPar
Paramagpy is equipped with a GUI which is cross\sphinxhyphen{}platform and contains most of the functionality of the scripted module. This gives a rapid way for new users to fit and compare PCS, RDC and PRE effects.


\subsection{YouTube Tutorial}
\label{\detokenize{paramagpy_gui:youtube-tutorial}}
\sphinxAtStartPar
\sphinxhref{https://youtu.be/MAoBItSac-g}{Check out the tutorial on YouTube}




\subsection{Running the GUI}
\label{\detokenize{paramagpy_gui:running-the-gui}}
\sphinxAtStartPar
To run the GUI, first open the python inperpreter in the terminal

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} python3
Python \PYG{l+m}{3}.5.2 \PYG{o}{(}default, Nov \PYG{l+m}{23} \PYG{l+m}{2017}, \PYG{l+m}{16}:37:01\PYG{o}{)}
\PYG{o}{[}GCC \PYG{l+m}{5}.4.0 \PYG{l+m}{20160609}\PYG{o}{]} on linux
Type \PYG{l+s+s2}{\PYGZdq{}help\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}copyright\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}credits\PYGZdq{}} or \PYG{l+s+s2}{\PYGZdq{}license\PYGZdq{}} \PYG{k}{for} more information.
\PYGZgt{}\PYGZgt{}\PYGZgt{}
\end{sphinxVerbatim}

\sphinxAtStartPar
Then import paramagpy and start the gui with \sphinxcode{\sphinxupquote{paramagpy.gui.run()}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} python3
Python \PYG{l+m}{3}.5.2 \PYG{o}{(}default, Nov \PYG{l+m}{23} \PYG{l+m}{2017}, \PYG{l+m}{16}:37:01\PYG{o}{)}
\PYG{o}{[}GCC \PYG{l+m}{5}.4.0 \PYG{l+m}{20160609}\PYG{o}{]} on linux
Type \PYG{l+s+s2}{\PYGZdq{}help\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}copyright\PYGZdq{}}, \PYG{l+s+s2}{\PYGZdq{}credits\PYGZdq{}} or \PYG{l+s+s2}{\PYGZdq{}license\PYGZdq{}} \PYG{k}{for} more information.
\PYGZgt{}\PYGZgt{}\PYGZgt{} import paramagpy
\PYGZgt{}\PYGZgt{}\PYGZgt{} paramagpy.gui.run\PYG{o}{(}\PYG{o}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Alternatively you can simply execute the following from the command line

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} \PYG{n+nb}{echo} \PYG{l+s+s2}{\PYGZdq{}import paramagpy; paramagpy.gui.run()\PYGZdq{}} \PYG{p}{|} python3
\end{sphinxVerbatim}

\sphinxAtStartPar
If all this fails, you can contact the author for a prebuilt executable at \sphinxhref{mailto:henry.orton@anu.edu.au}{henry.orton@anu.edu.au}

\noindent\sphinxincludegraphics{{paramagpy_gui_annot}.png}


\section{NMR Software Macros}
\label{\detokenize{nmr_software_macros/index:nmr-software-macros}}\label{\detokenize{nmr_software_macros/index:nmr-software-macros-index}}\label{\detokenize{nmr_software_macros/index::doc}}
\sphinxAtStartPar
Paramagpy includes scripts for reading/writing PCS values directly from popular NMR software. This drastically improves the iterative process of tensor fitting.


\subsection{CCPNMR Analysis 2.4}
\label{\detokenize{nmr_software_macros/index:ccpnmr-analysis-2-4}}
\sphinxAtStartPar
Download the two scripts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{paramagpy\_ccpnmr\_macro.py}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{paramagpy\_fit\_pcs.py}}

\end{itemize}

\sphinxAtStartPar
In the first line of the script \sphinxtitleref{paramagpy\_fit\_pcs.py}, replace the shebang with the path to the python version on your machine that contains the paramagpy installation. On my computer this is set to.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+ch}{\PYGZsh{}!/usr/bin/python3}
\end{sphinxVerbatim}

\sphinxAtStartPar
Open CCPNMR analysis and navigate to Menu\sphinxhyphen{}\textgreater{}Macro\sphinxhyphen{}\textgreater{}Organise Macros. At the lower right click \sphinxtitleref{Add Macro} and open the script \sphinxtitleref{paramagpy\_ccpnmr\_macro.py}, then select \sphinxtitleref{paramagpyMACRO} and click \sphinxtitleref{Load Macro}. You can then select if from the list and click \sphinxtitleref{Run} to reveal the screen below.

\noindent\sphinxincludegraphics{{ccpnmr_screen}.png}

\sphinxAtStartPar
The popup window allows you to select a diamagnetic and paramagnetic spectrum and has 3 available buttons:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Write PCS: This will calculate the difference between assigned peaks in the paramagnetic and diamagnetic spectra and write them to a .npc file (as specified in the relevant field).

\item {} 
\sphinxAtStartPar
Fit Tensor: This will call the paramagpy script \sphinxtitleref{paramagpy\_fit\_pcs.py} to fit the tensor the the written PCS values.

\item {} 
\sphinxAtStartPar
Read PCS: This will read back\sphinxhyphen{}calculated PCS values from file (as specified in the relevant field) and plot the expected peaks on the paramagnetic spectrum in red.

\end{itemize}

\sphinxAtStartPar
Note, to alter the parameters for fitting of the PCS tensor, you can change the values within the script \sphinxtitleref{paramagpy\_fit\_pcs.py}.


\subsection{Sparky}
\label{\detokenize{nmr_software_macros/index:sparky}}
\sphinxAtStartPar
Download the 3 scripts:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{paramagpy\_sparky\_macro.py}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sparky\_init.py}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{paramagpy\_fit\_pcs.py}}

\end{itemize}

\sphinxAtStartPar
Place the first two scripts \sphinxtitleref{paramagpy\_sparky\_macro.py} and \sphinxtitleref{sparky\_init.py} in the Sparky directory \sphinxtitleref{\textasciitilde{}/Sparky/Python}. Note that the Sparky directory usually contains the \sphinxtitleref{Projects}, \sphinxtitleref{Lists} and \sphinxtitleref{Save} folders. You may need to create the \sphinxtitleref{Python} directory here in which to place the two scripts.

\sphinxAtStartPar
Place the third script \sphinxtitleref{paramagpy\_fit\_pcs.py} in your home directory.

\sphinxAtStartPar
Open Sparky and navigate to Extensions\sphinxhyphen{}\textgreater{}Read and write PCS files.

\noindent\sphinxincludegraphics{{sparky_screen}.png}

\sphinxAtStartPar
The popup window allows you to select a diamagnetic and paramagnetic spectrum and has 3 available buttons:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Write PCS: This will calculate the difference between assigned peaks in the paramagnetic and diamagnetic spectra and write them to a .npc file (as specified in the relevant field).

\item {} 
\sphinxAtStartPar
Read PCS: This will read back\sphinxhyphen{}calculated PCS values from file (as specified in the relevant field) and plot the expected peaks on the paramagnetic spectrum in green.

\item {} 
\sphinxAtStartPar
Clear PCS: This will remove all calculated PCS peaks from the spectrum.

\end{itemize}

\sphinxAtStartPar
Note, to perform the tensor fitting, you will need to execute the paramagpy script in a separate terminal including an argument with the experimental PCS file such as:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
user@computer:\PYGZti{}\PYGZdl{} ./paramagpy\PYGZus{}fit\PYGZus{}pcs.py pcsexp.npc
\end{sphinxVerbatim}

\sphinxAtStartPar
To alter the parameters for fitting of the PCS tensor, you can change the values within the script \sphinxtitleref{paramagpy\_fit\_pcs.py}.


\section{Mathematical Proofs}
\label{\detokenize{mathematical_proofs:mathematical-proofs}}\label{\detokenize{mathematical_proofs::doc}}

\subsection{Proof of equivalence between the matrix representation of Curie\sphinxhyphen{}spin dipole\textendash{}dipole cross\sphinxhyphen{}correlated relaxation (Paramagpy implementation) and the original description by Ghose and Prestegard}
\label{\detokenize{mathematical_proofs:proof-of-equivalence-between-the-matrix-representation-of-curie-spin-dipole-dipole-cross-correlated-relaxation-paramagpy-implementation-and-the-original-description-by-ghose-and-prestegard}}
\sphinxAtStartPar
This proof concerns equations 24\sphinxhyphen{}27 of the \sphinxhref{https://doi.org/10.5194/mr-2019-3}{article} on the software Paramagpy, which describe the cross\sphinxhyphen{}correlated relaxation between the Curie spin and dipole\textendash{}dipole relaxation mechanisms. The equations 24\sphinxhyphen{}27 follow the matrix representation of relaxation theory (equations 20\sphinxhyphen{}21) by \sphinxhref{https://doi.org/10.1039/C8CP01332B}{Suturina et al.} . It is shown below that these equations are equivalent to the equations established previously by \sphinxhref{https://doi.org/10.1006/jmre.1997.1227}{Ghose and Prestegard} and reported in slightly modified form by \sphinxhref{https://doi.org/10.1006/jmre.2001.2378}{Bertini et al.}. The proof begins with equations 24\sphinxhyphen{}27 of the manuscript and describes their rearrangement into the form given by \sphinxhref{https://doi.org/10.1006/jmre.2001.2378}{Bertini et al.}

\sphinxAtStartPar
For a specific example, we consider the case of a $^{\text{15}}$N \sphinxhyphen{} $^{\text{1}}$H group, with the Curie\sphinxhyphen{}spin shielding tensor \(\sigma\) at the site of the $^{\text{1}}$H spin located at \(\vec r=[x,y,z]\) and distance \(r\) from the paramagnetic centre.
\begin{equation*}
\begin{split}\sigma = \frac{1}{4\pi r^5}
\begin{bmatrix}
(3x^2-r^2) & 3xy & 3xz\\
3xy & (3y^2-r^2) & 3yz\\
3xz & 3yz & (3z^2 - r^2)
\end{bmatrix}.
\begin{bmatrix}
\chi_{xx} & \chi_{xy} & \chi_{xz}\\
\chi_{xy} & \chi_{yy} & \chi_{yz}\\
\chi_{xz} & \chi_{yz} & \chi_{zz}
\end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
We  choose the orientation of the electron\textendash{}$^{\text{1}}$H vector to be aligned with the \(z\)\sphinxhyphen{}axis such that \(z\rightarrow r\). In the case of an isotropic magnetic susceptibility, \(x=y=0\) and the \(\chi\) tensor is represented by a diagonal matrix with three identical elements \(\chi_\text{iso}\), yielding the following simplification
\begin{equation*}
\begin{split}\sigma &= \frac{1}{4\pi r^5}
\begin{bmatrix}
-r^2 & 0 & 0\\
0 & -r^2 & 0\\
0 & 0 & 2r^2
\end{bmatrix}.
\begin{bmatrix}
\chi_\text{iso} & 0 & 0\\
0 & \chi_\text{iso} & 0\\
0 & 0 & \chi_\text{iso}
\end{bmatrix}\\
&= \xi_\text{DSA}
\begin{bmatrix}
-r^2 & 0 & 0\\
0 & -r^2 & 0\\
0 & 0 & 2r^2
\end{bmatrix}\\
\text{where} \qquad \xi_\text{DSA}&=\frac{\chi_\text{iso}}{4\pi r^5}\end{split}
\end{equation*}
\sphinxAtStartPar
The nuclear dipole shielding tensor arising from the $^{\text{15}}$N spin can be described in the same coordinate frame for an arbitrary orientation of the bond vector \(\vec r_\text{HN}=[x,y,z]\) with bond length \(r_\text{HN}\) by
\begin{equation*}
\begin{split}\sigma_N &= \frac{1}{B_0}\frac{\mu_0}{4\pi}\gamma_N\hbar I \left[ 3\frac{\vec r_\text{HN}\otimes \vec r_\text{HN}^T}{r_\text{HN}^5} - \frac{\mathbb{I}_3}{r_\text{HN}^3} \right]\\
\sigma_N &= \xi_\text{DD}
\begin{bmatrix}
(3x^2-r_\text{HN}^2) & 3xy & 3xz\\
3xy & (3y^2-r_\text{HN}^2) & 3yz\\
3xz & 3yz & (3z^2 - r_\text{HN}^2)
\end{bmatrix}\\
\text{where} \qquad \xi_\text{DD} &= \frac{1}{B_0} \frac{\mu_0}{4\pi} \frac{\gamma_N\hbar I}{r_\text{HN}^5}\end{split}
\end{equation*}
\sphinxAtStartPar
and \(x\), \(y\), \(z\) denote the coordinates of the $^{\text{15}}$N spin relative to the $^{\text{1}}$H spin.

\sphinxAtStartPar
The effective shielding tensor at the site of the $^{\text{1}}$H spin, when the $^{\text{15}}$N partner is in the spin\sphinxhyphen{}up state, is given by the sum of the two tensors
\begin{equation*}
\begin{split}\sigma_\uparrow &= \sigma + \sigma_N\\
&=
\begin{bmatrix}
(3x^2-r_\text{HN}^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}  & (3xy)\xi_\text{DD} & (3xz)\xi_\text{DD}\\
(3xy)\xi_\text{DD} & (3y^2-r_\text{HN}^2)\xi_\text{DD} -(r^2)\xi_\text{DSA} & (3yz)\xi_\text{DD}\\
(3xz)\xi_\text{DD} & (3yz)\xi_\text{DD} & (3z^2 - r_\text{HN}^2)\xi_\text{DD} +(2r^2)\xi_\text{DSA}
\end{bmatrix}\end{split}
\end{equation*}
\sphinxAtStartPar
Note that this matrix is symmetric. Therefore we can ignore equation 18 of the main text and only need to substitute matrix elements into equation 19. Expanding and simplifying (via symbolic processing in the program Mathematica), this yields
\begin{equation*}
\begin{split}\Delta(\sigma_\uparrow)^2={}& \sigma_{xx}^2+\sigma_{yy}^2+\sigma_{zz}^2
-\sigma_{xx}\sigma_{yy}-\sigma_{xx}\sigma_{zz}-\sigma_{yy}\sigma_{zz} \notag\\
&+\frac{3}{4}\left[
((\sigma_{xy}+\sigma_{yx})^2 + (\sigma_{xz}+\sigma_{zx})^2 + (\sigma_{yz}+\sigma_{zy})^2\right]\\
={}&
\left((3x^2-r_\text{HN}^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}\right)^2 \notag\\
&+\left((3y^2-r^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}\right)^2 \notag\\
&+\left((3z^2 - r_\text{HN}^2)\xi_\text{DD} +(2r^2)\xi_\text{DSA}\right)^2 \notag\\
&-\left((3x^2-r_\text{HN}^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}\right)
\left((3y^2-r^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}\right) \notag\\
&-\left((3x^2-r_\text{HN}^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}\right)
\left((3z^2 - r_\text{HN}^2)\xi_\text{DD} +(2r^2)\xi_\text{DSA}\right) \notag\\
&-\left((3y^2-r^2)\xi_\text{DD} -(r^2)\xi_\text{DSA}\right)
\left((3z^2 - r_\text{HN}^2)\xi_\text{DD} +(2r^2)\xi_\text{DSA}\right) \notag\\
&+\frac{3}{4}\left[
(6xy\xi_\text{DD})^2
+ (6xz\xi_\text{DD})^2
+ (6yz\xi_\text{DD})^2
\right]\\
={}& 9\xi_\text{DD}^2r_\text{HN}^4 + 9\xi_\text{DSA}^2r^4 -
9\xi_\text{DD}(r_\text{HN}^2-3z^2)\xi_\text{DSA}r^2\end{split}
\end{equation*}
\sphinxAtStartPar
The angle \(\theta\) between the electron\sphinxhyphen{}nuclear vector \(\vec r\) and the nuclear bond vector \(\vec r_\text{HN}\) is captured by the dot product formula
\begin{equation*}
\begin{split}\vec r.\vec r_\text{HN} &= |\vec r||\vec r_\text{HN}| \cos{\theta}\\
\implies \qquad [0,0,r].[x,y,z] &= r.r_\text{HN} \cos{\theta}\\
\implies \qquad  z &= r_\text{HN} \cos{\theta}\end{split}
\end{equation*}
\sphinxAtStartPar
Using above equation to substitute \$z\$ yields
\begin{equation*}
\begin{split}\Delta(\sigma_\uparrow)^2= 9\xi_\text{DD}^2r_\text{HN}^4 + 9\xi_\text{DSA}^2r^4 - 9\xi_\text{DD}r_\text{HN}^2(1-3\cos^2{\theta})\xi_\text{DSA}r^2\end{split}
\end{equation*}
\sphinxAtStartPar
where the first two terms account for the dipolar and Curie spin auto\sphinxhyphen{}relaxation terms respectively, and the last term accounts for their cross\sphinxhyphen{}correlation. The \(R_2\) relaxation rate can be calculated by substitution of \(\Delta^2\) into equation 21 of the main text.
\begin{equation*}
\begin{split}R_2^\text{Curie}(\sigma_\uparrow) = \frac{1}{45}\omega^2 \left[4\mathbf{J}(0) + 3\mathbf{J}(\omega)\right]
\left( 9\xi_\text{DD}^2r_\text{HN}^4 + 9\xi_\text{DSA}^2r^4 +
9\xi_\text{DD}r_\text{HN}^2(3\cos^2{\theta}-1)\xi_\text{DSA}r^2 \right)\end{split}
\end{equation*}
\sphinxAtStartPar
The same derivation for \(\sigma_\downarrow\) yields the same result except for a sign change in the cross term:
\begin{equation*}
\begin{split}R_2^\text{Curie}(\sigma_\downarrow) = \frac{1}{45}B_0^2\gamma_H^2 \left[4\mathbf{J}(0) + 3\mathbf{J}(\omega)\right]
\left( 9\xi_\text{DD}^2r_\text{HN}^4 + 9\xi_\text{DSA}^2r^4 -
9\xi_\text{DD}r_\text{HN}^2(3\cos^2{\theta}-1)\xi_\text{DSA}r^2 \right)\end{split}
\end{equation*}
\sphinxAtStartPar
Taking the difference we obtain
\begin{equation*}
\begin{split}R_2^\text{Curie$\times$DD} &= R_2^\text{Curie}(\sigma_\uparrow) - R_2^\text{Curie}(\sigma_\downarrow)\\
&= \frac{1}{45}B_0^2\gamma_H^2 \left(18\xi_\text{DD}r_\text{HN}^2(3\cos^2{\theta}-1)\xi_\text{DSA}r^2 \right)\left[4\mathbf{J}(0) + 3\mathbf{J}(\omega)\right]\\
&=\frac{18}{45} \frac{\mu_0}{4\pi} \frac{B_0\gamma_H^2\gamma_N\hbar I}{r_\text{HN}^3}\frac{\chi_\text{iso}}{4\pi r^3}(3\cos^2{\theta}-1)\left[4\mathbf{J}(0) + 3\mathbf{J}(\omega)\right]\end{split}
\end{equation*}
\sphinxAtStartPar
Substituting \(\chi_\text{iso}\) and the spin of $^{\text{15}}$N as $^{\text{I=1/2}}$ yields
\begin{equation*}
\begin{split}R_2^\text{Curie$\times$DD}&=\frac{9}{45} \left(\frac{\mu_0}{4\pi}\right)^2 \frac{B_0\gamma_H^2\gamma_N\hbar}{r_\text{HN}^3} \frac{\mu_B^2g^2J(J+1)}{3 k T r^3}(3\cos^2{\theta}-1)\left[4\mathbf{J}(0) + 3\mathbf{J}(\omega)\right]\\
&=\frac{2}{15} \left(\frac{\mu_0}{4\pi}\right)^2 \frac{B_0\gamma_H^2\gamma_N\hbar}{r_\text{HN}^3} \frac{\mu_B^2g^2J(J+1)}{k T r^3}\frac{(3\cos^2{\theta}-1)}{2}\left[4\mathbf{J}(0) + 3\mathbf{J}(\omega)\right]\end{split}
\end{equation*}
\sphinxAtStartPar
The differential line width can be calculated from the relaxation rate as \(\Delta\nu = R_2^\text{Curie$\times$DD}/\pi\) and thus this equation matches equation 7 from \sphinxhref{https://doi.org/10.1006/jmre.2001.2378}{Bertini et al.}.


\section{Reference Guide}
\label{\detokenize{reference/index:reference-guide}}\label{\detokenize{reference/index:reference-index}}\label{\detokenize{reference/index::doc}}

\subsection{Paramagnetic module}
\label{\detokenize{reference/index:paramagnetic-module}}
\sphinxAtStartPar
This module handles the paramagnetic centre by defining the magnetic susceptibility
tensor and methods for PCS, RDC and PRE calculations.


\subsubsection{paramagpy.metal}
\label{\detokenize{reference/metal:module-paramagpy.metal}}\label{\detokenize{reference/metal:paramagpy-metal}}\label{\detokenize{reference/metal:metal}}\label{\detokenize{reference/metal::doc}}\index{module@\spxentry{module}!paramagpy.metal@\spxentry{paramagpy.metal}}\index{paramagpy.metal@\spxentry{paramagpy.metal}!module@\spxentry{module}}

\paragraph{Functions}
\label{\detokenize{reference/metal:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.euler_to_matrix:paramagpy.metal.euler_to_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{euler\_to\_matrix}}}}}(eulers)
&
\sphinxAtStartPar
Calculate a rotation matrix from euler angles using ZYZ convention
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.matrix_to_euler:paramagpy.metal.matrix_to_euler}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{matrix\_to\_euler}}}}}(M)
&
\sphinxAtStartPar
Calculate Euler angles from a rotation matrix using ZYZ convention
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.unique_eulers:paramagpy.metal.unique_eulers}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{unique\_eulers}}}}}(eulers)
&
\sphinxAtStartPar
Calculate Euler angles in unique tensor representation.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.make_tensor:paramagpy.metal.make_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_tensor}}}}}(x, y, z, axial, rhombic, alpha, …)
&
\sphinxAtStartPar
Make a ChiTensor isntance from given parameters.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.euler\_to\_matrix}
\label{\detokenize{reference/generated/paramagpy.metal.euler_to_matrix:paramagpy-metal-euler-to-matrix}}\label{\detokenize{reference/generated/paramagpy.metal.euler_to_matrix::doc}}\index{euler\_to\_matrix() (in module paramagpy.metal)@\spxentry{euler\_to\_matrix()}\spxextra{in module paramagpy.metal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.euler_to_matrix:paramagpy.metal.euler_to_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{euler\_to\_matrix}}}{\emph{\DUrole{n}{eulers}}}{}
\sphinxAtStartPar
Calculate a rotation matrix from euler angles using ZYZ convention
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eulers}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{matrix} \textendash{} the rotation matrix

\item[{Return type}] \leavevmode
\sphinxAtStartPar
3x3 numpy ndarray

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eulers} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mf}{1.2}\PYG{p}{,}\PYG{l+m+mf}{0.8}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{euler\PYGZus{}to\PYGZus{}matrix}\PYG{p}{(}\PYG{n}{eulers}\PYG{p}{)}
\PYG{g+go}{array([[\PYGZhy{}0.1223669 , \PYGZhy{}0.5621374 ,  0.81794125],}
\PYG{g+go}{       [ 0.75057357,  0.486796  ,  0.44684334],}
\PYG{g+go}{       [\PYGZhy{}0.64935788,  0.66860392,  0.36235775]])}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.matrix\_to\_euler}
\label{\detokenize{reference/generated/paramagpy.metal.matrix_to_euler:paramagpy-metal-matrix-to-euler}}\label{\detokenize{reference/generated/paramagpy.metal.matrix_to_euler::doc}}\index{matrix\_to\_euler() (in module paramagpy.metal)@\spxentry{matrix\_to\_euler()}\spxextra{in module paramagpy.metal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.matrix_to_euler:paramagpy.metal.matrix_to_euler}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{matrix\_to\_euler}}}{\emph{\DUrole{n}{M}}}{}
\sphinxAtStartPar
Calculate Euler angles from a rotation matrix using ZYZ convention
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{M}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 numpy ndarray}}) \textendash{} a rotation matrix

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{eulers} \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of floats

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{matrix} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.1223669} \PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{0.5621374} \PYG{p}{,}  \PYG{l+m+mf}{0.81794125}\PYG{p}{]}\PYG{p}{,}
\PYG{g+go}{                    [ 0.75057357,  0.486796  ,  0.44684334],}
\PYG{g+go}{                    [\PYGZhy{}0.64935788,  0.66860392,  0.36235775]])}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{matrix\PYGZus{}to\PYGZus{}euler}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}
\PYG{g+go}{np.array([0.5,1.2,0.8])}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.unique\_eulers}
\label{\detokenize{reference/generated/paramagpy.metal.unique_eulers:paramagpy-metal-unique-eulers}}\label{\detokenize{reference/generated/paramagpy.metal.unique_eulers::doc}}\index{unique\_eulers() (in module paramagpy.metal)@\spxentry{unique\_eulers()}\spxextra{in module paramagpy.metal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.unique_eulers:paramagpy.metal.unique_eulers}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{unique\_eulers}}}{\emph{\DUrole{n}{eulers}}}{}
\sphinxAtStartPar
Calculate Euler angles in unique tensor representation.

\sphinxAtStartPar
Given general Euler angles by ZYZ convention, this function accounts for
the symmetry of a second rank symmetric tensor to map all angles within
the range {[}0, pi{]}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eulers}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of float}}) \textendash{} the three Euler angles in radians

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{eulers\_utr} \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of floats

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{eulers} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.2}\PYG{p}{,}\PYG{l+m+mf}{10.3}\PYG{p}{,}\PYG{l+m+mf}{0.1}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{unique\PYGZus{}eulers}\PYG{p}{(}\PYG{n}{eulers}\PYG{p}{)}
\PYG{g+go}{np.array([1.08318531 0.87522204 3.04159265])}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.make\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.make_tensor:paramagpy-metal-make-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.make_tensor::doc}}\index{make\_tensor() (in module paramagpy.metal)@\spxentry{make\_tensor()}\spxextra{in module paramagpy.metal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.make_tensor:paramagpy.metal.make_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{make\_tensor}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{z}}, \emph{\DUrole{n}{axial}}, \emph{\DUrole{n}{rhombic}}, \emph{\DUrole{n}{alpha}}, \emph{\DUrole{n}{beta}}, \emph{\DUrole{n}{gamma}}, \emph{\DUrole{n}{lanthanide}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{temperature}\DUrole{o}{=}\DUrole{default_value}{298.15}}}{}
\sphinxAtStartPar
Make a ChiTensor isntance from given parameters.
This is designed to use pdb coordinates (x, y, z) and euler angles
from an output like Numbat.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{z}} (\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} tensor position in pdb coordiante in Angstroms

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rhombic}} (\sphinxstyleliteralemphasis{\sphinxupquote{axial}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} the tensor anisotropies in units 10\textasciicircum{}\sphinxhyphen{}32

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{alpha}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{beta}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}) \textendash{} the euler angles in degrees that maps the tensor
to the pdb (I think?)

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{ChiTensor} \textendash{} a tensor object for calulating paramagnetic effects on
nuclear spins in the pdb coordinate

\item[{Return type}] \leavevmode
\sphinxAtStartPar
object {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Classes}
\label{\detokenize{reference/metal:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Metal}}}}}({[}position, eulers, axrh, mueff, …{]})
&
\sphinxAtStartPar
An object for paramagnetic chi tensors and delta\sphinxhyphen{}chi tensors.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.Metal}
\label{\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy-metal-metal}}\label{\detokenize{reference/generated/paramagpy.metal.Metal::doc}}\index{Metal (class in paramagpy.metal)@\spxentry{Metal}\spxextra{class in paramagpy.metal}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.metal.}}\sphinxbfcode{\sphinxupquote{Metal}}}{\emph{\DUrole{n}{position}\DUrole{o}{=}\DUrole{default_value}{(0, 0, 0)}}, \emph{\DUrole{n}{eulers}\DUrole{o}{=}\DUrole{default_value}{(0, 0, 0)}}, \emph{\DUrole{n}{axrh}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{mueff}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{g\_axrh}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{t1e}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{temperature}\DUrole{o}{=}\DUrole{default_value}{298.15}}, \emph{\DUrole{n}{B0}\DUrole{o}{=}\DUrole{default_value}{18.79}}, \emph{\DUrole{n}{taur}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
An object for paramagnetic chi tensors and delta\sphinxhyphen{}chi tensors.
This class has basic attributes that specify position,
axiality/rhombicity, isotropy and euler angles.
It also has methods for calculating PCS, RDC, PRE and CCR values.
\index{\_\_init\_\_() (paramagpy.metal.Metal method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal:paramagpy.metal.Metal.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{position}\DUrole{o}{=}\DUrole{default_value}{(0, 0, 0)}}, \emph{\DUrole{n}{eulers}\DUrole{o}{=}\DUrole{default_value}{(0, 0, 0)}}, \emph{\DUrole{n}{axrh}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{mueff}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{g\_axrh}\DUrole{o}{=}\DUrole{default_value}{(0, 0)}}, \emph{\DUrole{n}{t1e}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{shift}\DUrole{o}{=}\DUrole{default_value}{0.0}}, \emph{\DUrole{n}{temperature}\DUrole{o}{=}\DUrole{default_value}{298.15}}, \emph{\DUrole{n}{B0}\DUrole{o}{=}\DUrole{default_value}{18.79}}, \emph{\DUrole{n}{taur}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Instantiate ChiTensor object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the (x,y,z) position in meters. Default is (0,0,0)
stored as a np.matrix object.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{eulers}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the euler angles {[}alpha,beta,gamma{]} in radians
by ZYZ convention. Defualt is (0,0,0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axrh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the axial and rhombic values defining the magnetic susceptibility
anisotropy

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{g\_axrh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the axial and rhombic values defining the power spectral density
tensor

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mueff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the effective magnetic moment in units of A.m\textasciicircum{}2

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shift}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} a bulk shift value applied to all PCS calculations.
This is a correction parameter that may arise due to an offset
between diamagnetic and paramagnetic PCS datasets.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{temperature}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the temperature in Kelvin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{t1e}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the longitudinal electronic relaxation time

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{B0}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the magnetic field in Telsa

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{taur}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the rotational correlation time in seconds

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy.metal.Metal.atom_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_ccr}}}}}(atom, atomPartner)
&
\sphinxAtStartPar
Calculate R2 cross\sphinxhyphen{}corelated relaxation due to DDxDSA
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs:paramagpy.metal.Metal.atom_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_pcs}}}}}(atom{[}, racs, rads{]})
&
\sphinxAtStartPar
Calculate the psuedo\sphinxhyphen{}contact shift at the given atom
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre:paramagpy.metal.Metal.atom_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_pre}}}}}(atom{[}, rtype, dsa, sbm, csa{]})
&
\sphinxAtStartPar
Calculate the PRE for an atom
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc:paramagpy.metal.Metal.atom_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_rdc}}}}}(atom1, atom2)
&
\sphinxAtStartPar
Calculate the residual dipolar coupling between two atoms
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position:paramagpy.metal.Metal.atom_set_position}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_set\_position}}}}}(atom)
&
\sphinxAtStartPar
Set the position of the Metal object to that of an atom
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.average:paramagpy.metal.Metal.average}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{average}}}}}(metals)
&
\sphinxAtStartPar
Set the attributes of the current instance to the average of a list of provided tensor objects
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ccr}}}}}(position, gamma, dipole\_shift\_tensor)
&
\sphinxAtStartPar
Calculate R2 cross\sphinxhyphen{}corelated relaxation due to DDxDSA
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.copy:paramagpy.metal.Metal.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
\sphinxAtStartPar
Copy the current Metal object to a new instance
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dipole\_shift\_tensor}}}}}(position)
&
\sphinxAtStartPar
Calculate the chemical shift tensor at the given postition
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dsa\_r1}}}}}(position, gamma{[}, csa{]})
&
\sphinxAtStartPar
Calculate R1 relaxation due to Curie Spin
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dsa\_r2}}}}}(position, gamma{[}, csa{]})
&
\sphinxAtStartPar
Calculate R2 relaxation due to Curie Spin
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr:paramagpy.metal.Metal.fast_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_ccr}}}}}(posarray, gammaarray, dstarray)
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.ccr()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor:paramagpy.metal.Metal.fast_dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_dipole\_shift\_tensor}}}}}(posarray)
&
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dipole\_shift\_tensor()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1:paramagpy.metal.Metal.fast_dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_dsa\_r1}}}}}(posarray, gammaarray{[}, csaarray{]})
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r1()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2:paramagpy.metal.Metal.fast_dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_dsa\_r2}}}}}(posarray, gammaarray{[}, csaarray{]})
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r2()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared:paramagpy.metal.Metal.fast_first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_first\_invariant\_squared}}}}}(t)
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.first\_invariant\_squared()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_g_sbm_r1:paramagpy.metal.Metal.fast_g_sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_g\_sbm\_r1}}}}}(posarray, gammaarray)
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g_sbm_r1:paramagpy.metal.Metal.g_sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.g\_sbm\_r1()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs:paramagpy.metal.Metal.fast_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_pcs}}}}}(posarray)
&
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.pcs()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre:paramagpy.metal.Metal.fast_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_pre}}}}}(posarray, gammaarray, rtype{[}, dsa, …{]})
&
\sphinxAtStartPar
Calculate the PRE for a set of spins using Curie and or SBM theory
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs:paramagpy.metal.Metal.fast_racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_racs}}}}}(csaarray)
&
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.racs()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads:paramagpy.metal.Metal.fast_rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_rads}}}}}(posarray)
&
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rads()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc:paramagpy.metal.Metal.fast_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_rdc}}}}}(vecarray, gammaProdArray)
&
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rdc()}}}}} method.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1:paramagpy.metal.Metal.fast_sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_sbm\_r1}}}}}(posarray, gammaarray)
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r1()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2:paramagpy.metal.Metal.fast_sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_sbm\_r2}}}}}(posarray, gammaarray)
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r2()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared:paramagpy.metal.Metal.fast_second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fast\_second\_invariant\_squared}}}}}(t)
&
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.second\_invariant\_squared()}}}}}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{first\_invariant\_squared}}}}}(t)
&
\sphinxAtStartPar
Calculate the antisymmetric contribution to relaxation via the first invariant of a tensor.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g_sbm_r1:paramagpy.metal.Metal.g_sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g\_sbm\_r1}}}}}(position, gamma)
&
\sphinxAtStartPar
Calculate R1 relaxation due to Solomon\sphinxhyphen{}Bloembergen\sphinxhyphen{}Morgan theory from anisotropic power spectral density tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.get_params:paramagpy.metal.Metal.get_params}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_params}}}}}(params)
&
\sphinxAtStartPar
Get tensor parameters that have been scaled appropriately
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.info:paramagpy.metal.Metal.info}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{info}}}}}({[}comment{]})
&
\sphinxAtStartPar
Get basic information about the Metal object
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy.metal.Metal.isomap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isomap}}}}}({[}protein, isoval{]})
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy.metal.Metal.make_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{make\_mesh}}}}}({[}density, size, origin{]})
&
\sphinxAtStartPar
Construct a 3D grid of points to map an isosurface
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs}}}}}(position)
&
\sphinxAtStartPar
Calculate the psuedo\sphinxhyphen{}contact shift at the given postition
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs_gradient:paramagpy.metal.Metal.pcs_gradient}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_gradient}}}}}(position)
&
\sphinxAtStartPar
Calculate the gradient of the psuedo\sphinxhyphen{}contact shift at the given postition.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh:paramagpy.metal.Metal.pcs_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_mesh}}}}}(mesh)
&
\sphinxAtStartPar
Calculate a PCS value at each location of cubic grid of points
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pre:paramagpy.metal.Metal.pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pre}}}}}(position, gamma, rtype{[}, dsa, sbm, …{]})
&
\sphinxAtStartPar
Calculate the PRE for a set of spins using Curie and or SBM theory
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh:paramagpy.metal.Metal.pre_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pre\_mesh}}}}}(mesh{[}, gamma, rtype, dsa, sbm{]})
&
\sphinxAtStartPar
Calculate a PRE value at each location of cubic grid of points
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{racs}}}}}(csa)
&
\sphinxAtStartPar
Calculate the residual anisotropic chemical shift at the given postition.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rads}}}}}(position)
&
\sphinxAtStartPar
Calculate the residual anisotropic dipolar shift at the given postition.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rdc}}}}}(vector, gammaProd)
&
\sphinxAtStartPar
Calculate Residual Dipolar Coupling (RDC)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy.metal.Metal.save}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{save}}}}}({[}fileName{]})
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sbm\_r1}}}}}(position, gamma)
&
\sphinxAtStartPar
Calculate R1 relaxation due to Solomon\sphinxhyphen{}Bloembergen\sphinxhyphen{}Morgan theory
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sbm\_r2}}}}}(position, gamma)
&
\sphinxAtStartPar
Calculate R2 relaxation due to Solomon\sphinxhyphen{}Bloembergen\sphinxhyphen{}Morgan theory
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{second\_invariant\_squared}}}}}(t)
&
\sphinxAtStartPar
Calculate the second invariant squared of a tensor.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg:paramagpy.metal.Metal.set_Jg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_Jg}}}}}(J, g)
&
\sphinxAtStartPar
Set the magnetic susceptibility absolute magnitude from J/g.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide:paramagpy.metal.Metal.set_lanthanide}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_lanthanide}}}}}(lanthanide{[}, set\_dchi{]})
&
\sphinxAtStartPar
Set the anisotropy, isotropy and T1e parameters from literature values
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_params:paramagpy.metal.Metal.set_params}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_params}}}}}(paramValues)
&
\sphinxAtStartPar
Set tensor parameters that have been scaled appropriately
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.set_utr:paramagpy.metal.Metal.set_utr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_utr}}}}}()
&
\sphinxAtStartPar
Modify current tensor parameters to unique tensor representation (UTR)
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens:paramagpy.metal.Metal.spec_dens}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{spec\_dens}}}}}(tau, omega)
&
\sphinxAtStartPar
A spectral density function with Lorentzian shape:
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap:paramagpy.metal.Metal.write_isomap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{write\_isomap}}}}}(mesh, bounds{[}, fileName{]})
&
\sphinxAtStartPar
Write a PyMol script to file which allows loading of the isosurface file
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script:paramagpy.metal.Metal.write_pymol_script}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{write\_pymol\_script}}}}}({[}isoval, surfaceName, …{]})
&
\sphinxAtStartPar
Write a PyMol script to file which allows loading of the isosurface file
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.Metal.atom\_ccr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy-metal-metal-atom-ccr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr::doc}}\index{atom\_ccr() (paramagpy.metal.Metal method)@\spxentry{atom\_ccr()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_ccr:paramagpy.metal.Metal.atom_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_ccr}}}{\emph{\DUrole{n}{atom}}, \emph{\DUrole{n}{atomPartner}}}{}
\sphinxAtStartPar
Calculate R2 cross\sphinxhyphen{}corelated relaxation due to DDxDSA
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atom}} ({\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{paramagpy.protein.CustomAtom}}}}}) \textendash{} the active nuclear spin for which relaxation will be calculated
must have attributes ‘position’ and ‘gamma’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atomPartner}} ({\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{paramagpy.protein.CustomAtom}}}}}) \textendash{} the coupling parnter nuclear spin
must have method ‘dipole\_shift\_tensor’

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} the CCR differential line broadening in Hz

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_pcs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs:paramagpy-metal-metal-atom-pcs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs::doc}}\index{atom\_pcs() (paramagpy.metal.Metal method)@\spxentry{atom\_pcs()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pcs:paramagpy.metal.Metal.atom_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_pcs}}}{\emph{\DUrole{n}{atom}}, \emph{\DUrole{n}{racs}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{rads}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Calculate the psuedo\sphinxhyphen{}contact shift at the given atom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atom}} (\sphinxstyleliteralemphasis{\sphinxupquote{biopython atom object}}) \textendash{} must have ‘position’ attribute

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{racs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True, RACS (residual anisotropic chemical shielding)
correction is included. Default is False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rads}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True, RADS (residual anisotropic dipolar shielding)
correction is included. Defualt is False

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{pcs} \textendash{} the pseudo\sphinxhyphen{}contact shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_pre}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre:paramagpy-metal-metal-atom-pre}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre::doc}}\index{atom\_pre() (paramagpy.metal.Metal method)@\spxentry{atom\_pre()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_pre:paramagpy.metal.Metal.atom_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_pre}}}{\emph{\DUrole{n}{atom}}, \emph{\DUrole{n}{rtype}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}r2\textquotesingle{}}}, \emph{\DUrole{n}{dsa}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{sbm}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{csa}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Calculate the PRE for an atom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atom}} ({\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{paramagpy.protein.CustomAtom}}}}}) \textendash{} the active nuclear spin for which relaxation will be calculated
must have attributes ‘position’ and ‘gamma’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} CSA tensor of the spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rate} \textendash{} The PRE rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_rdc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc:paramagpy-metal-metal-atom-rdc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc::doc}}\index{atom\_rdc() (paramagpy.metal.Metal method)@\spxentry{atom\_rdc()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_rdc:paramagpy.metal.Metal.atom_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_rdc}}}{\emph{\DUrole{n}{atom1}}, \emph{\DUrole{n}{atom2}}}{}
\sphinxAtStartPar
Calculate the residual dipolar coupling between two atoms
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atom1}} (\sphinxstyleliteralemphasis{\sphinxupquote{biopython atom object}}) \textendash{} must have ‘position’ and ‘gamma’ attribute

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atom1}} \textendash{} must have ‘position’ and ‘gamma’ attribute

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rdc} \textendash{} the RDC values in Hz

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.atom\_set\_position}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position:paramagpy-metal-metal-atom-set-position}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position::doc}}\index{atom\_set\_position() (paramagpy.metal.Metal method)@\spxentry{atom\_set\_position()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.atom_set_position:paramagpy.metal.Metal.atom_set_position}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{atom\_set\_position}}}{\emph{\DUrole{n}{atom}}}{}
\sphinxAtStartPar
Set the position of the Metal object to that of an atom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{atom}} (\sphinxstyleliteralemphasis{\sphinxupquote{biopython atom object}}) \textendash{} must have ‘position’ attribute

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.average}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.average:paramagpy-metal-metal-average}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.average::doc}}\index{average() (paramagpy.metal.Metal method)@\spxentry{average()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.average:paramagpy.metal.Metal.average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{average}}}{\emph{\DUrole{n}{metals}}}{}
\sphinxAtStartPar
Set the attributes of the current instance to the average
of a list of provided tensor objects

\sphinxAtStartPar
WARNING: averging is unstable for spectral power density \textless{}g\_tensor\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metals}} (\sphinxstyleliteralemphasis{\sphinxupquote{a list of Metal objects}}) \textendash{} the average of attributes of this list will be taken

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.ccr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy-metal-metal-ccr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.ccr::doc}}\index{ccr() (paramagpy.metal.Metal method)@\spxentry{ccr()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{ccr}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}, \emph{\DUrole{n}{dipole\_shift\_tensor}}}{}
\sphinxAtStartPar
Calculate R2 cross\sphinxhyphen{}corelated relaxation due to DDxDSA

\sphinxAtStartPar
If the metal has an anisotropic magnetic susceptibility, this is
taken into account.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)
this is the position of the nuclear spin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the relaxing spin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dipole\_shift\_tensor}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 array of floats}}) \textendash{} this is the dipole shift tensor arising from
the nuclear spin of the coupling partner

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} The R2 differential line broadening rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.copy}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.copy:paramagpy-metal-metal-copy}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.copy::doc}}\index{copy() (paramagpy.metal.Metal method)@\spxentry{copy()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.copy:paramagpy.metal.Metal.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{}
\sphinxAtStartPar
Copy the current Metal object to a new instance
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{new\_tensor} \textendash{} a new Metal instance with the same parameters

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Metal object

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.dipole\_shift\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy-metal-metal-dipole-shift-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor::doc}}\index{dipole\_shift\_tensor() (paramagpy.metal.Metal method)@\spxentry{dipole\_shift\_tensor()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{dipole\_shift\_tensor}}}{\emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
Calculate the chemical shift tensor at the given postition

\sphinxAtStartPar
This arises due to the paramagnetic dipole tensor field
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{dipole\_shift\_tensor} \textendash{} the tensor describing chemical shift at the nuclear position

\item[{Return type}] \leavevmode
\sphinxAtStartPar
3x3 array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.dsa\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy-metal-metal-dsa-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1::doc}}\index{dsa\_r1() (paramagpy.metal.Metal method)@\spxentry{dsa\_r1()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{dsa\_r1}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}, \emph{\DUrole{n}{csa}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Calculate R1 relaxation due to Curie Spin

\sphinxAtStartPar
If the metal has an anisotropic magnetic susceptibility, this is
taken into account, resulting in orientation dependent PRE as
predicted by Vega and Fiat. CSA cross\sphinxhyphen{}correlated relaxation may
be included by providing an appropriate CSA tensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z) in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the CSA tensor of the given spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} The R1 relaxation rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.dsa\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy-metal-metal-dsa-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2::doc}}\index{dsa\_r2() (paramagpy.metal.Metal method)@\spxentry{dsa\_r2()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{dsa\_r2}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}, \emph{\DUrole{n}{csa}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Calculate R2 relaxation due to Curie Spin

\sphinxAtStartPar
If the metal has an anisotropic magnetic susceptibility, this is
taken into account, resulting in orientation dependent PRE as
predicted by Vega and Fiat. CSA cross\sphinxhyphen{}correlated relaxation may
be included by providing an appropriate CSA tensor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the CSA tensor of the given spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} The R2 relaxation rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_ccr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr:paramagpy-metal-metal-fast-ccr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr::doc}}\index{fast\_ccr() (paramagpy.metal.Metal method)@\spxentry{fast\_ccr()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_ccr:paramagpy.metal.Metal.fast_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_ccr}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}, \emph{\DUrole{n}{dstarray}}}{}
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ccr:paramagpy.metal.Metal.ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.ccr()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting DDxDSA data

\sphinxAtStartPar
If the metal has an anisotropic magnetic susceptibility, this is
taken into account.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dstarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of nuclear dipole shift tensors arising from
the coupling partners

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The R2 differential line broadening rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_dipole\_shift\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor:paramagpy-metal-metal-fast-dipole-shift-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor::doc}}\index{fast\_dipole\_shift\_tensor() (paramagpy.metal.Metal method)@\spxentry{fast\_dipole\_shift\_tensor()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dipole_shift_tensor:paramagpy.metal.Metal.fast_dipole_shift_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_dipole\_shift\_tensor}}}{\emph{\DUrole{n}{posarray}}}{}
\sphinxAtStartPar
A vectorised version of
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dipole_shift_tensor:paramagpy.metal.Metal.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dipole\_shift\_tensor()}}}}}

\sphinxAtStartPar
This is generally used for fast calculations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array}}) \textendash{} an array of positions with shape (n,3)

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{dipole\_shift\_tensor\_array} \textendash{} and array of dipole shift tensors at corresponding positions.
This has shape (n,3,3)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_dsa\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1:paramagpy-metal-metal-fast-dsa-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1::doc}}\index{fast\_dsa\_r1() (paramagpy.metal.Metal method)@\spxentry{fast\_dsa\_r1()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r1:paramagpy.metal.Metal.fast_dsa_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_dsa\_r1}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}, \emph{\DUrole{n}{csaarray}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r1:paramagpy.metal.Metal.dsa_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r1()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{m}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of CSA tensors of the spins.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The R1 relaxation rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_dsa\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2:paramagpy-metal-metal-fast-dsa-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2::doc}}\index{fast\_dsa\_r2() (paramagpy.metal.Metal method)@\spxentry{fast\_dsa\_r2()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_dsa_r2:paramagpy.metal.Metal.fast_dsa_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_dsa\_r2}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}, \emph{\DUrole{n}{csaarray}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.dsa_r2:paramagpy.metal.Metal.dsa_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.dsa\_r2()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{m}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of CSA tensors of the spins.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The R2 relaxation rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_first\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared:paramagpy-metal-metal-fast-first-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared::doc}}\index{fast\_first\_invariant\_squared() (paramagpy.metal.Metal static method)@\spxentry{fast\_first\_invariant\_squared()}\spxextra{paramagpy.metal.Metal static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_first_invariant_squared:paramagpy.metal.Metal.fast_first_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_first\_invariant\_squared}}}{\emph{\DUrole{n}{t}}}{}
\sphinxAtStartPar
Vectorised version of
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.first\_invariant\_squared()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tensorarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of shielding tensors

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{firstInvariantSquared} \textendash{} the first invariants squared of the tensors

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_g\_sbm\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_g_sbm_r1:paramagpy-metal-metal-fast-g-sbm-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_g_sbm_r1::doc}}\index{fast\_g\_sbm\_r1() (paramagpy.metal.Metal method)@\spxentry{fast\_g\_sbm\_r1()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_g_sbm_r1:paramagpy.metal.Metal.fast_g_sbm_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_g\_sbm\_r1}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}}{}
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g_sbm_r1:paramagpy.metal.Metal.g_sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.g\_sbm\_r1()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The R1 relaxation rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_pcs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs:paramagpy-metal-metal-fast-pcs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs::doc}}\index{fast\_pcs() (paramagpy.metal.Metal method)@\spxentry{fast\_pcs()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pcs:paramagpy.metal.Metal.fast_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_pcs}}}{\emph{\DUrole{n}{posarray}}}{}
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.pcs()}}}}}

\sphinxAtStartPar
This efficient algorithm calculates the PCSs for an array of
positions and is best used where speed is required for fitting.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of ‘n’ positions (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{pcs} \textendash{} the peudo\sphinxhyphen{}contact shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of floats with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_pre}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre:paramagpy-metal-metal-fast-pre}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre::doc}}\index{fast\_pre() (paramagpy.metal.Metal method)@\spxentry{fast\_pre()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_pre:paramagpy.metal.Metal.fast_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_pre}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}, \emph{\DUrole{n}{rtype}}, \emph{\DUrole{n}{dsa}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{sbm}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{gsbm}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{csaarray}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Calculate the PRE for a set of spins using Curie and or SBM theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gsbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (default=False), anisotropic dipolar relaxation is
included using the spectral power density gensor \textless{}g\_tensor\textgreater{}
NOTE: when true, ignores relaxation of type SBM
NOTE: only implemented for R1 relaxation calculations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{m}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of CSA tensors of the spins.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The PRE rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_racs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs:paramagpy-metal-metal-fast-racs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs::doc}}\index{fast\_racs() (paramagpy.metal.Metal method)@\spxentry{fast\_racs()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_racs:paramagpy.metal.Metal.fast_racs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_racs}}}{\emph{\DUrole{n}{csaarray}}}{}
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.racs()}}}}}

\sphinxAtStartPar
This is generally used when speed is required for fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of chemical shift anisotropy tensors

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{racs\_array} \textendash{} the residual anisotropic chemical shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of floats with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_rads}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads:paramagpy-metal-metal-fast-rads}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads::doc}}\index{fast\_rads() (paramagpy.metal.Metal method)@\spxentry{fast\_rads()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rads:paramagpy.metal.Metal.fast_rads}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_rads}}}{\emph{\DUrole{n}{posarray}}}{}
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rads()}}}}}

\sphinxAtStartPar
This is generally used when speed is required for fitting
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} an array of ‘n’ positions (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rads\_array} \textendash{} the residual anisotropic dipole shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of floats with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_rdc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc:paramagpy-metal-metal-fast-rdc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc::doc}}\index{fast\_rdc() (paramagpy.metal.Metal method)@\spxentry{fast\_rdc()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_rdc:paramagpy.metal.Metal.fast_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_rdc}}}{\emph{\DUrole{n}{vecarray}}, \emph{\DUrole{n}{gammaProdArray}}}{}
\sphinxAtStartPar
A vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.rdc()}}}}} method.

\sphinxAtStartPar
This is generally used for speed in fitting RDC data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vecarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of internuclear vectors in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaProdArray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{1}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the products of gyromagnetic ratios of spins A and B
where each has units of rad/s/T

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rdc\_array} \textendash{} the RDC values in Hz

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_sbm\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1:paramagpy-metal-metal-fast-sbm-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1::doc}}\index{fast\_sbm\_r1() (paramagpy.metal.Metal method)@\spxentry{fast\_sbm\_r1()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r1:paramagpy.metal.Metal.fast_sbm_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_sbm\_r1}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}}{}
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r1()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The R1 relaxation rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_sbm\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2:paramagpy-metal-metal-fast-sbm-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2::doc}}\index{fast\_sbm\_r2() (paramagpy.metal.Metal method)@\spxentry{fast\_sbm\_r2()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_sbm_r2:paramagpy.metal.Metal.fast_sbm_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_sbm\_r2}}}{\emph{\DUrole{n}{posarray}}, \emph{\DUrole{n}{gammaarray}}}{}
\sphinxAtStartPar
Vectorised version of {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.sbm\_r2()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{posarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of gyromagnetic ratios of the spins

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rates} \textendash{} The R2 relaxation rates in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fast\_second\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared:paramagpy-metal-metal-fast-second-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared::doc}}\index{fast\_second\_invariant\_squared() (paramagpy.metal.Metal static method)@\spxentry{fast\_second\_invariant\_squared()}\spxextra{paramagpy.metal.Metal static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fast_second_invariant_squared:paramagpy.metal.Metal.fast_second_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fast\_second\_invariant\_squared}}}{\emph{\DUrole{n}{t}}}{}
\sphinxAtStartPar
Vectorised version of
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.second\_invariant\_squared()}}}}}

\sphinxAtStartPar
This is generally used for speed in fitting PRE data
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tensorarray}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} array of shielding tensors

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{secondInvariantSquared} \textendash{} the second invariants squared of the tensors

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.first\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy-metal-metal-first-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared::doc}}\index{first\_invariant\_squared() (paramagpy.metal.Metal static method)@\spxentry{first\_invariant\_squared()}\spxextra{paramagpy.metal.Metal static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.first_invariant_squared:paramagpy.metal.Metal.first_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{first\_invariant\_squared}}}{\emph{\DUrole{n}{t}}}{}
\sphinxAtStartPar
Calculate the antisymmetric contribution to relaxation via the
first invariant of a tensor.

\sphinxAtStartPar
This is required for PRE calculations using the shilding tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}) \textendash{} a second rank tensor

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{firstInvariantSquared} \textendash{} the first invariant squared of the shift tensor

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.g\_sbm\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_sbm_r1:paramagpy-metal-metal-g-sbm-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_sbm_r1::doc}}\index{g\_sbm\_r1() (paramagpy.metal.Metal method)@\spxentry{g\_sbm\_r1()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_sbm_r1:paramagpy.metal.Metal.g_sbm_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{g\_sbm\_r1}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}}{}
\sphinxAtStartPar
Calculate R1 relaxation due to Solomon\sphinxhyphen{}Bloembergen\sphinxhyphen{}Morgan theory
from anisotropic power spectral density tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} The R1 relaxation rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.get\_params}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.get_params:paramagpy-metal-metal-get-params}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.get_params::doc}}\index{get\_params() (paramagpy.metal.Metal method)@\spxentry{get\_params()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.get_params:paramagpy.metal.Metal.get_params}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{get\_params}}}{\emph{\DUrole{n}{params}}}{}
\sphinxAtStartPar
Get tensor parameters that have been scaled appropriately

\sphinxAtStartPar
This is often used to get parameter values during fitting where
floating point errors would otherwise occur on the small values
encountered.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} each element of the list is a string that corresponds to
an attribute of the Metal to be retrieved.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{scaled\_params} \textendash{} a list with respective scaled parameter values from the input.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
list

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{n}{axrh}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{20E\PYGZhy{}32}\PYG{p}{,} \PYG{l+m+mf}{3E\PYGZhy{}32}\PYG{p}{]}\PYG{p}{,}\PYG{n}{position}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mf}{10E\PYGZhy{}10}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5E\PYGZhy{}10}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{get\PYGZus{}params}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{[20.0, 3.0, 0.0, 10.0, \PYGZhy{}5.0]}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.info}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.info:paramagpy-metal-metal-info}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.info::doc}}\index{info() (paramagpy.metal.Metal method)@\spxentry{info()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.info:paramagpy.metal.Metal.info}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{info}}}{\emph{\DUrole{n}{comment}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Get basic information about the Metal object

\sphinxAtStartPar
This is returned as a string in human readable units
This is also the file format for saving the tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{comment}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if True, each line has a ‘\#’ placed at the front

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{information} \textendash{} a string containing basic information about the Metal

\item[{Return type}] \leavevmode
\sphinxAtStartPar
str

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{set\PYGZus{}lanthanide}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{info}\PYG{p}{(}\PYG{p}{)}
\PYG{g+go}{\PYGZsh{} ax    | 1E\PYGZhy{}32 m\PYGZca{}3 :   \PYGZhy{}11.600}
\PYG{g+go}{\PYGZsh{} rh    | 1E\PYGZhy{}32 m\PYGZca{}3 :    \PYGZhy{}8.600}
\PYG{g+go}{\PYGZsh{} x     |   1E\PYGZhy{}10 m :     0.000}
\PYG{g+go}{\PYGZsh{} y     |   1E\PYGZhy{}10 m :     0.000}
\PYG{g+go}{\PYGZsh{} z     |   1E\PYGZhy{}10 m :     0.000}
\PYG{g+go}{\PYGZsh{} a     |       deg :     0.000}
\PYG{g+go}{\PYGZsh{} b     |       deg :     0.000}
\PYG{g+go}{\PYGZsh{} g     |       deg :     0.000}
\PYG{g+go}{\PYGZsh{} mueff |        Bm :     9.581}
\PYG{g+go}{\PYGZsh{} shift |       ppm :     0.000}
\PYG{g+go}{\PYGZsh{} B0    |         T :    18.790}
\PYG{g+go}{\PYGZsh{} temp  |         K :   298.150}
\PYG{g+go}{\PYGZsh{} t1e   |        ps :     0.189}
\PYG{g+go}{\PYGZsh{} taur  |        ns :     0.000}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.isomap}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy-metal-metal-isomap}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.isomap::doc}}\index{isomap() (paramagpy.metal.Metal method)@\spxentry{isomap()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.isomap:paramagpy.metal.Metal.isomap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{isomap}}}{\emph{\DUrole{n}{protein}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{isoval}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.make\_mesh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy-metal-metal-make-mesh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh::doc}}\index{make\_mesh() (paramagpy.metal.Metal method)@\spxentry{make\_mesh()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy.metal.Metal.make_mesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{make\_mesh}}}{\emph{\DUrole{n}{density}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{40.0}}, \emph{\DUrole{n}{origin}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Construct a 3D grid of points to map an isosurface

\sphinxAtStartPar
This is contained in a cube
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{density}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the points per Angstrom in the grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{size}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the length of one edge of the cube

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{mesh} (\sphinxstyleemphasis{cubic grid array}) \textendash{} This has shape (n,n,n,3) where n is the number of points
along one edge of the grid. Units are meters

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{origin} (\sphinxstyleemphasis{array of floats,}) \textendash{} the (x,y,z) location of mesh vertex

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{low} (\sphinxstyleemphasis{array of ints, the integer location of the first}) \textendash{} point in each dimension

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{high} (\sphinxstyleemphasis{array of ints, the integer location of the last}) \textendash{} point in each dimension

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{points} (\sphinxstyleemphasis{array of ints,}) \textendash{} the number of points along each dimension

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pcs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy-metal-metal-pcs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs::doc}}\index{pcs() (paramagpy.metal.Metal method)@\spxentry{pcs()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs:paramagpy.metal.Metal.pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pcs}}}{\emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
Calculate the psuedo\sphinxhyphen{}contact shift at the given postition
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{pcs} \textendash{} the pseudo\sphinxhyphen{}contact shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{set\PYGZus{}lanthanide}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Er}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{pcs}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{0.}\PYG{p}{,}\PYG{l+m+mf}{10E\PYGZhy{}10}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{\PYGZhy{}6.153991132886608}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pcs\_gradient}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_gradient:paramagpy-metal-metal-pcs-gradient}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_gradient::doc}}\index{pcs\_gradient() (paramagpy.metal.Metal method)@\spxentry{pcs\_gradient()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_gradient:paramagpy.metal.Metal.pcs_gradient}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pcs\_gradient}}}{\emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
Calculate the gradient of the psuedo\sphinxhyphen{}contact shift
at the given postition.
This equation uses analytic partial derivatives calculated in
Mathematica.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in metres

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{gradient} \textendash{} the {[}x,y,z{]} gradient vector for the pseudo\sphinxhyphen{}contact shift
in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm) per metre

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of floats

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pcs\_mesh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh:paramagpy-metal-metal-pcs-mesh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh::doc}}\index{pcs\_mesh() (paramagpy.metal.Metal method)@\spxentry{pcs\_mesh()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pcs_mesh:paramagpy.metal.Metal.pcs_mesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pcs\_mesh}}}{\emph{\DUrole{n}{mesh}}}{}
\sphinxAtStartPar
Calculate a PCS value at each location of cubic grid of points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} a cubic grid as generated by the method \textless{}make\_mesh\textgreater{}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{pcs\_mesh} \textendash{} The same grid shape, with PCS values at the respective locations

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,n,n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pre}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre:paramagpy-metal-metal-pre}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre::doc}}\index{pre() (paramagpy.metal.Metal method)@\spxentry{pre()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre:paramagpy.metal.Metal.pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pre}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}, \emph{\DUrole{n}{rtype}}, \emph{\DUrole{n}{dsa}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{sbm}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{gsbm}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{csa}\DUrole{o}{=}\DUrole{default_value}{0.0}}}{}
\sphinxAtStartPar
Calculate the PRE for a set of spins using Curie and or SBM theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} position in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} gyromagnetic ratio of the spin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gsbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (default=False), anisotropic dipolar relaxation is
included using the spectral power density gensor \textless{}g\_tensor\textgreater{}
NOTE: when true, ignores relaxation of type SBM
NOTE: only implemented for R1 relaxation calculations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{) }}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} CSA tensor of the spin.
This defualts to 0.0, meaning CSAxDSA crosscorrelation is
not accounted for.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rate} \textendash{} The PRE rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.pre\_mesh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh:paramagpy-metal-metal-pre-mesh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh::doc}}\index{pre\_mesh() (paramagpy.metal.Metal method)@\spxentry{pre\_mesh()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.pre_mesh:paramagpy.metal.Metal.pre_mesh}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{pre\_mesh}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{gamma}\DUrole{o}{=}\DUrole{default_value}{267512897.63847807}}, \emph{\DUrole{n}{rtype}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}r2\textquotesingle{}}}, \emph{\DUrole{n}{dsa}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{sbm}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Calculate a PRE value at each location of cubic grid of points
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{array with shape}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{n}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} a cubic grid as generated by the method \textless{}make\_mesh\textgreater{}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rtype}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} either ‘r1’ or ‘r2’, the relaxation type

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), DSA or Curie spin relaxation is included

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} when True (defualt), SBM spin relaxation is included

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{pre\_mesh} \textendash{} The same grid shape, with PRE values at the respective locations

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array with shape (n,n,n,1)

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.racs}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy-metal-metal-racs}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.racs::doc}}\index{racs() (paramagpy.metal.Metal method)@\spxentry{racs()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.racs:paramagpy.metal.Metal.racs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{racs}}}{\emph{\DUrole{n}{csa}}}{}
\sphinxAtStartPar
Calculate the residual anisotropic chemical shift at the
given postition.

\sphinxAtStartPar
The partial alignment induced by an anisotropic
magnetic susecptiblity causes the chemical shift tensor at a nuclear
position to average to a value different to the isotropic value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{3 x 3 array}}) \textendash{} the chemical shift anisotropy tensor

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{racs} \textendash{} the residual anisotropic chemical shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rads}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy-metal-metal-rads}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rads::doc}}\index{rads() (paramagpy.metal.Metal method)@\spxentry{rads()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rads:paramagpy.metal.Metal.rads}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rads}}}{\emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
Calculate the residual anisotropic dipolar shift at the
given postition.

\sphinxAtStartPar
The partial alignment induced by an anisotropic
magnetic susecptiblity causes the dipole shift tensor at a nuclear
position to average to a value different to the PCS.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rads} \textendash{} the residual anisotropic dipole shift in parts\sphinxhyphen{}per\sphinxhyphen{}million (ppm)

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rdc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy-metal-metal-rdc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rdc::doc}}\index{rdc() (paramagpy.metal.Metal method)@\spxentry{rdc()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rdc:paramagpy.metal.Metal.rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rdc}}}{\emph{\DUrole{n}{vector}}, \emph{\DUrole{n}{gammaProd}}}{}
\sphinxAtStartPar
Calculate Residual Dipolar Coupling (RDC)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vector}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} internuclear vector (x,y,z) in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gammaProd}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the product of gyromagnetic ratios of spin A and B
where each has units of rad/s/T

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{rdc} \textendash{} the RDC in Hz

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.save}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy-metal-metal-save}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.save::doc}}\index{save() (paramagpy.metal.Metal method)@\spxentry{save()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.save:paramagpy.metal.Metal.save}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{save}}}{\emph{\DUrole{n}{fileName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}tensor.txt\textquotesingle{}}}}{}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.sbm\_r1}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy-metal-metal-sbm-r1}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1::doc}}\index{sbm\_r1() (paramagpy.metal.Metal method)@\spxentry{sbm\_r1()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r1:paramagpy.metal.Metal.sbm_r1}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{sbm\_r1}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}}{}
\sphinxAtStartPar
Calculate R1 relaxation due to Solomon\sphinxhyphen{}Bloembergen\sphinxhyphen{}Morgan theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} The R1 relaxation rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.sbm\_r2}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy-metal-metal-sbm-r2}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2::doc}}\index{sbm\_r2() (paramagpy.metal.Metal method)@\spxentry{sbm\_r2()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.sbm_r2:paramagpy.metal.Metal.sbm_r2}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{sbm\_r2}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{gamma}}}{}
\sphinxAtStartPar
Calculate R2 relaxation due to Solomon\sphinxhyphen{}Bloembergen\sphinxhyphen{}Morgan theory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} three coordinates (x,y,z)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{gamma}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the gyromagnetic ratio of the spin

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} The R2 relaxation rate in /s

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.second\_invariant\_squared}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy-metal-metal-second-invariant-squared}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared::doc}}\index{second\_invariant\_squared() (paramagpy.metal.Metal static method)@\spxentry{second\_invariant\_squared()}\spxextra{paramagpy.metal.Metal static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.second_invariant_squared:paramagpy.metal.Metal.second_invariant_squared}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{second\_invariant\_squared}}}{\emph{\DUrole{n}{t}}}{}
\sphinxAtStartPar
Calculate the second invariant squared of a tensor.

\sphinxAtStartPar
This is required for PRE calculations using the shilding tensor
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tensor}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 matrix}}) \textendash{} a second rank tensor

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{secondInvariantSquared} \textendash{} the second invariant squared of the shift tensor

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_Jg}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg:paramagpy-metal-metal-set-jg}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg::doc}}\index{set\_Jg() (paramagpy.metal.Metal method)@\spxentry{set\_Jg()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_Jg:paramagpy.metal.Metal.set_Jg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_Jg}}}{\emph{\DUrole{n}{J}}, \emph{\DUrole{n}{g}}}{}
\sphinxAtStartPar
Set the magnetic susceptibility absolute magnitude from J/g.

\sphinxAtStartPar
This is achieved using the following formula:
\begin{equation*}
\begin{split}\mu_{eff}=g\mu_B\sqrt{J(J+1)}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{J}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the total spin angular momentum quantum number

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{g}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the Lande g\sphinxhyphen{}factor

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_lanthanide}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide:paramagpy-metal-metal-set-lanthanide}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide::doc}}\index{set\_lanthanide() (paramagpy.metal.Metal method)@\spxentry{set\_lanthanide()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_lanthanide:paramagpy.metal.Metal.set_lanthanide}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_lanthanide}}}{\emph{\DUrole{n}{lanthanide}}, \emph{\DUrole{n}{set\_dchi}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Set the anisotropy, isotropy and T1e parameters from
literature values
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{lanthanide}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} one of ‘Ce’,’Pr’,’Nd’,’Pm’,’Sm’,’Eu’,’Gd’,’Tb’,
‘Dy’,’Ho’,’Er’,’Tm’,’Yb’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{set\_dichi}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if True (default), the tensor anisotropy is set.
Otherwise only the isotropy and T1e values are set

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_params}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_params:paramagpy-metal-metal-set-params}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_params::doc}}\index{set\_params() (paramagpy.metal.Metal method)@\spxentry{set\_params()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_params:paramagpy.metal.Metal.set_params}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_params}}}{\emph{\DUrole{n}{paramValues}}}{}
\sphinxAtStartPar
Set tensor parameters that have been scaled appropriately

\sphinxAtStartPar
This is the inverse of the method \textless{}get\_params\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{paramValues}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of tuple}}) \textendash{} each element is a tuple (variable, value) where ‘variable’
is the string indentifying the attribute to be set, and ‘value’
is the corresponding value

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal} \PYG{o}{=} \PYG{n}{Metal}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{set\PYGZus{}params}\PYG{p}{(}\PYG{p}{[}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ax}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{20.0}\PYG{p}{)}\PYG{p}{,}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rh}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mf}{3.0}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{metal}\PYG{o}{.}\PYG{n}{axrh}
\PYG{g+go}{[2.e\PYGZhy{}31 3.e\PYGZhy{}32]}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.set\_utr}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_utr:paramagpy-metal-metal-set-utr}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_utr::doc}}\index{set\_utr() (paramagpy.metal.Metal method)@\spxentry{set\_utr()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.set_utr:paramagpy.metal.Metal.set_utr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{set\_utr}}}{}{}
\sphinxAtStartPar
Modify current tensor parameters to unique tensor representation (UTR)

\sphinxAtStartPar
Note that multiple axial/rhombic and euler angles can give congruent
tensors.
This method ensures that identical tensors may always be compared
by using Numbat style representation.

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.spec\_dens}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens:paramagpy-metal-metal-spec-dens}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens::doc}}\index{spec\_dens() (paramagpy.metal.Metal static method)@\spxentry{spec\_dens()}\spxextra{paramagpy.metal.Metal static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.spec_dens:paramagpy.metal.Metal.spec_dens}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{spec\_dens}}}{\emph{\DUrole{n}{tau}}, \emph{\DUrole{n}{omega}}}{}
\sphinxAtStartPar
A spectral density function with Lorentzian shape:
\begin{equation*}
\begin{split}\mathbb{J}(\tau,\omega)=\frac{\tau}{1+(\omega\tau)^2}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tau}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} correaltion time

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{omega}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} frequency

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{value} \textendash{} the value of the spectral denstiy

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.write\_isomap}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap:paramagpy-metal-metal-write-isomap}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap::doc}}\index{write\_isomap() (paramagpy.metal.Metal method)@\spxentry{write\_isomap()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_isomap:paramagpy.metal.Metal.write_isomap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{write\_isomap}}}{\emph{\DUrole{n}{mesh}}, \emph{\DUrole{n}{bounds}}, \emph{\DUrole{n}{fileName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}isomap.pml.ccp4\textquotesingle{}}}}{}
\sphinxAtStartPar
Write a PyMol script to file which allows loading of the
isosurface file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mesh}} (\sphinxstyleliteralemphasis{\sphinxupquote{3D scalar np.ndarray of floats}}) \textendash{} the scalar field of PCS or PRE values in a cubic grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bounds}} (\sphinxstyleliteralemphasis{\sphinxupquote{tuple}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{origin}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{low}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{high}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{points}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} as generated by {\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.make_mesh:paramagpy.metal.Metal.make_mesh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.metal.Metal.make\_mesh()}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the filename of the isosurface file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.write\_pymol\_script}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script:paramagpy-metal-metal-write-pymol-script}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script::doc}}\index{write\_pymol\_script() (paramagpy.metal.Metal method)@\spxentry{write\_pymol\_script()}\spxextra{paramagpy.metal.Metal method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.write_pymol_script:paramagpy.metal.Metal.write_pymol_script}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{write\_pymol\_script}}}{\emph{\DUrole{n}{isoval}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{surfaceName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}isomap\textquotesingle{}}}, \emph{\DUrole{n}{scriptName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}isomap.pml\textquotesingle{}}}, \emph{\DUrole{n}{meshName}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}./isomap.pml.ccp4\textquotesingle{}}}, \emph{\DUrole{n}{pdbFile}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Write a PyMol script to file which allows loading of the
isosurface file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{isoval}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the contour level of the isosurface

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{surfaceName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the name of the isosurface file within PyMol

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{scriptName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the name of the PyMol script to load the tensor isosurface

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{meshName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the name of the binary isosurface file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pdbFile}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} if not \textless{}None\textgreater{}, the file name of the PDB file to be loaded with
the isosurface.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz:paramagpy.metal.Metal.B0_MHz}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{B0\_MHz}}}}}
&
\sphinxAtStartPar
1H NMR frequency for the given field in MHz
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA:paramagpy.metal.Metal.GAMMA}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{GAMMA}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.HBAR:paramagpy.metal.Metal.HBAR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HBAR}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.K:paramagpy.metal.Metal.K}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{K}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.MU0:paramagpy.metal.Metal.MU0}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MU0}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.MUB:paramagpy.metal.Metal.MUB}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MUB}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.a:paramagpy.metal.Metal.a}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{a}}}}}
&
\sphinxAtStartPar
alpha euler anglue
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor:paramagpy.metal.Metal.alignment_factor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{alignment\_factor}}}}}
&
\sphinxAtStartPar
Factor for conversion between magnetic susceptibility and alignment tensors
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.ax:paramagpy.metal.Metal.ax}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ax}}}}}
&
\sphinxAtStartPar
axiality
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.b:paramagpy.metal.Metal.b}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{b}}}}}
&
\sphinxAtStartPar
beta euler anglue
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues:paramagpy.metal.Metal.eigenvalues}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{eigenvalues}}}}}
&
\sphinxAtStartPar
The eigenvalues defining the magnitude of the principle axes
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling:paramagpy.metal.Metal.fit_scaling}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fit\_scaling}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.fundamental_attributes:paramagpy.metal.Metal.fundamental_attributes}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fundamental\_attributes}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g:paramagpy.metal.Metal.g}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g}}}}}
&
\sphinxAtStartPar
gamma euler anglue
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g_eigenvalues:paramagpy.metal.Metal.g_eigenvalues}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g\_eigenvalues}}}}}
&
\sphinxAtStartPar
The eigenvalues defining the magnitude of the principle axes
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g_isotropy:paramagpy.metal.Metal.g_isotropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g\_isotropy}}}}}
&
\sphinxAtStartPar
Estimate of the spectral power density tensor isotropy
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.g_tensor:paramagpy.metal.Metal.g_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{g\_tensor}}}}}
&
\sphinxAtStartPar
The magnetic susceptibility tensor matrix representation
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.gax:paramagpy.metal.Metal.gax}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gax}}}}}
&
\sphinxAtStartPar
axial componenet of spectral power density tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.grh:paramagpy.metal.Metal.grh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{grh}}}}}
&
\sphinxAtStartPar
axial componenet of spectral power density tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.iso:paramagpy.metal.Metal.iso}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{iso}}}}}
&
\sphinxAtStartPar
isotropy
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.isotropy:paramagpy.metal.Metal.isotropy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{isotropy}}}}}
&
\sphinxAtStartPar
The magnidue of the isotropic component of the tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh:paramagpy.metal.Metal.lanth_axrh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lanth\_axrh}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib:paramagpy.metal.Metal.lanth_lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lanth\_lib}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords:paramagpy.metal.Metal.lower_coords}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{lower\_coords}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rh:paramagpy.metal.Metal.rh}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rh}}}}}
&
\sphinxAtStartPar
rhombicity
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix:paramagpy.metal.Metal.rotationMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rotationMatrix}}}}}
&
\sphinxAtStartPar
The rotation matrix as defined by the euler angles
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor:paramagpy.metal.Metal.saupe_factor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{saupe\_factor}}}}}
&
\sphinxAtStartPar
Factor for conversion between magnetic susceptibility and saupe tensors
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tauc:paramagpy.metal.Metal.tauc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tauc}}}}}
&
\sphinxAtStartPar
The effective rotational correlation time.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor:paramagpy.metal.Metal.tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor}}}}}
&
\sphinxAtStartPar
The magnetic susceptibility tensor matrix representation
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment:paramagpy.metal.Metal.tensor_alignment}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor\_alignment}}}}}
&
\sphinxAtStartPar
The alignment tensor matrix representation
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe:paramagpy.metal.Metal.tensor_saupe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor\_saupe}}}}}
&
\sphinxAtStartPar
The saupe tensor matrix representation
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless:paramagpy.metal.Metal.tensor_traceless}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{tensor\_traceless}}}}}
&
\sphinxAtStartPar
The traceless magnetic susceptibility tensor matrix representation
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords:paramagpy.metal.Metal.upper_coords}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_coords}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang:paramagpy.metal.Metal.upper_triang}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_triang}}}}}
&
\sphinxAtStartPar
Fetch 5 unique matrix element defining the magnetic susceptibility tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment:paramagpy.metal.Metal.upper_triang_alignment}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_triang\_alignment}}}}}
&
\sphinxAtStartPar
Fetch 5 unique matrix element defining the alignment tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe:paramagpy.metal.Metal.upper_triang_saupe}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{upper\_triang\_saupe}}}}}
&
\sphinxAtStartPar
Fetch 5 unique matrix element defining the magnetic susceptibility tensor
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.x:paramagpy.metal.Metal.x}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{x}}}}}
&
\sphinxAtStartPar
x coordinate
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.y:paramagpy.metal.Metal.y}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{y}}}}}
&
\sphinxAtStartPar
y coordinate
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.metal.Metal.z:paramagpy.metal.Metal.z}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{z}}}}}
&
\sphinxAtStartPar
z coordinate
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.metal.Metal.B0\_MHz}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz:paramagpy-metal-metal-b0-mhz}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz::doc}}\index{B0\_MHz (paramagpy.metal.Metal property)@\spxentry{B0\_MHz}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.B0_MHz:paramagpy.metal.Metal.B0_MHz}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{B0\_MHz}}}
\sphinxAtStartPar
1H NMR frequency for the given field in MHz

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.GAMMA}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA:paramagpy-metal-metal-gamma}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA::doc}}\index{GAMMA (paramagpy.metal.Metal attribute)@\spxentry{GAMMA}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.GAMMA:paramagpy.metal.Metal.GAMMA}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{GAMMA}}\sphinxbfcode{\sphinxupquote{ = 176085964400.0}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.HBAR}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.HBAR:paramagpy-metal-metal-hbar}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.HBAR::doc}}\index{HBAR (paramagpy.metal.Metal attribute)@\spxentry{HBAR}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.HBAR:paramagpy.metal.Metal.HBAR}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{HBAR}}\sphinxbfcode{\sphinxupquote{ = 1.0546e\sphinxhyphen{}34}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.K}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.K:paramagpy-metal-metal-k}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.K::doc}}\index{K (paramagpy.metal.Metal attribute)@\spxentry{K}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.K:paramagpy.metal.Metal.K}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{K}}\sphinxbfcode{\sphinxupquote{ = 1.381e\sphinxhyphen{}23}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.MU0}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.MU0:paramagpy-metal-metal-mu0}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.MU0::doc}}\index{MU0 (paramagpy.metal.Metal attribute)@\spxentry{MU0}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.MU0:paramagpy.metal.Metal.MU0}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{MU0}}\sphinxbfcode{\sphinxupquote{ = 1.2566370614359173e\sphinxhyphen{}06}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.MUB}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.MUB:paramagpy-metal-metal-mub}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.MUB::doc}}\index{MUB (paramagpy.metal.Metal attribute)@\spxentry{MUB}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.MUB:paramagpy.metal.Metal.MUB}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{MUB}}\sphinxbfcode{\sphinxupquote{ = 9.274e\sphinxhyphen{}24}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.a}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.a:paramagpy-metal-metal-a}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.a::doc}}\index{a (paramagpy.metal.Metal property)@\spxentry{a}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.a:paramagpy.metal.Metal.a}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{a}}}
\sphinxAtStartPar
alpha euler anglue

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.alignment\_factor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor:paramagpy-metal-metal-alignment-factor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor::doc}}\index{alignment\_factor (paramagpy.metal.Metal property)@\spxentry{alignment\_factor}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.alignment_factor:paramagpy.metal.Metal.alignment_factor}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{alignment\_factor}}}
\sphinxAtStartPar
Factor for conversion between magnetic susceptibility
and alignment tensors

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.ax}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.ax:paramagpy-metal-metal-ax}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.ax::doc}}\index{ax (paramagpy.metal.Metal property)@\spxentry{ax}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.ax:paramagpy.metal.Metal.ax}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{ax}}}
\sphinxAtStartPar
axiality

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.b}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.b:paramagpy-metal-metal-b}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.b::doc}}\index{b (paramagpy.metal.Metal property)@\spxentry{b}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.b:paramagpy.metal.Metal.b}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{b}}}
\sphinxAtStartPar
beta euler anglue

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.eigenvalues}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues:paramagpy-metal-metal-eigenvalues}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues::doc}}\index{eigenvalues (paramagpy.metal.Metal property)@\spxentry{eigenvalues}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.eigenvalues:paramagpy.metal.Metal.eigenvalues}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{eigenvalues}}}
\sphinxAtStartPar
The eigenvalues defining the magnitude of the principle axes

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fit\_scaling}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling:paramagpy-metal-metal-fit-scaling}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling::doc}}\index{fit\_scaling (paramagpy.metal.Metal attribute)@\spxentry{fit\_scaling}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fit_scaling:paramagpy.metal.Metal.fit_scaling}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fit\_scaling}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}a\textquotesingle{}: 57.29577951308232, \textquotesingle{}ax\textquotesingle{}: 1e+32, \textquotesingle{}b\textquotesingle{}: 57.29577951308232, \textquotesingle{}g\textquotesingle{}: 57.29577951308232, \textquotesingle{}gax\textquotesingle{}: 1e+60, \textquotesingle{}grh\textquotesingle{}: 1e+60, \textquotesingle{}iso\textquotesingle{}: 1e+32, \textquotesingle{}mueff\textquotesingle{}: 1.0782833728703903e+23, \textquotesingle{}rh\textquotesingle{}: 1e+32, \textquotesingle{}t1e\textquotesingle{}: 1000000000000.0, \textquotesingle{}taur\textquotesingle{}: 1000000000.0, \textquotesingle{}x\textquotesingle{}: 10000000000.0, \textquotesingle{}y\textquotesingle{}: 10000000000.0, \textquotesingle{}z\textquotesingle{}: 10000000000.0\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.fundamental\_attributes}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.fundamental_attributes:paramagpy-metal-metal-fundamental-attributes}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.fundamental_attributes::doc}}\index{fundamental\_attributes (paramagpy.metal.Metal attribute)@\spxentry{fundamental\_attributes}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.fundamental_attributes:paramagpy.metal.Metal.fundamental_attributes}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{fundamental\_attributes}}\sphinxbfcode{\sphinxupquote{ = (\textquotesingle{}position\textquotesingle{}, \textquotesingle{}eulers\textquotesingle{}, \textquotesingle{}axrh\textquotesingle{}, \textquotesingle{}mueff\textquotesingle{}, \textquotesingle{}g\_axrh\textquotesingle{}, \textquotesingle{}t1e\textquotesingle{}, \textquotesingle{}shift\textquotesingle{}, \textquotesingle{}temperature\textquotesingle{}, \textquotesingle{}B0\textquotesingle{}, \textquotesingle{}taur\textquotesingle{})}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.g}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.g:paramagpy-metal-metal-g}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.g::doc}}\index{g (paramagpy.metal.Metal property)@\spxentry{g}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.g:paramagpy.metal.Metal.g}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{g}}}
\sphinxAtStartPar
gamma euler anglue

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.g\_eigenvalues}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_eigenvalues:paramagpy-metal-metal-g-eigenvalues}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_eigenvalues::doc}}\index{g\_eigenvalues (paramagpy.metal.Metal property)@\spxentry{g\_eigenvalues}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_eigenvalues:paramagpy.metal.Metal.g_eigenvalues}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{g\_eigenvalues}}}
\sphinxAtStartPar
The eigenvalues defining the magnitude of the principle axes

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.g\_isotropy}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_isotropy:paramagpy-metal-metal-g-isotropy}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_isotropy::doc}}\index{g\_isotropy (paramagpy.metal.Metal property)@\spxentry{g\_isotropy}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_isotropy:paramagpy.metal.Metal.g_isotropy}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{g\_isotropy}}}
\sphinxAtStartPar
Estimate of the spectral power density tensor isotropy

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.g\_tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_tensor:paramagpy-metal-metal-g-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_tensor::doc}}\index{g\_tensor (paramagpy.metal.Metal property)@\spxentry{g\_tensor}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.g_tensor:paramagpy.metal.Metal.g_tensor}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{g\_tensor}}}
\sphinxAtStartPar
The magnetic susceptibility tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.gax}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.gax:paramagpy-metal-metal-gax}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.gax::doc}}\index{gax (paramagpy.metal.Metal property)@\spxentry{gax}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.gax:paramagpy.metal.Metal.gax}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{gax}}}
\sphinxAtStartPar
axial componenet of spectral power density tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.grh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.grh:paramagpy-metal-metal-grh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.grh::doc}}\index{grh (paramagpy.metal.Metal property)@\spxentry{grh}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.grh:paramagpy.metal.Metal.grh}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{grh}}}
\sphinxAtStartPar
axial componenet of spectral power density tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.iso}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.iso:paramagpy-metal-metal-iso}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.iso::doc}}\index{iso (paramagpy.metal.Metal property)@\spxentry{iso}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.iso:paramagpy.metal.Metal.iso}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{iso}}}
\sphinxAtStartPar
isotropy

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.isotropy}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.isotropy:paramagpy-metal-metal-isotropy}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.isotropy::doc}}\index{isotropy (paramagpy.metal.Metal property)@\spxentry{isotropy}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.isotropy:paramagpy.metal.Metal.isotropy}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{isotropy}}}
\sphinxAtStartPar
The magnidue of the isotropic component of the tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.lanth\_axrh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh:paramagpy-metal-metal-lanth-axrh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh::doc}}\index{lanth\_axrh (paramagpy.metal.Metal attribute)@\spxentry{lanth\_axrh}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_axrh:paramagpy.metal.Metal.lanth_axrh}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{lanth\_axrh}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}Ce\textquotesingle{}: (2.08, 0.71), \textquotesingle{}Dy\textquotesingle{}: (34.7, 20.3), \textquotesingle{}Er\textquotesingle{}: (\sphinxhyphen{}11.6, \sphinxhyphen{}8.58), \textquotesingle{}Eu\textquotesingle{}: (\sphinxhyphen{}2.34, \sphinxhyphen{}1.63), \textquotesingle{}Gd\textquotesingle{}: (0.0, 0.0), \textquotesingle{}Ho\textquotesingle{}: (18.5, 5.79), \textquotesingle{}Nd\textquotesingle{}: (1.74, 0.46), \textquotesingle{}Pm\textquotesingle{}: (0.0, 0.0), \textquotesingle{}Pr\textquotesingle{}: (3.4, 2.11), \textquotesingle{}Sm\textquotesingle{}: (0.19, 0.08), \textquotesingle{}Tb\textquotesingle{}: (42.1, 11.2), \textquotesingle{}Tm\textquotesingle{}: (\sphinxhyphen{}21.9, \sphinxhyphen{}20.1), \textquotesingle{}Yb\textquotesingle{}: (\sphinxhyphen{}8.26, \sphinxhyphen{}5.84), \textquotesingle{}Zero\textquotesingle{}: (0.0, 0.0)\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.lanth\_lib}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib:paramagpy-metal-metal-lanth-lib}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib::doc}}\index{lanth\_lib (paramagpy.metal.Metal attribute)@\spxentry{lanth\_lib}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.lanth_lib:paramagpy.metal.Metal.lanth_lib}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{lanth\_lib}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}Ce\textquotesingle{}: (2.5, 0.8571428571428571, 1.33e\sphinxhyphen{}13), \textquotesingle{}Dy\textquotesingle{}: (7.5, 1.3333333333333333, 2.4e\sphinxhyphen{}13), \textquotesingle{}Er\textquotesingle{}: (7.5, 1.2, 1.89e\sphinxhyphen{}13), \textquotesingle{}Eu\textquotesingle{}: (2.0, 1.5, 1.5e\sphinxhyphen{}14), \textquotesingle{}Gd\textquotesingle{}: (3.5, 2.0, 1e\sphinxhyphen{}07), \textquotesingle{}Ho\textquotesingle{}: (8.0, 1.25, 2.09e\sphinxhyphen{}13), \textquotesingle{}Nd\textquotesingle{}: (4.5, 0.7272727272727273, 2.1e\sphinxhyphen{}13), \textquotesingle{}Pm\textquotesingle{}: (4.0, 0.6, 0.0), \textquotesingle{}Pr\textquotesingle{}: (4.0, 0.8, 5.4e\sphinxhyphen{}14), \textquotesingle{}Sm\textquotesingle{}: (2.5, 0.2857142857142857, 7.4e\sphinxhyphen{}14), \textquotesingle{}Tb\textquotesingle{}: (6.0, 1.5, 2.51e\sphinxhyphen{}13), \textquotesingle{}Tm\textquotesingle{}: (6.0, 1.1666666666666667, 2.68e\sphinxhyphen{}13), \textquotesingle{}Yb\textquotesingle{}: (3.5, 1.1428571428571428, 1.57e\sphinxhyphen{}13), \textquotesingle{}Zero\textquotesingle{}: (0.0, 0.0, 0.0)\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.lower\_coords}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords:paramagpy-metal-metal-lower-coords}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords::doc}}\index{lower\_coords (paramagpy.metal.Metal attribute)@\spxentry{lower\_coords}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.lower_coords:paramagpy.metal.Metal.lower_coords}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{lower\_coords}}\sphinxbfcode{\sphinxupquote{ = ((0, 1, 1, 2, 2), (0, 1, 0, 0, 1))}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rh}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rh:paramagpy-metal-metal-rh}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rh::doc}}\index{rh (paramagpy.metal.Metal property)@\spxentry{rh}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rh:paramagpy.metal.Metal.rh}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rh}}}
\sphinxAtStartPar
rhombicity

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.rotationMatrix}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix:paramagpy-metal-metal-rotationmatrix}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix::doc}}\index{rotationMatrix (paramagpy.metal.Metal property)@\spxentry{rotationMatrix}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.rotationMatrix:paramagpy.metal.Metal.rotationMatrix}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{rotationMatrix}}}
\sphinxAtStartPar
The rotation matrix as defined by the euler angles

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.saupe\_factor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor:paramagpy-metal-metal-saupe-factor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor::doc}}\index{saupe\_factor (paramagpy.metal.Metal property)@\spxentry{saupe\_factor}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.saupe_factor:paramagpy.metal.Metal.saupe_factor}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{saupe\_factor}}}
\sphinxAtStartPar
Factor for conversion between magnetic susceptibility
and saupe tensors

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tauc}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tauc:paramagpy-metal-metal-tauc}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tauc::doc}}\index{tauc (paramagpy.metal.Metal property)@\spxentry{tauc}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tauc:paramagpy.metal.Metal.tauc}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tauc}}}
\sphinxAtStartPar
The effective rotational correlation time.

\sphinxAtStartPar
This is calculated by combining the rotational correaltion time
and the electronic relaxation time:
\begin{equation*}
\begin{split}\tau_c = \frac{1}{\frac{1}{\tau_r}+\frac{1}{T_{1e}}}\end{split}
\end{equation*}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor:paramagpy-metal-metal-tensor}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor::doc}}\index{tensor (paramagpy.metal.Metal property)@\spxentry{tensor}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor:paramagpy.metal.Metal.tensor}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor}}}
\sphinxAtStartPar
The magnetic susceptibility tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor\_alignment}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment:paramagpy-metal-metal-tensor-alignment}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment::doc}}\index{tensor\_alignment (paramagpy.metal.Metal property)@\spxentry{tensor\_alignment}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_alignment:paramagpy.metal.Metal.tensor_alignment}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor\_alignment}}}
\sphinxAtStartPar
The alignment tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor\_saupe}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe:paramagpy-metal-metal-tensor-saupe}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe::doc}}\index{tensor\_saupe (paramagpy.metal.Metal property)@\spxentry{tensor\_saupe}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_saupe:paramagpy.metal.Metal.tensor_saupe}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor\_saupe}}}
\sphinxAtStartPar
The saupe tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.tensor\_traceless}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless:paramagpy-metal-metal-tensor-traceless}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless::doc}}\index{tensor\_traceless (paramagpy.metal.Metal property)@\spxentry{tensor\_traceless}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.tensor_traceless:paramagpy.metal.Metal.tensor_traceless}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{tensor\_traceless}}}
\sphinxAtStartPar
The traceless magnetic susceptibility tensor matrix representation

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_coords}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords:paramagpy-metal-metal-upper-coords}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords::doc}}\index{upper\_coords (paramagpy.metal.Metal attribute)@\spxentry{upper\_coords}\spxextra{paramagpy.metal.Metal attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_coords:paramagpy.metal.Metal.upper_coords}}\pysigline{\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_coords}}\sphinxbfcode{\sphinxupquote{ = ((0, 1, 0, 0, 1), (0, 1, 1, 2, 2))}}}
\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_triang}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang:paramagpy-metal-metal-upper-triang}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang::doc}}\index{upper\_triang (paramagpy.metal.Metal property)@\spxentry{upper\_triang}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang:paramagpy.metal.Metal.upper_triang}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_triang}}}
\sphinxAtStartPar
Fetch 5 unique matrix element defining the magnetic
susceptibility tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_triang\_alignment}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment:paramagpy-metal-metal-upper-triang-alignment}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment::doc}}\index{upper\_triang\_alignment (paramagpy.metal.Metal property)@\spxentry{upper\_triang\_alignment}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_alignment:paramagpy.metal.Metal.upper_triang_alignment}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_triang\_alignment}}}
\sphinxAtStartPar
Fetch 5 unique matrix element defining the alignment tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.upper\_triang\_saupe}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe:paramagpy-metal-metal-upper-triang-saupe}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe::doc}}\index{upper\_triang\_saupe (paramagpy.metal.Metal property)@\spxentry{upper\_triang\_saupe}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.upper_triang_saupe:paramagpy.metal.Metal.upper_triang_saupe}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{upper\_triang\_saupe}}}
\sphinxAtStartPar
Fetch 5 unique matrix element defining the magnetic
susceptibility tensor

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.x}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.x:paramagpy-metal-metal-x}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.x::doc}}\index{x (paramagpy.metal.Metal property)@\spxentry{x}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.x:paramagpy.metal.Metal.x}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{x}}}
\sphinxAtStartPar
x coordinate

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.y}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.y:paramagpy-metal-metal-y}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.y::doc}}\index{y (paramagpy.metal.Metal property)@\spxentry{y}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.y:paramagpy.metal.Metal.y}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{y}}}
\sphinxAtStartPar
y coordinate

\end{fulllineitems}



\subparagraph{paramagpy.metal.Metal.z}
\label{\detokenize{reference/generated/paramagpy.metal.Metal.z:paramagpy-metal-metal-z}}\label{\detokenize{reference/generated/paramagpy.metal.Metal.z::doc}}\index{z (paramagpy.metal.Metal property)@\spxentry{z}\spxextra{paramagpy.metal.Metal property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.metal.Metal.z:paramagpy.metal.Metal.z}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{Metal.}}\sphinxbfcode{\sphinxupquote{z}}}
\sphinxAtStartPar
z coordinate

\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Protein module}
\label{\detokenize{reference/index:protein-module}}
\sphinxAtStartPar
This module handles the protein structure coordinates and includes methods for
loading a PDB file and calculating atomic properites such as CSA or gyromagnetic ratio


\subsubsection{paramagpy.protein}
\label{\detokenize{reference/protein:module-paramagpy.protein}}\label{\detokenize{reference/protein:paramagpy-protein}}\label{\detokenize{reference/protein:protein}}\label{\detokenize{reference/protein::doc}}\index{module@\spxentry{module}!paramagpy.protein@\spxentry{paramagpy.protein}}\index{paramagpy.protein@\spxentry{paramagpy.protein}!module@\spxentry{module}}

\paragraph{Functions}
\label{\detokenize{reference/protein:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy.protein.load_pdb}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{load\_pdb}}}}}(fileName{[}, ident{]})
&
\sphinxAtStartPar
Read PDB from file into biopython structure object
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.rotation_matrix:paramagpy.protein.rotation_matrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{rotation\_matrix}}}}}(axis, theta)
&
\sphinxAtStartPar
Return the rotation matrix associated with counterclockwise rotation about the given axis by theta radians.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.load\_pdb}
\label{\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy-protein-load-pdb}}\label{\detokenize{reference/generated/paramagpy.protein.load_pdb::doc}}\index{load\_pdb() (in module paramagpy.protein)@\spxentry{load\_pdb()}\spxextra{in module paramagpy.protein}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.load_pdb:paramagpy.protein.load_pdb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{load\_pdb}}}{\emph{\DUrole{n}{fileName}}, \emph{\DUrole{n}{ident}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Read PDB from file into biopython structure object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ident}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} the desired identity of the structure object

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{values} \textendash{} a structure object containing the atomic coordinates

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.rotation\_matrix}
\label{\detokenize{reference/generated/paramagpy.protein.rotation_matrix:paramagpy-protein-rotation-matrix}}\label{\detokenize{reference/generated/paramagpy.protein.rotation_matrix::doc}}\index{rotation\_matrix() (in module paramagpy.protein)@\spxentry{rotation\_matrix()}\spxextra{in module paramagpy.protein}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.rotation_matrix:paramagpy.protein.rotation_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{rotation\_matrix}}}{\emph{\DUrole{n}{axis}}, \emph{\DUrole{n}{theta}}}{}
\sphinxAtStartPar
Return the rotation matrix associated with counterclockwise
rotation about the given axis by theta radians.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{axis}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the {[}x,y,z{]} axis for rotation.

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{matrix} \textendash{} the rotation matrix

\item[{Return type}] \leavevmode
\sphinxAtStartPar
numpy 3x3 matrix object

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{Classes}
\label{\detokenize{reference/protein:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomAtom}}}}}(*arg, **kwargs)
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomStructure}}}}}(*arg, **kwargs)
&
\sphinxAtStartPar
This is an overload hack of the BioPython Structure object
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy.protein.CustomStructureBuilder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{CustomStructureBuilder}}}}}(*arg, **kwargs)
&
\sphinxAtStartPar
This is an overload hack of BioPython’s CustomStructureBuilder
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.PyMolScript:paramagpy.protein.PyMolScript}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{PyMolScript}}}}}()
&
\sphinxAtStartPar
A PyMol helper class for constructing a PyMol script that will load PDB files and density map files
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomAtom}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy-protein-customatom}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom::doc}}\index{CustomAtom (class in paramagpy.protein)@\spxentry{CustomAtom}\spxextra{class in paramagpy.protein}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{CustomAtom}}}{\emph{\DUrole{o}{*}\DUrole{n}{arg}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}~\index{\_\_init\_\_() (paramagpy.protein.CustomAtom method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom:paramagpy.protein.CustomAtom.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{arg}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Initialize Atom object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{name}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} atom name (eg. “CA”). Note that spaces are normally stripped.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coord}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{Float0}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{size 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} atomic coordinates (x,y,z)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bfactor}} (\sphinxstyleliteralemphasis{\sphinxupquote{number}}) \textendash{} isotropic B factor

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{occupancy}} (\sphinxstyleliteralemphasis{\sphinxupquote{number}}) \textendash{} occupancy (0.0\sphinxhyphen{}1.0)

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{altloc}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} alternative location specifier for disordered atoms

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fullname}} (\sphinxstyleliteralemphasis{\sphinxupquote{string}}) \textendash{} full atom name, including spaces, e.g. ” CA “. Normally
these spaces are stripped from the atom name.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{element}} (\sphinxstyleliteralemphasis{\sphinxupquote{uppercase string}}\sphinxstyleliteralemphasis{\sphinxupquote{ (or }}\sphinxstyleliteralemphasis{\sphinxupquote{None if unknown}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} atom element, e.g. “C” for Carbon, “HG” for mercury,

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pqr\_charge}} (\sphinxstyleliteralemphasis{\sphinxupquote{number}}) \textendash{} atom charge

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{number}}) \textendash{} atom radius

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy:paramagpy.protein.CustomAtom.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
\sphinxAtStartPar
Create a copy of the Atom.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent:paramagpy.protein.CustomAtom.detach_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{detach\_parent}}}}}()
&
\sphinxAtStartPar
Remove reference to parent.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor:paramagpy.protein.CustomAtom.dipole_shift_tensor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{dipole\_shift\_tensor}}}}}(position)
&
\sphinxAtStartPar
Calculate the magnetic field shielding tensor at the given postition due to the nuclear dipole
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder:paramagpy.protein.CustomAtom.flag_disorder}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{flag\_disorder}}}}}()
&
\sphinxAtStartPar
Set the disordered flag to 1.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc:paramagpy.protein.CustomAtom.get_altloc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_altloc}}}}}()
&
\sphinxAtStartPar
Return alternative location specifier.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou:paramagpy.protein.CustomAtom.get_anisou}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_anisou}}}}}()
&
\sphinxAtStartPar
Return anisotropic B factor.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor:paramagpy.protein.CustomAtom.get_bfactor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_bfactor}}}}}()
&
\sphinxAtStartPar
Return B factor.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_charge:paramagpy.protein.CustomAtom.get_charge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_charge}}}}}()
&
\sphinxAtStartPar
Return charge.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord:paramagpy.protein.CustomAtom.get_coord}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_coord}}}}}()
&
\sphinxAtStartPar
Return atomic coordinates.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id:paramagpy.protein.CustomAtom.get_full_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_full\_id}}}}}()
&
\sphinxAtStartPar
Return the full id of the atom.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname:paramagpy.protein.CustomAtom.get_fullname}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_fullname}}}}}()
&
\sphinxAtStartPar
Return the atom name, including leading and trailing spaces.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id:paramagpy.protein.CustomAtom.get_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_id}}}}}()
&
\sphinxAtStartPar
Return the id of the atom (which is its atom name).
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level:paramagpy.protein.CustomAtom.get_level}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_level}}}}}()
&
\sphinxAtStartPar
Return level.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name:paramagpy.protein.CustomAtom.get_name}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_name}}}}}()
&
\sphinxAtStartPar
Return atom name.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy:paramagpy.protein.CustomAtom.get_occupancy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_occupancy}}}}}()
&
\sphinxAtStartPar
Return occupancy.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent:paramagpy.protein.CustomAtom.get_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_parent}}}}}()
&
\sphinxAtStartPar
Return parent residue.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_radius:paramagpy.protein.CustomAtom.get_radius}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_radius}}}}}()
&
\sphinxAtStartPar
Return radius.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number:paramagpy.protein.CustomAtom.get_serial_number}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_serial\_number}}}}}()
&
\sphinxAtStartPar
Return the serial number.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm:paramagpy.protein.CustomAtom.get_sigatm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_sigatm}}}}}()
&
\sphinxAtStartPar
Return standard deviation of atomic parameters.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij:paramagpy.protein.CustomAtom.get_siguij}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_siguij}}}}}()
&
\sphinxAtStartPar
Return standard deviations of anisotropic temperature factors.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector:paramagpy.protein.CustomAtom.get_vector}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_vector}}}}}()
&
\sphinxAtStartPar
Return coordinates as Vector.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered:paramagpy.protein.CustomAtom.is_disordered}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{is\_disordered}}}}}()
&
\sphinxAtStartPar
Return the disordered flag (1 if disordered, 0 otherwise).
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc:paramagpy.protein.CustomAtom.set_altloc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_altloc}}}}}(altloc)
&
\sphinxAtStartPar
Set alternative location specifier.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou:paramagpy.protein.CustomAtom.set_anisou}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_anisou}}}}}(anisou\_array)
&
\sphinxAtStartPar
Set anisotropic B factor.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor:paramagpy.protein.CustomAtom.set_bfactor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_bfactor}}}}}(bfactor)
&
\sphinxAtStartPar
Set isotroptic B factor.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_charge:paramagpy.protein.CustomAtom.set_charge}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_charge}}}}}(pqr\_charge)
&
\sphinxAtStartPar
Set charge.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord:paramagpy.protein.CustomAtom.set_coord}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_coord}}}}}(coord)
&
\sphinxAtStartPar
Set coordinates.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy:paramagpy.protein.CustomAtom.set_occupancy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_occupancy}}}}}(occupancy)
&
\sphinxAtStartPar
Set occupancy.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent:paramagpy.protein.CustomAtom.set_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_parent}}}}}(parent)
&
\sphinxAtStartPar
Set the parent residue.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_radius:paramagpy.protein.CustomAtom.set_radius}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_radius}}}}}(radius)
&
\sphinxAtStartPar
Set radius.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number:paramagpy.protein.CustomAtom.set_serial_number}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_serial\_number}}}}}(n)
&
\sphinxAtStartPar
Set serial number.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm:paramagpy.protein.CustomAtom.set_sigatm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_sigatm}}}}}(sigatm\_array)
&
\sphinxAtStartPar
Set standard deviation of atomic parameters.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij:paramagpy.protein.CustomAtom.set_siguij}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_siguij}}}}}(siguij\_array)
&
\sphinxAtStartPar
Set standard deviations of anisotropic temperature factors.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.top:paramagpy.protein.CustomAtom.top}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{top}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform:paramagpy.protein.CustomAtom.transform}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transform}}}}}(rot, tran)
&
\sphinxAtStartPar
Apply rotation and translation to the atomic coordinates.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomAtom.copy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy:paramagpy-protein-customatom-copy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy::doc}}\index{copy() (paramagpy.protein.CustomAtom method)@\spxentry{copy()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.copy:paramagpy.protein.CustomAtom.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{}
\sphinxAtStartPar
Create a copy of the Atom.

\sphinxAtStartPar
Parent information is lost.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.detach\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent:paramagpy-protein-customatom-detach-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent::doc}}\index{detach\_parent() (paramagpy.protein.CustomAtom method)@\spxentry{detach\_parent()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.detach_parent:paramagpy.protein.CustomAtom.detach_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{detach\_parent}}}{}{}
\sphinxAtStartPar
Remove reference to parent.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.dipole\_shift\_tensor}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor:paramagpy-protein-customatom-dipole-shift-tensor}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor::doc}}\index{dipole\_shift\_tensor() (paramagpy.protein.CustomAtom method)@\spxentry{dipole\_shift\_tensor()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.dipole_shift_tensor:paramagpy.protein.CustomAtom.dipole_shift_tensor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{dipole\_shift\_tensor}}}{\emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
Calculate the magnetic field shielding tensor at the given postition
due to the nuclear dipole

\sphinxAtStartPar
Assumes nuclear spin 1/2
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{array floats}}) \textendash{} the position (x, y, z) in meters

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{dipole\_shielding\_tensor} \textendash{} the tensor describing magnetic shielding at the given position

\item[{Return type}] \leavevmode
\sphinxAtStartPar
3x3 array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.flag\_disorder}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder:paramagpy-protein-customatom-flag-disorder}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder::doc}}\index{flag\_disorder() (paramagpy.protein.CustomAtom method)@\spxentry{flag\_disorder()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.flag_disorder:paramagpy.protein.CustomAtom.flag_disorder}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{flag\_disorder}}}{}{}
\sphinxAtStartPar
Set the disordered flag to 1.

\sphinxAtStartPar
The disordered flag indicates whether the atom is disordered or not.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_altloc}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc:paramagpy-protein-customatom-get-altloc}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc::doc}}\index{get\_altloc() (paramagpy.protein.CustomAtom method)@\spxentry{get\_altloc()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_altloc:paramagpy.protein.CustomAtom.get_altloc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_altloc}}}{}{}
\sphinxAtStartPar
Return alternative location specifier.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_anisou}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou:paramagpy-protein-customatom-get-anisou}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou::doc}}\index{get\_anisou() (paramagpy.protein.CustomAtom method)@\spxentry{get\_anisou()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_anisou:paramagpy.protein.CustomAtom.get_anisou}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_anisou}}}{}{}
\sphinxAtStartPar
Return anisotropic B factor.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_bfactor}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor:paramagpy-protein-customatom-get-bfactor}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor::doc}}\index{get\_bfactor() (paramagpy.protein.CustomAtom method)@\spxentry{get\_bfactor()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_bfactor:paramagpy.protein.CustomAtom.get_bfactor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_bfactor}}}{}{}
\sphinxAtStartPar
Return B factor.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_charge}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_charge:paramagpy-protein-customatom-get-charge}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_charge::doc}}\index{get\_charge() (paramagpy.protein.CustomAtom method)@\spxentry{get\_charge()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_charge:paramagpy.protein.CustomAtom.get_charge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_charge}}}{}{}
\sphinxAtStartPar
Return charge.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_coord}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord:paramagpy-protein-customatom-get-coord}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord::doc}}\index{get\_coord() (paramagpy.protein.CustomAtom method)@\spxentry{get\_coord()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_coord:paramagpy.protein.CustomAtom.get_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_coord}}}{}{}
\sphinxAtStartPar
Return atomic coordinates.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_full\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id:paramagpy-protein-customatom-get-full-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id::doc}}\index{get\_full\_id() (paramagpy.protein.CustomAtom method)@\spxentry{get\_full\_id()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_full_id:paramagpy.protein.CustomAtom.get_full_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_full\_id}}}{}{}
\sphinxAtStartPar
Return the full id of the atom.

\sphinxAtStartPar
The full id of an atom is a tuple used to uniquely identify
the atom and consists of the following elements:
(structure id, model id, chain id, residue id, atom name, altloc)

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_fullname}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname:paramagpy-protein-customatom-get-fullname}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname::doc}}\index{get\_fullname() (paramagpy.protein.CustomAtom method)@\spxentry{get\_fullname()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_fullname:paramagpy.protein.CustomAtom.get_fullname}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_fullname}}}{}{}
\sphinxAtStartPar
Return the atom name, including leading and trailing spaces.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id:paramagpy-protein-customatom-get-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id::doc}}\index{get\_id() (paramagpy.protein.CustomAtom method)@\spxentry{get\_id()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_id:paramagpy.protein.CustomAtom.get_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_id}}}{}{}
\sphinxAtStartPar
Return the id of the atom (which is its atom name).

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_level}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level:paramagpy-protein-customatom-get-level}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level::doc}}\index{get\_level() (paramagpy.protein.CustomAtom method)@\spxentry{get\_level()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_level:paramagpy.protein.CustomAtom.get_level}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_level}}}{}{}
\sphinxAtStartPar
Return level.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_name}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name:paramagpy-protein-customatom-get-name}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name::doc}}\index{get\_name() (paramagpy.protein.CustomAtom method)@\spxentry{get\_name()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_name:paramagpy.protein.CustomAtom.get_name}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_name}}}{}{}
\sphinxAtStartPar
Return atom name.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_occupancy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy:paramagpy-protein-customatom-get-occupancy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy::doc}}\index{get\_occupancy() (paramagpy.protein.CustomAtom method)@\spxentry{get\_occupancy()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_occupancy:paramagpy.protein.CustomAtom.get_occupancy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_occupancy}}}{}{}
\sphinxAtStartPar
Return occupancy.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent:paramagpy-protein-customatom-get-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent::doc}}\index{get\_parent() (paramagpy.protein.CustomAtom method)@\spxentry{get\_parent()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_parent:paramagpy.protein.CustomAtom.get_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_parent}}}{}{}
\sphinxAtStartPar
Return parent residue.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_radius}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_radius:paramagpy-protein-customatom-get-radius}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_radius::doc}}\index{get\_radius() (paramagpy.protein.CustomAtom method)@\spxentry{get\_radius()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_radius:paramagpy.protein.CustomAtom.get_radius}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_radius}}}{}{}
\sphinxAtStartPar
Return radius.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_serial\_number}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number:paramagpy-protein-customatom-get-serial-number}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number::doc}}\index{get\_serial\_number() (paramagpy.protein.CustomAtom method)@\spxentry{get\_serial\_number()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_serial_number:paramagpy.protein.CustomAtom.get_serial_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_serial\_number}}}{}{}
\sphinxAtStartPar
Return the serial number.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_sigatm}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm:paramagpy-protein-customatom-get-sigatm}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm::doc}}\index{get\_sigatm() (paramagpy.protein.CustomAtom method)@\spxentry{get\_sigatm()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_sigatm:paramagpy.protein.CustomAtom.get_sigatm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_sigatm}}}{}{}
\sphinxAtStartPar
Return standard deviation of atomic parameters.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_siguij}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij:paramagpy-protein-customatom-get-siguij}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij::doc}}\index{get\_siguij() (paramagpy.protein.CustomAtom method)@\spxentry{get\_siguij()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_siguij:paramagpy.protein.CustomAtom.get_siguij}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_siguij}}}{}{}
\sphinxAtStartPar
Return standard deviations of anisotropic temperature factors.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.get\_vector}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector:paramagpy-protein-customatom-get-vector}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector::doc}}\index{get\_vector() (paramagpy.protein.CustomAtom method)@\spxentry{get\_vector()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.get_vector:paramagpy.protein.CustomAtom.get_vector}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{get\_vector}}}{}{}
\sphinxAtStartPar
Return coordinates as Vector.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
coordinates as 3D vector

\item[{Return type}] \leavevmode
\sphinxAtStartPar
Bio.PDB.Vector class

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.is\_disordered}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered:paramagpy-protein-customatom-is-disordered}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered::doc}}\index{is\_disordered() (paramagpy.protein.CustomAtom method)@\spxentry{is\_disordered()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.is_disordered:paramagpy.protein.CustomAtom.is_disordered}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{is\_disordered}}}{}{}
\sphinxAtStartPar
Return the disordered flag (1 if disordered, 0 otherwise).

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_altloc}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc:paramagpy-protein-customatom-set-altloc}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc::doc}}\index{set\_altloc() (paramagpy.protein.CustomAtom method)@\spxentry{set\_altloc()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_altloc:paramagpy.protein.CustomAtom.set_altloc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_altloc}}}{\emph{\DUrole{n}{altloc}}}{}
\sphinxAtStartPar
Set alternative location specifier.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_anisou}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou:paramagpy-protein-customatom-set-anisou}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou::doc}}\index{set\_anisou() (paramagpy.protein.CustomAtom method)@\spxentry{set\_anisou()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_anisou:paramagpy.protein.CustomAtom.set_anisou}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_anisou}}}{\emph{\DUrole{n}{anisou\_array}}}{}
\sphinxAtStartPar
Set anisotropic B factor.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{anisou\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{length 6}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} anisotropic B factor.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_bfactor}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor:paramagpy-protein-customatom-set-bfactor}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor::doc}}\index{set\_bfactor() (paramagpy.protein.CustomAtom method)@\spxentry{set\_bfactor()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_bfactor:paramagpy.protein.CustomAtom.set_bfactor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_bfactor}}}{\emph{\DUrole{n}{bfactor}}}{}
\sphinxAtStartPar
Set isotroptic B factor.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_charge}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_charge:paramagpy-protein-customatom-set-charge}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_charge::doc}}\index{set\_charge() (paramagpy.protein.CustomAtom method)@\spxentry{set\_charge()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_charge:paramagpy.protein.CustomAtom.set_charge}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_charge}}}{\emph{\DUrole{n}{pqr\_charge}}}{}
\sphinxAtStartPar
Set charge.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_coord}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord:paramagpy-protein-customatom-set-coord}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord::doc}}\index{set\_coord() (paramagpy.protein.CustomAtom method)@\spxentry{set\_coord()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_coord:paramagpy.protein.CustomAtom.set_coord}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_coord}}}{\emph{\DUrole{n}{coord}}}{}
\sphinxAtStartPar
Set coordinates.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_occupancy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy:paramagpy-protein-customatom-set-occupancy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy::doc}}\index{set\_occupancy() (paramagpy.protein.CustomAtom method)@\spxentry{set\_occupancy()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_occupancy:paramagpy.protein.CustomAtom.set_occupancy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_occupancy}}}{\emph{\DUrole{n}{occupancy}}}{}
\sphinxAtStartPar
Set occupancy.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent:paramagpy-protein-customatom-set-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent::doc}}\index{set\_parent() (paramagpy.protein.CustomAtom method)@\spxentry{set\_parent()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_parent:paramagpy.protein.CustomAtom.set_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_parent}}}{\emph{\DUrole{n}{parent}}}{}
\sphinxAtStartPar
Set the parent residue.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{object}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} parent \sphinxhyphen{} Residue}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_radius}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_radius:paramagpy-protein-customatom-set-radius}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_radius::doc}}\index{set\_radius() (paramagpy.protein.CustomAtom method)@\spxentry{set\_radius()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_radius:paramagpy.protein.CustomAtom.set_radius}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_radius}}}{\emph{\DUrole{n}{radius}}}{}
\sphinxAtStartPar
Set radius.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_serial\_number}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number:paramagpy-protein-customatom-set-serial-number}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number::doc}}\index{set\_serial\_number() (paramagpy.protein.CustomAtom method)@\spxentry{set\_serial\_number()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_serial_number:paramagpy.protein.CustomAtom.set_serial_number}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_serial\_number}}}{\emph{\DUrole{n}{n}}}{}
\sphinxAtStartPar
Set serial number.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_sigatm}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm:paramagpy-protein-customatom-set-sigatm}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm::doc}}\index{set\_sigatm() (paramagpy.protein.CustomAtom method)@\spxentry{set\_sigatm()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_sigatm:paramagpy.protein.CustomAtom.set_sigatm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_sigatm}}}{\emph{\DUrole{n}{sigatm\_array}}}{}
\sphinxAtStartPar
Set standard deviation of atomic parameters.

\sphinxAtStartPar
The standard deviation of atomic parameters consists
of 3 positional, 1 B factor and 1 occupancy standard
deviation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{sigatm\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{length 5}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} standard deviations of atomic parameters.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.set\_siguij}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij:paramagpy-protein-customatom-set-siguij}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij::doc}}\index{set\_siguij() (paramagpy.protein.CustomAtom method)@\spxentry{set\_siguij()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.set_siguij:paramagpy.protein.CustomAtom.set_siguij}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{set\_siguij}}}{\emph{\DUrole{n}{siguij\_array}}}{}
\sphinxAtStartPar
Set standard deviations of anisotropic temperature factors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{siguij\_array}} (\sphinxstyleliteralemphasis{\sphinxupquote{Numeric array}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{length 6}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} standard deviations of anisotropic temperature factors.

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.top}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.top:paramagpy-protein-customatom-top}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.top::doc}}\index{top() (paramagpy.protein.CustomAtom method)@\spxentry{top()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.top:paramagpy.protein.CustomAtom.top}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{top}}}{}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.transform}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform:paramagpy-protein-customatom-transform}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform::doc}}\index{transform() (paramagpy.protein.CustomAtom method)@\spxentry{transform()}\spxextra{paramagpy.protein.CustomAtom method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.transform:paramagpy.protein.CustomAtom.transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{rot}}, \emph{\DUrole{n}{tran}}}{}
\sphinxAtStartPar
Apply rotation and translation to the atomic coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 Numeric array}}) \textendash{} A right multiplying rotation matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tran}} (\sphinxstyleliteralemphasis{\sphinxupquote{size 3 Numeric array}}) \textendash{} the translation vector

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\sphinxAtStartPar
This is an incomplete but illustrative example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{array}
\PYG{k+kn}{from} \PYG{n+nn}{Bio}\PYG{n+nn}{.}\PYG{n+nn}{PDB}\PYG{n+nn}{.}\PYG{n+nn}{vectors} \PYG{k+kn}{import} \PYG{n}{Vector}\PYG{p}{,} \PYG{n}{rotmat}
\PYG{n}{rotation} \PYG{o}{=} \PYG{n}{rotmat}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{translation} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{atom}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{rotation}\PYG{p}{,} \PYG{n}{translation}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR:paramagpy.protein.CustomAtom.HBAR}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{HBAR}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0:paramagpy.protein.CustomAtom.MU0}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MU0}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa:paramagpy.protein.CustomAtom.csa}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{csa}}}}}
&
\sphinxAtStartPar
Get the CSA tensor at the nuclear position This uses the geometry of neighbouring atoms and a standard library from Bax J.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib:paramagpy.protein.CustomAtom.csa_lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{csa\_lib}}}}}
&
\sphinxAtStartPar
docstring for CustomAtom
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib:paramagpy.protein.CustomAtom.gyro_lib}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gyro\_lib}}}}}
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomAtom.position:paramagpy.protein.CustomAtom.position}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{position}}}}}
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomAtom.HBAR}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR:paramagpy-protein-customatom-hbar}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR::doc}}\index{HBAR (paramagpy.protein.CustomAtom attribute)@\spxentry{HBAR}\spxextra{paramagpy.protein.CustomAtom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.HBAR:paramagpy.protein.CustomAtom.HBAR}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{HBAR}}\sphinxbfcode{\sphinxupquote{ = 1.0546e\sphinxhyphen{}34}}}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.MU0}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0:paramagpy-protein-customatom-mu0}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0::doc}}\index{MU0 (paramagpy.protein.CustomAtom attribute)@\spxentry{MU0}\spxextra{paramagpy.protein.CustomAtom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.MU0:paramagpy.protein.CustomAtom.MU0}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{MU0}}\sphinxbfcode{\sphinxupquote{ = 1.2566370614359173e\sphinxhyphen{}06}}}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.csa}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa:paramagpy-protein-customatom-csa}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa::doc}}\index{csa (paramagpy.protein.CustomAtom property)@\spxentry{csa}\spxextra{paramagpy.protein.CustomAtom property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa:paramagpy.protein.CustomAtom.csa}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{csa}}}
\sphinxAtStartPar
Get the CSA tensor at the nuclear position
This uses the geometry of neighbouring atoms
and a standard library from Bax J. Am. Chem. Soc. 2000
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{matrix} \textendash{} the CSA tensor in the PDB frame
if appropriate nuclear positions are not
available \textless{}None\textgreater{} is returned.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
3x3 array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.csa\_lib}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib:paramagpy-protein-customatom-csa-lib}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib::doc}}\index{csa\_lib (paramagpy.protein.CustomAtom attribute)@\spxentry{csa\_lib}\spxextra{paramagpy.protein.CustomAtom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.csa_lib:paramagpy.protein.CustomAtom.csa_lib}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{csa\_lib}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}C\textquotesingle{}: (array({[}\sphinxhyphen{}8.65e\sphinxhyphen{}05,  1.18e\sphinxhyphen{}05,  7.47e\sphinxhyphen{}05{]}), 0.6632251157578453), \textquotesingle{}H\textquotesingle{}: (array({[}\sphinxhyphen{}5.8e\sphinxhyphen{}06,  0.0e+00,  5.8e\sphinxhyphen{}06{]}), 0.13962634015954636), \textquotesingle{}N\textquotesingle{}: (array({[}\sphinxhyphen{}6.280e\sphinxhyphen{}05, \sphinxhyphen{}4.570e\sphinxhyphen{}05,  1.085e\sphinxhyphen{}04{]}), 0.33161255787892263)\}}}}
\sphinxAtStartPar
docstring for CustomAtom

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.gyro\_lib}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib:paramagpy-protein-customatom-gyro-lib}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib::doc}}\index{gyro\_lib (paramagpy.protein.CustomAtom attribute)@\spxentry{gyro\_lib}\spxextra{paramagpy.protein.CustomAtom attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.gyro_lib:paramagpy.protein.CustomAtom.gyro_lib}}\pysigline{\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{gyro\_lib}}\sphinxbfcode{\sphinxupquote{ = \{\textquotesingle{}C\textquotesingle{}: 67261498.71335746, \textquotesingle{}H\textquotesingle{}: 267512897.63847807, \textquotesingle{}N\textquotesingle{}: \sphinxhyphen{}27118227.785787094\}}}}
\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomAtom.position}
\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.position:paramagpy-protein-customatom-position}}\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.position::doc}}\index{position (paramagpy.protein.CustomAtom property)@\spxentry{position}\spxextra{paramagpy.protein.CustomAtom property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomAtom.position:paramagpy.protein.CustomAtom.position}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{CustomAtom.}}\sphinxbfcode{\sphinxupquote{position}}}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy-protein-customstructure}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure::doc}}\index{CustomStructure (class in paramagpy.protein)@\spxentry{CustomStructure}\spxextra{class in paramagpy.protein}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{CustomStructure}}}{\emph{\DUrole{o}{*}\DUrole{n}{arg}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
This is an overload hack of the BioPython Structure object
\index{\_\_init\_\_() (paramagpy.protein.CustomStructure method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure:paramagpy.protein.CustomStructure.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{arg}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Initialize the class.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.add:paramagpy.protein.CustomStructure.add}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add}}}}}(entity)
&
\sphinxAtStartPar
Add a child to the Entity.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.atom_to_internal_coordinates:paramagpy.protein.CustomStructure.atom_to_internal_coordinates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{atom\_to\_internal\_coordinates}}}}}({[}verbose{]})
&
\sphinxAtStartPar
Create/update internal coordinates from Atom X,Y,Z coordinates.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.center_of_mass:paramagpy.protein.CustomStructure.center_of_mass}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{center\_of\_mass}}}}}({[}geometric{]})
&
\sphinxAtStartPar
Return the center of mass of the Entity as a numpy array.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy:paramagpy.protein.CustomStructure.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
\sphinxAtStartPar
Copy entity recursively.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child:paramagpy.protein.CustomStructure.detach_child}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{detach\_child}}}}}(id)
&
\sphinxAtStartPar
Remove a child.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent:paramagpy.protein.CustomStructure.detach_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{detach\_parent}}}}}()
&
\sphinxAtStartPar
Detach the parent.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms:paramagpy.protein.CustomStructure.get_atoms}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_atoms}}}}}()
&
\sphinxAtStartPar
Return atoms from residue.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains:paramagpy.protein.CustomStructure.get_chains}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_chains}}}}}()
&
\sphinxAtStartPar
Return chains from models.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id:paramagpy.protein.CustomStructure.get_full_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_full\_id}}}}}()
&
\sphinxAtStartPar
Return the full id.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id:paramagpy.protein.CustomStructure.get_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_id}}}}}()
&
\sphinxAtStartPar
Return the id.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator:paramagpy.protein.CustomStructure.get_iterator}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_iterator}}}}}()
&
\sphinxAtStartPar
Return iterator over children.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level:paramagpy.protein.CustomStructure.get_level}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_level}}}}}()
&
\sphinxAtStartPar
Return level in hierarchy.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list:paramagpy.protein.CustomStructure.get_list}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_list}}}}}()
&
\sphinxAtStartPar
Return a copy of the list of children.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models:paramagpy.protein.CustomStructure.get_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_models}}}}}()
&
\sphinxAtStartPar
Return models.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent:paramagpy.protein.CustomStructure.get_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_parent}}}}}()
&
\sphinxAtStartPar
Return the parent Entity object.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues:paramagpy.protein.CustomStructure.get_residues}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_residues}}}}}()
&
\sphinxAtStartPar
Return residues from chains.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id:paramagpy.protein.CustomStructure.has_id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{has\_id}}}}}(id)
&
\sphinxAtStartPar
Check if a child with given id exists.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert:paramagpy.protein.CustomStructure.insert}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{insert}}}}}(pos, entity)
&
\sphinxAtStartPar
Add a child to the Entity at a specified position.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.internal_to_atom_coordinates:paramagpy.protein.CustomStructure.internal_to_atom_coordinates}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{internal\_to\_atom\_coordinates}}}}}({[}verbose{]})
&
\sphinxAtStartPar
Create/update atom coordinates from internal coordinates.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse}}}}}(dataValues{[}, models{]})
&
\sphinxAtStartPar
Associate experimental data with atoms of the PDB file This method takes a DataContainer instance from the dataparse module
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent:paramagpy.protein.CustomStructure.set_parent}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_parent}}}}}(entity)
&
\sphinxAtStartPar
Set the parent Entity object.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform:paramagpy.protein.CustomStructure.transform}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{transform}}}}}(rot, tran)
&
\sphinxAtStartPar
Apply rotation and translation to the atomic coordinates.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomStructure.add}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.add:paramagpy-protein-customstructure-add}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.add::doc}}\index{add() (paramagpy.protein.CustomStructure method)@\spxentry{add()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.add:paramagpy.protein.CustomStructure.add}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{add}}}{\emph{\DUrole{n}{entity}}}{}
\sphinxAtStartPar
Add a child to the Entity.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.atom\_to\_internal\_coordinates}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.atom_to_internal_coordinates:paramagpy-protein-customstructure-atom-to-internal-coordinates}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.atom_to_internal_coordinates::doc}}\index{atom\_to\_internal\_coordinates() (paramagpy.protein.CustomStructure method)@\spxentry{atom\_to\_internal\_coordinates()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.atom_to_internal_coordinates:paramagpy.protein.CustomStructure.atom_to_internal_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{atom\_to\_internal\_coordinates}}}{\emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Create/update internal coordinates from Atom X,Y,Z coordinates.

\sphinxAtStartPar
Internal coordinates are bond length, angle and dihedral angles.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{verbose}}) \textendash{} default False
describe runtime problems

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.center\_of\_mass}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.center_of_mass:paramagpy-protein-customstructure-center-of-mass}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.center_of_mass::doc}}\index{center\_of\_mass() (paramagpy.protein.CustomStructure method)@\spxentry{center\_of\_mass()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.center_of_mass:paramagpy.protein.CustomStructure.center_of_mass}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{center\_of\_mass}}}{\emph{\DUrole{n}{geometric}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Return the center of mass of the Entity as a numpy array.

\sphinxAtStartPar
If geometric is True, returns the center of geometry instead.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.copy}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy:paramagpy-protein-customstructure-copy}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy::doc}}\index{copy() (paramagpy.protein.CustomStructure method)@\spxentry{copy()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.copy:paramagpy.protein.CustomStructure.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{}
\sphinxAtStartPar
Copy entity recursively.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.detach\_child}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child:paramagpy-protein-customstructure-detach-child}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child::doc}}\index{detach\_child() (paramagpy.protein.CustomStructure method)@\spxentry{detach\_child()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_child:paramagpy.protein.CustomStructure.detach_child}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{detach\_child}}}{\emph{\DUrole{n}{id}}}{}
\sphinxAtStartPar
Remove a child.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.detach\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent:paramagpy-protein-customstructure-detach-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent::doc}}\index{detach\_parent() (paramagpy.protein.CustomStructure method)@\spxentry{detach\_parent()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.detach_parent:paramagpy.protein.CustomStructure.detach_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{detach\_parent}}}{}{}
\sphinxAtStartPar
Detach the parent.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_atoms}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms:paramagpy-protein-customstructure-get-atoms}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms::doc}}\index{get\_atoms() (paramagpy.protein.CustomStructure method)@\spxentry{get\_atoms()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_atoms:paramagpy.protein.CustomStructure.get_atoms}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_atoms}}}{}{}
\sphinxAtStartPar
Return atoms from residue.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_chains}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains:paramagpy-protein-customstructure-get-chains}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains::doc}}\index{get\_chains() (paramagpy.protein.CustomStructure method)@\spxentry{get\_chains()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_chains:paramagpy.protein.CustomStructure.get_chains}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_chains}}}{}{}
\sphinxAtStartPar
Return chains from models.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_full\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id:paramagpy-protein-customstructure-get-full-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id::doc}}\index{get\_full\_id() (paramagpy.protein.CustomStructure method)@\spxentry{get\_full\_id()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_full_id:paramagpy.protein.CustomStructure.get_full_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_full\_id}}}{}{}
\sphinxAtStartPar
Return the full id.

\sphinxAtStartPar
The full id is a tuple containing all id’s starting from
the top object (Structure) down to the current object. A full id for
a Residue object e.g. is something like:

\sphinxAtStartPar
(“1abc”, 0, “A”, (” “, 10, “A”))

\sphinxAtStartPar
This corresponds to:

\sphinxAtStartPar
Structure with id “1abc”
Model with id 0
Chain with id “A”
Residue with id (” “, 10, “A”)

\sphinxAtStartPar
The Residue id indicates that the residue is not a hetero\sphinxhyphen{}residue
(or a water) because it has a blank hetero field, that its sequence
identifier is 10 and its insertion code “A”.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id:paramagpy-protein-customstructure-get-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id::doc}}\index{get\_id() (paramagpy.protein.CustomStructure method)@\spxentry{get\_id()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_id:paramagpy.protein.CustomStructure.get_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_id}}}{}{}
\sphinxAtStartPar
Return the id.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_iterator}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator:paramagpy-protein-customstructure-get-iterator}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator::doc}}\index{get\_iterator() (paramagpy.protein.CustomStructure method)@\spxentry{get\_iterator()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_iterator:paramagpy.protein.CustomStructure.get_iterator}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_iterator}}}{}{}
\sphinxAtStartPar
Return iterator over children.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_level}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level:paramagpy-protein-customstructure-get-level}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level::doc}}\index{get\_level() (paramagpy.protein.CustomStructure method)@\spxentry{get\_level()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_level:paramagpy.protein.CustomStructure.get_level}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_level}}}{}{}
\sphinxAtStartPar
Return level in hierarchy.

\sphinxAtStartPar
A \sphinxhyphen{} atom
R \sphinxhyphen{} residue
C \sphinxhyphen{} chain
M \sphinxhyphen{} model
S \sphinxhyphen{} structure

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_list}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list:paramagpy-protein-customstructure-get-list}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list::doc}}\index{get\_list() (paramagpy.protein.CustomStructure method)@\spxentry{get\_list()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_list:paramagpy.protein.CustomStructure.get_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_list}}}{}{}
\sphinxAtStartPar
Return a copy of the list of children.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_models}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models:paramagpy-protein-customstructure-get-models}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models::doc}}\index{get\_models() (paramagpy.protein.CustomStructure method)@\spxentry{get\_models()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_models:paramagpy.protein.CustomStructure.get_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_models}}}{}{}
\sphinxAtStartPar
Return models.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent:paramagpy-protein-customstructure-get-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent::doc}}\index{get\_parent() (paramagpy.protein.CustomStructure method)@\spxentry{get\_parent()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_parent:paramagpy.protein.CustomStructure.get_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_parent}}}{}{}
\sphinxAtStartPar
Return the parent Entity object.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.get\_residues}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues:paramagpy-protein-customstructure-get-residues}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues::doc}}\index{get\_residues() (paramagpy.protein.CustomStructure method)@\spxentry{get\_residues()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.get_residues:paramagpy.protein.CustomStructure.get_residues}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{get\_residues}}}{}{}
\sphinxAtStartPar
Return residues from chains.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.has\_id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id:paramagpy-protein-customstructure-has-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id::doc}}\index{has\_id() (paramagpy.protein.CustomStructure method)@\spxentry{has\_id()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.has_id:paramagpy.protein.CustomStructure.has_id}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{has\_id}}}{\emph{\DUrole{n}{id}}}{}
\sphinxAtStartPar
Check if a child with given id exists.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.insert}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert:paramagpy-protein-customstructure-insert}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert::doc}}\index{insert() (paramagpy.protein.CustomStructure method)@\spxentry{insert()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.insert:paramagpy.protein.CustomStructure.insert}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{insert}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{entity}}}{}
\sphinxAtStartPar
Add a child to the Entity at a specified position.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.internal\_to\_atom\_coordinates}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.internal_to_atom_coordinates:paramagpy-protein-customstructure-internal-to-atom-coordinates}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.internal_to_atom_coordinates::doc}}\index{internal\_to\_atom\_coordinates() (paramagpy.protein.CustomStructure method)@\spxentry{internal\_to\_atom\_coordinates()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.internal_to_atom_coordinates:paramagpy.protein.CustomStructure.internal_to_atom_coordinates}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{internal\_to\_atom\_coordinates}}}{\emph{\DUrole{n}{verbose}\DUrole{p}{:} \DUrole{n}{bool} \DUrole{o}{=} \DUrole{default_value}{False}}}{{ $\rightarrow$ None}}
\sphinxAtStartPar
Create/update atom coordinates from internal coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bool}} (\sphinxstyleliteralemphasis{\sphinxupquote{verbose}}) \textendash{} default False
describe runtime problems

\item[{Raises}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{Exception}} \textendash{} if any chain does not have .pic attribute

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.parse}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy-protein-customstructure-parse}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse::doc}}\index{parse() (paramagpy.protein.CustomStructure method)@\spxentry{parse()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{parse}}}{\emph{\DUrole{n}{dataValues}}, \emph{\DUrole{n}{models}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Associate experimental data with atoms of the PDB file
This method takes a DataContainer instance from the
dataparse module
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataValues}} (\sphinxstyleliteralemphasis{\sphinxupquote{DataContainer instance}}) \textendash{} a dictionary containing the experimental values

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{dataArray} \textendash{} the returned array has a row for each relevant atom
in the PDB file. The columns contain model,
experimental/calculated data, errors and indexes.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
numpy structured array

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.set\_parent}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent:paramagpy-protein-customstructure-set-parent}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent::doc}}\index{set\_parent() (paramagpy.protein.CustomStructure method)@\spxentry{set\_parent()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.set_parent:paramagpy.protein.CustomStructure.set_parent}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{set\_parent}}}{\emph{\DUrole{n}{entity}}}{}
\sphinxAtStartPar
Set the parent Entity object.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructure.transform}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform:paramagpy-protein-customstructure-transform}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform::doc}}\index{transform() (paramagpy.protein.CustomStructure method)@\spxentry{transform()}\spxextra{paramagpy.protein.CustomStructure method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.transform:paramagpy.protein.CustomStructure.transform}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{transform}}}{\emph{\DUrole{n}{rot}}, \emph{\DUrole{n}{tran}}}{}
\sphinxAtStartPar
Apply rotation and translation to the atomic coordinates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rot}} (\sphinxstyleliteralemphasis{\sphinxupquote{3x3 Numeric array}}) \textendash{} A right multiplying rotation matrix

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{tran}} (\sphinxstyleliteralemphasis{\sphinxupquote{size 3 Numeric array}}) \textendash{} the translation vector

\end{itemize}

\end{description}\end{quote}
\subsubsection*{Examples}

\sphinxAtStartPar
This is an incomplete but illustrative example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{pi}\PYG{p}{,} \PYG{n}{array}
\PYG{k+kn}{from} \PYG{n+nn}{Bio}\PYG{n+nn}{.}\PYG{n+nn}{PDB}\PYG{n+nn}{.}\PYG{n+nn}{vectors} \PYG{k+kn}{import} \PYG{n}{Vector}\PYG{p}{,} \PYG{n}{rotmat}
\PYG{n}{rotation} \PYG{o}{=} \PYG{n}{rotmat}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{,} \PYG{n}{Vector}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{translation} \PYG{o}{=} \PYG{n}{array}\PYG{p}{(}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{entity}\PYG{o}{.}\PYG{n}{transform}\PYG{p}{(}\PYG{n}{rotation}\PYG{p}{,} \PYG{n}{translation}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.id:paramagpy.protein.CustomStructure.id}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{id}}}}}
&
\sphinxAtStartPar
Return identifier.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomStructure.id}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.id:paramagpy-protein-customstructure-id}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.id::doc}}\index{id (paramagpy.protein.CustomStructure property)@\spxentry{id}\spxextra{paramagpy.protein.CustomStructure property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructure.id:paramagpy.protein.CustomStructure.id}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxcode{\sphinxupquote{CustomStructure.}}\sphinxbfcode{\sphinxupquote{id}}}
\sphinxAtStartPar
Return identifier.

\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy-protein-customstructurebuilder}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder::doc}}\index{CustomStructureBuilder (class in paramagpy.protein)@\spxentry{CustomStructureBuilder}\spxextra{class in paramagpy.protein}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy.protein.CustomStructureBuilder}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{CustomStructureBuilder}}}{\emph{\DUrole{o}{*}\DUrole{n}{arg}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
This is an overload hack of BioPython’s CustomStructureBuilder
\index{\_\_init\_\_() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder:paramagpy.protein.CustomStructureBuilder.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{arg}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Initialize the class.
\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure:paramagpy.protein.CustomStructureBuilder.get_structure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get\_structure}}}}}()
&
\sphinxAtStartPar
Return the structure.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom:paramagpy.protein.CustomStructureBuilder.init_atom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_atom}}}}}(name, coord, b\_factor, occupancy, …)
&
\sphinxAtStartPar
Create a new Atom object.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain:paramagpy.protein.CustomStructureBuilder.init_chain}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_chain}}}}}(chain\_id)
&
\sphinxAtStartPar
Create a new Chain object with given id.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model:paramagpy.protein.CustomStructureBuilder.init_model}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_model}}}}}(model\_id{[}, serial\_num{]})
&
\sphinxAtStartPar
Create a new Model object with given id.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue:paramagpy.protein.CustomStructureBuilder.init_residue}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_residue}}}}}(resname, field, resseq, icode)
&
\sphinxAtStartPar
Create a new Residue object.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg:paramagpy.protein.CustomStructureBuilder.init_seg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_seg}}}}}(segid)
&
\sphinxAtStartPar
Flag a change in segid.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure:paramagpy.protein.CustomStructureBuilder.init_structure}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{init\_structure}}}}}(structure\_id)
&
\sphinxAtStartPar
Initialize a new Structure object with given id.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou:paramagpy.protein.CustomStructureBuilder.set_anisou}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_anisou}}}}}(anisou\_array)
&
\sphinxAtStartPar
Set anisotropic B factor of current Atom.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header:paramagpy.protein.CustomStructureBuilder.set_header}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_header}}}}}(header)
&
\sphinxAtStartPar
Set header.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter:paramagpy.protein.CustomStructureBuilder.set_line_counter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_line\_counter}}}}}(line\_counter)
&
\sphinxAtStartPar
Tracks line in the PDB file that is being parsed.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm:paramagpy.protein.CustomStructureBuilder.set_sigatm}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_sigatm}}}}}(sigatm\_array)
&
\sphinxAtStartPar
Set standard deviation of atom position of current Atom.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij:paramagpy.protein.CustomStructureBuilder.set_siguij}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_siguij}}}}}(siguij\_array)
&
\sphinxAtStartPar
Set standard deviation of anisotropic B factor of current Atom.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry:paramagpy.protein.CustomStructureBuilder.set_symmetry}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{set\_symmetry}}}}}(spacegroup, cell)
&
\sphinxAtStartPar
Set symmetry.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.CustomStructureBuilder.get\_structure}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure:paramagpy-protein-customstructurebuilder-get-structure}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure::doc}}\index{get\_structure() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{get\_structure()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.get_structure:paramagpy.protein.CustomStructureBuilder.get_structure}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{get\_structure}}}{}{}
\sphinxAtStartPar
Return the structure.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_atom}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom:paramagpy-protein-customstructurebuilder-init-atom}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom::doc}}\index{init\_atom() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{init\_atom()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_atom:paramagpy.protein.CustomStructureBuilder.init_atom}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_atom}}}{\emph{\DUrole{n}{name}}, \emph{\DUrole{n}{coord}}, \emph{\DUrole{n}{b\_factor}}, \emph{\DUrole{n}{occupancy}}, \emph{\DUrole{n}{altloc}}, \emph{\DUrole{n}{fullname}}, \emph{\DUrole{n}{serial\_number}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{element}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Create a new Atom object.
:param \sphinxhyphen{} name \sphinxhyphen{} string, atom name, e.g. CA, spaces should be stripped:
:param \sphinxhyphen{} coord \sphinxhyphen{} Numeric array:
:type \sphinxhyphen{} coord \sphinxhyphen{} Numeric array: Float0, size 3
:param \sphinxhyphen{} b\_factor \sphinxhyphen{} float, B factor:
:param \sphinxhyphen{} occupancy \sphinxhyphen{} float:
:param \sphinxhyphen{} altloc \sphinxhyphen{} string, alternative location specifier:
:param \sphinxhyphen{} fullname \sphinxhyphen{} string, atom name including spaces, e.g. ” CA “:
:param \sphinxhyphen{} element \sphinxhyphen{} string, upper case, e.g. “HG” for mercury:

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_chain}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain:paramagpy-protein-customstructurebuilder-init-chain}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain::doc}}\index{init\_chain() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{init\_chain()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_chain:paramagpy.protein.CustomStructureBuilder.init_chain}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_chain}}}{\emph{\DUrole{n}{chain\_id}}}{}
\sphinxAtStartPar
Create a new Chain object with given id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{string}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} chain\_id \sphinxhyphen{}}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_model}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model:paramagpy-protein-customstructurebuilder-init-model}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model::doc}}\index{init\_model() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{init\_model()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_model:paramagpy.protein.CustomStructureBuilder.init_model}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_model}}}{\emph{\DUrole{n}{model\_id}}, \emph{\DUrole{n}{serial\_num}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Create a new Model object with given id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{int}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} serial\_num \sphinxhyphen{}}}) \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{int}} \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_residue}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue:paramagpy-protein-customstructurebuilder-init-residue}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue::doc}}\index{init\_residue() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{init\_residue()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_residue:paramagpy.protein.CustomStructureBuilder.init_residue}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_residue}}}{\emph{\DUrole{n}{resname}}, \emph{\DUrole{n}{field}}, \emph{\DUrole{n}{resseq}}, \emph{\DUrole{n}{icode}}}{}
\sphinxAtStartPar
Create a new Residue object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{"ASN"}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} resname \sphinxhyphen{} string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{e.g.}}) \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{for}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} field \sphinxhyphen{} hetero flag}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"W" for waters}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{"H"}}) \textendash{} hetero residues, otherwise blank.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} resseq \sphinxhyphen{} int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{sequence}}) \textendash{} 

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{code}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} icode \sphinxhyphen{} string}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{insertion}}) \textendash{} 

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_seg}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg:paramagpy-protein-customstructurebuilder-init-seg}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg::doc}}\index{init\_seg() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{init\_seg()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_seg:paramagpy.protein.CustomStructureBuilder.init_seg}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_seg}}}{\emph{\DUrole{n}{segid}}}{}
\sphinxAtStartPar
Flag a change in segid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{string}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} segid \sphinxhyphen{}}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.init\_structure}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure:paramagpy-protein-customstructurebuilder-init-structure}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure::doc}}\index{init\_structure() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{init\_structure()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.init_structure:paramagpy.protein.CustomStructureBuilder.init_structure}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{init\_structure}}}{\emph{\DUrole{n}{structure\_id}}}{}
\sphinxAtStartPar
Initialize a new Structure object with given id.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{string}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} id \sphinxhyphen{}}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_anisou}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou:paramagpy-protein-customstructurebuilder-set-anisou}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou::doc}}\index{set\_anisou() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{set\_anisou()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_anisou:paramagpy.protein.CustomStructureBuilder.set_anisou}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_anisou}}}{\emph{\DUrole{n}{anisou\_array}}}{}
\sphinxAtStartPar
Set anisotropic B factor of current Atom.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_header}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header:paramagpy-protein-customstructurebuilder-set-header}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header::doc}}\index{set\_header() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{set\_header()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_header:paramagpy.protein.CustomStructureBuilder.set_header}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_header}}}{\emph{\DUrole{n}{header}}}{}
\sphinxAtStartPar
Set header.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_line\_counter}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter:paramagpy-protein-customstructurebuilder-set-line-counter}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter::doc}}\index{set\_line\_counter() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{set\_line\_counter()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_line_counter:paramagpy.protein.CustomStructureBuilder.set_line_counter}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_line\_counter}}}{\emph{\DUrole{n}{line\_counter}}}{}
\sphinxAtStartPar
Tracks line in the PDB file that is being parsed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{int}} (\sphinxstyleliteralemphasis{\sphinxupquote{\sphinxhyphen{} line\_counter \sphinxhyphen{}}}) \textendash{} 

\end{description}\end{quote}

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_sigatm}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm:paramagpy-protein-customstructurebuilder-set-sigatm}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm::doc}}\index{set\_sigatm() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{set\_sigatm()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_sigatm:paramagpy.protein.CustomStructureBuilder.set_sigatm}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_sigatm}}}{\emph{\DUrole{n}{sigatm\_array}}}{}
\sphinxAtStartPar
Set standard deviation of atom position of current Atom.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_siguij}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij:paramagpy-protein-customstructurebuilder-set-siguij}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij::doc}}\index{set\_siguij() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{set\_siguij()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_siguij:paramagpy.protein.CustomStructureBuilder.set_siguij}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_siguij}}}{\emph{\DUrole{n}{siguij\_array}}}{}
\sphinxAtStartPar
Set standard deviation of anisotropic B factor of current Atom.

\end{fulllineitems}



\subparagraph{paramagpy.protein.CustomStructureBuilder.set\_symmetry}
\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry:paramagpy-protein-customstructurebuilder-set-symmetry}}\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry::doc}}\index{set\_symmetry() (paramagpy.protein.CustomStructureBuilder method)@\spxentry{set\_symmetry()}\spxextra{paramagpy.protein.CustomStructureBuilder method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.CustomStructureBuilder.set_symmetry:paramagpy.protein.CustomStructureBuilder.set_symmetry}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{CustomStructureBuilder.}}\sphinxbfcode{\sphinxupquote{set\_symmetry}}}{\emph{\DUrole{n}{spacegroup}}, \emph{\DUrole{n}{cell}}}{}
\sphinxAtStartPar
Set symmetry.

\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subparagraph{paramagpy.protein.PyMolScript}
\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript:paramagpy-protein-pymolscript}}\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript::doc}}\index{PyMolScript (class in paramagpy.protein)@\spxentry{PyMolScript}\spxextra{class in paramagpy.protein}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript:paramagpy.protein.PyMolScript}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.protein.}}\sphinxbfcode{\sphinxupquote{PyMolScript}}}
\sphinxAtStartPar
A PyMol helper class for constructing a PyMol script
that will load PDB files and density map files
\index{\_\_init\_\_() (paramagpy.protein.PyMolScript method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.protein.PyMolScript method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript:paramagpy.protein.PyMolScript.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{}{}~\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_atom:paramagpy.protein.PyMolScript.add_atom}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_atom}}}}}(position, name{[}, colour, size, label{]})
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_map:paramagpy.protein.PyMolScript.add_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_map}}}}}(path, name, isoVals, colours{[}, …{]})
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_pdb:paramagpy.protein.PyMolScript.add_pdb}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{add\_pdb}}}}}(path{[}, name, showAs{]})
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.protein.PyMolScript.write:paramagpy.protein.PyMolScript.write}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{write}}}}}(fileName)
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.protein.PyMolScript.add\_atom}
\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_atom:paramagpy-protein-pymolscript-add-atom}}\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_atom::doc}}\index{add\_atom() (paramagpy.protein.PyMolScript method)@\spxentry{add\_atom()}\spxextra{paramagpy.protein.PyMolScript method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_atom:paramagpy.protein.PyMolScript.add_atom}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{PyMolScript.}}\sphinxbfcode{\sphinxupquote{add\_atom}}}{\emph{\DUrole{n}{position}}, \emph{\DUrole{n}{name}}, \emph{\DUrole{n}{colour}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pink\textquotesingle{}}}, \emph{\DUrole{n}{size}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{label}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.PyMolScript.add\_map}
\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_map:paramagpy-protein-pymolscript-add-map}}\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_map::doc}}\index{add\_map() (paramagpy.protein.PyMolScript method)@\spxentry{add\_map()}\spxextra{paramagpy.protein.PyMolScript method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_map:paramagpy.protein.PyMolScript.add_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{PyMolScript.}}\sphinxbfcode{\sphinxupquote{add\_map}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{name}}, \emph{\DUrole{n}{isoVals}}, \emph{\DUrole{n}{colours}}, \emph{\DUrole{n}{surfaceType}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}isosurface\textquotesingle{}}}, \emph{\DUrole{n}{transparency}\DUrole{o}{=}\DUrole{default_value}{0.5}}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.PyMolScript.add\_pdb}
\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_pdb:paramagpy-protein-pymolscript-add-pdb}}\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_pdb::doc}}\index{add\_pdb() (paramagpy.protein.PyMolScript method)@\spxentry{add\_pdb()}\spxextra{paramagpy.protein.PyMolScript method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.add_pdb:paramagpy.protein.PyMolScript.add_pdb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{PyMolScript.}}\sphinxbfcode{\sphinxupquote{add\_pdb}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{name}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{showAs}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}cartoon\textquotesingle{}}}}{}
\end{fulllineitems}



\subparagraph{paramagpy.protein.PyMolScript.write}
\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.write:paramagpy-protein-pymolscript-write}}\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.write::doc}}\index{write() (paramagpy.protein.PyMolScript method)@\spxentry{write()}\spxextra{paramagpy.protein.PyMolScript method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.protein.PyMolScript.write:paramagpy.protein.PyMolScript.write}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{PyMolScript.}}\sphinxbfcode{\sphinxupquote{write}}}{\emph{\DUrole{n}{fileName}}}{}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Data I/O module}
\label{\detokenize{reference/index:data-i-o-module}}
\sphinxAtStartPar
This module handles the reading and writing of experimental data.


\subsubsection{paramagpy.dataparse}
\label{\detokenize{reference/dataparse:module-paramagpy.dataparse}}\label{\detokenize{reference/dataparse:paramagpy-dataparse}}\label{\detokenize{reference/dataparse:dataparse}}\label{\detokenize{reference/dataparse::doc}}\index{module@\spxentry{module}!paramagpy.dataparse@\spxentry{paramagpy.dataparse}}\index{paramagpy.dataparse@\spxentry{paramagpy.dataparse}!module@\spxentry{module}}

\paragraph{Functions}
\label{\detokenize{reference/dataparse:functions}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_pcs}}}}}(fileName)
&
\sphinxAtStartPar
Read pseudo contact shift values from file.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy.dataparse.read_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_rdc}}}}}(fileName)
&
\sphinxAtStartPar
Read residual dipolar coupling values from file.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pre:paramagpy.dataparse.read_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_pre}}}}}(fileName)
&
\sphinxAtStartPar
Read paramagnetic relaxation enhancement values from file.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_ccr:paramagpy.dataparse.read_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{read\_ccr}}}}}(fileName)
&
\sphinxAtStartPar
Read cross\sphinxhyphen{}correlated relaxation values from file.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.dataparse.read\_pcs}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy-dataparse-read-pcs}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_pcs::doc}}\index{read\_pcs() (in module paramagpy.dataparse)@\spxentry{read\_pcs()}\spxextra{in module paramagpy.dataparse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_pcs}}}{\emph{\DUrole{n}{fileName}}}{}
\sphinxAtStartPar
Read pseudo contact shift values from file.
The returned object is a dicationary.
They keys are tuples of (sequence, atomName)
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{paramagpy}\PYG{o}{.}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}pcs}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{calbindin\PYGZus{}Er\PYGZus{}HN\PYGZus{}PCS\PYGZus{}errors.npc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{values}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{((2, \PYGZsq{}H\PYGZsq{}), (\PYGZhy{}0.04855485, 0.0016))}
\PYG{g+go}{((2, \PYGZsq{}N\PYGZsq{}), (\PYGZhy{}0.03402764, 0.0009))}
\PYG{g+go}{((4, \PYGZsq{}H\PYGZsq{}), (\PYGZhy{}0.18470315, 0.0004))}
\PYG{g+gp}{...}
\PYG{g+go}{((75, \PYGZsq{}H\PYGZsq{}), (0.19553661, 0.0005))}
\PYG{g+go}{((75, \PYGZsq{}N\PYGZsq{}), (0.17840666, 0.0004))}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.read\_rdc}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy-dataparse-read-rdc}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_rdc::doc}}\index{read\_rdc() (in module paramagpy.dataparse)@\spxentry{read\_rdc()}\spxextra{in module paramagpy.dataparse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy.dataparse.read_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_rdc}}}{\emph{\DUrole{n}{fileName}}}{}
\sphinxAtStartPar
Read residual dipolar coupling values from file.
The returned object is a dicationary.
They keys are frozensets of tuples of the form:
frozenset(\{(sequence1, atomName1), (sequence2, atomName2)\})
The frozenset only allows unordered unique atom identification pairs
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{values} \PYG{o}{=} \PYG{n}{paramagpy}\PYG{o}{.}\PYG{n}{dataparse}\PYG{o}{.}\PYG{n}{read\PYGZus{}rdc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ubiquitin\PYGZus{}a28c\PYGZus{}c1\PYGZus{}Tb\PYGZus{}HN.rdc}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{values}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
\PYG{g+gp}{... }    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{v}\PYG{p}{)}
\PYG{g+gp}{...}
\PYG{g+go}{(frozenset(\PYGZob{}(2, \PYGZsq{}N\PYGZsq{}), (2, \PYGZsq{}H\PYGZsq{})\PYGZcb{}), (\PYGZhy{}2.35, 0.32))}
\PYG{g+go}{(frozenset(\PYGZob{}(3, \PYGZsq{}N\PYGZsq{}), (3, \PYGZsq{}H\PYGZsq{})\PYGZcb{}), (\PYGZhy{}4.05, 0.38))}
\PYG{g+go}{(frozenset(\PYGZob{}(4, \PYGZsq{}H\PYGZsq{}), (4, \PYGZsq{}N\PYGZsq{})\PYGZcb{}), (\PYGZhy{}3.58, 0.42))}
\PYG{g+gp}{...}
\PYG{g+go}{(frozenset(\PYGZob{}(73, \PYGZsq{}N\PYGZsq{}), (73, \PYGZsq{}H\PYGZsq{})\PYGZcb{}), (\PYGZhy{}0.47, 0.75))}
\PYG{g+go}{(frozenset(\PYGZob{}(76, \PYGZsq{}H\PYGZsq{}), (76, \PYGZsq{}N\PYGZsq{})\PYGZcb{}), (0.14, 0.3))}
\end{sphinxVerbatim}

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.read\_pre}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_pre:paramagpy-dataparse-read-pre}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_pre::doc}}\index{read\_pre() (in module paramagpy.dataparse)@\spxentry{read\_pre()}\spxextra{in module paramagpy.dataparse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_pre:paramagpy.dataparse.read_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_pre}}}{\emph{\DUrole{n}{fileName}}}{}
\sphinxAtStartPar
Read paramagnetic relaxation enhancement values from file.
The returned object is a dicationary.
They keys are tuples of (sequence, atomName)
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

\sphinxAtStartPar
see {\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_pcs:paramagpy.dataparse.read_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.read\_pcs()}}}}} which has the same file structure

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.read\_ccr}
\label{\detokenize{reference/generated/paramagpy.dataparse.read_ccr:paramagpy-dataparse-read-ccr}}\label{\detokenize{reference/generated/paramagpy.dataparse.read_ccr::doc}}\index{read\_ccr() (in module paramagpy.dataparse)@\spxentry{read\_ccr()}\spxextra{in module paramagpy.dataparse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.read_ccr:paramagpy.dataparse.read_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{read\_ccr}}}{\emph{\DUrole{n}{fileName}}}{}
\sphinxAtStartPar
Read cross\sphinxhyphen{}correlated relaxation values from file.
These are typically Curie\sphinxhyphen{}spin cross Dipole\sphinxhyphen{}dipole relaxation rates
The returned object is a dicationary.
They keys are tuples of the form:
((sequence1, atomName1), (sequence2, atomName2))
Note that the first column is for the active nucleus undergoing
relaxation and the second column is for the partner spin.
The values are tuples of (value, error)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fileName}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} the path to the file

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{values} \textendash{} a dictionary containing the parsed data

\item[{Return type}] \leavevmode
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.DataContainer}}}}}

\end{description}\end{quote}
\subsubsection*{Examples}

\sphinxAtStartPar
see {\hyperref[\detokenize{reference/generated/paramagpy.dataparse.read_rdc:paramagpy.dataparse.read_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.dataparse.read\_rdc()}}}}} which has the similar file structure

\end{fulllineitems}



\paragraph{Classes}
\label{\detokenize{reference/dataparse:classes}}

\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DataContainer}}}}}(*args, **kwargs)
&
\sphinxAtStartPar
A dictionary\sphinxhyphen{}like container for storing PCS, RDC, PRE and CCR data Has an additional attribute ‘dtype’ to define datatype
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.dataparse.DataContainer}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy-dataparse-datacontainer}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer::doc}}\index{DataContainer (class in paramagpy.dataparse)@\spxentry{DataContainer}\spxextra{class in paramagpy.dataparse}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.dataparse.}}\sphinxbfcode{\sphinxupquote{DataContainer}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
A dictionary\sphinxhyphen{}like container for storing
PCS, RDC, PRE and CCR data
Has an additional attribute ‘dtype’ to define datatype
\index{\_\_init\_\_() (paramagpy.dataparse.DataContainer method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer:paramagpy.dataparse.DataContainer.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{o}{*}\DUrole{n}{args}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}~\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear:paramagpy.dataparse.DataContainer.clear}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{clear}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy:paramagpy.dataparse.DataContainer.copy}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{copy}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys:paramagpy.dataparse.DataContainer.fromkeys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fromkeys}}}}}({[}value{]})
&
\sphinxAtStartPar
Create a new ordered dictionary with keys from iterable and values set to value.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get:paramagpy.dataparse.DataContainer.get}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{get}}}}}(key{[}, default{]})
&
\sphinxAtStartPar
Return the value for key if key is in the dictionary, else default.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items:paramagpy.dataparse.DataContainer.items}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{items}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys:paramagpy.dataparse.DataContainer.keys}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{keys}}}}}()
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end:paramagpy.dataparse.DataContainer.move_to_end}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{move\_to\_end}}}}}(key{[}, last{]})
&
\sphinxAtStartPar
Move an existing element to the end (or beginning if last is false).
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop:paramagpy.dataparse.DataContainer.pop}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pop}}}}}(k{[},d{]})
&
\sphinxAtStartPar
value.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem:paramagpy.dataparse.DataContainer.popitem}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{popitem}}}}}({[}last{]})
&
\sphinxAtStartPar
Remove and return a (key, value) pair from the dictionary.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault:paramagpy.dataparse.DataContainer.setdefault}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{setdefault}}}}}(key{[}, default{]})
&
\sphinxAtStartPar
Insert key with a value of default if key is not in the dictionary.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update:paramagpy.dataparse.DataContainer.update}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{update}}}}}({[}E, {]}**F)
&
\sphinxAtStartPar
If E is present and has a .keys() method, then does:  for k in E: D{[}k{]} = E{[}k{]} If E is present and lacks a .keys() method, then does:  for k, v in E: D{[}k{]} = v In either case, this is followed by: for k in F:  D{[}k{]} = F{[}k{]}
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values:paramagpy.dataparse.DataContainer.values}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{values}}}}}()
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subparagraph{paramagpy.dataparse.DataContainer.clear}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear:paramagpy-dataparse-datacontainer-clear}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear::doc}}\index{clear() (paramagpy.dataparse.DataContainer method)@\spxentry{clear()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.clear:paramagpy.dataparse.DataContainer.clear}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{clear}}}{}{{ $\rightarrow$ None.  Remove all items from od.}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.copy}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy:paramagpy-dataparse-datacontainer-copy}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy::doc}}\index{copy() (paramagpy.dataparse.DataContainer method)@\spxentry{copy()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.copy:paramagpy.dataparse.DataContainer.copy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{copy}}}{}{{ $\rightarrow$ a shallow copy of od}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.fromkeys}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys:paramagpy-dataparse-datacontainer-fromkeys}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys::doc}}\index{fromkeys() (paramagpy.dataparse.DataContainer method)@\spxentry{fromkeys()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.fromkeys:paramagpy.dataparse.DataContainer.fromkeys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{fromkeys}}}{\emph{\DUrole{n}{value}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Create a new ordered dictionary with keys from iterable and values set to value.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.get}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get:paramagpy-dataparse-datacontainer-get}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get::doc}}\index{get() (paramagpy.dataparse.DataContainer method)@\spxentry{get()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.get:paramagpy.dataparse.DataContainer.get}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{get}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{o}{/}}}{}
\sphinxAtStartPar
Return the value for key if key is in the dictionary, else default.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.items}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items:paramagpy-dataparse-datacontainer-items}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items::doc}}\index{items() (paramagpy.dataparse.DataContainer method)@\spxentry{items()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.items:paramagpy.dataparse.DataContainer.items}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{items}}}{}{{ $\rightarrow$ a set\sphinxhyphen{}like object providing a view on D’s items}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.keys}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys:paramagpy-dataparse-datacontainer-keys}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys::doc}}\index{keys() (paramagpy.dataparse.DataContainer method)@\spxentry{keys()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.keys:paramagpy.dataparse.DataContainer.keys}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{keys}}}{}{{ $\rightarrow$ a set\sphinxhyphen{}like object providing a view on D’s keys}}
\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.move\_to\_end}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end:paramagpy-dataparse-datacontainer-move-to-end}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end::doc}}\index{move\_to\_end() (paramagpy.dataparse.DataContainer method)@\spxentry{move\_to\_end()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.move_to_end:paramagpy.dataparse.DataContainer.move_to_end}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{move\_to\_end}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{last}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Move an existing element to the end (or beginning if last is false).

\sphinxAtStartPar
Raise KeyError if the element does not exist.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.pop}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop:paramagpy-dataparse-datacontainer-pop}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop::doc}}\index{pop() (paramagpy.dataparse.DataContainer method)@\spxentry{pop()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.pop:paramagpy.dataparse.DataContainer.pop}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{pop}}}{\emph{k}\sphinxoptional{, \emph{d}}}{{ $\rightarrow$ v, remove specified key and return the corresponding}}
\sphinxAtStartPar
value.  If key is not found, d is returned if given, otherwise KeyError
is raised.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.popitem}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem:paramagpy-dataparse-datacontainer-popitem}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem::doc}}\index{popitem() (paramagpy.dataparse.DataContainer method)@\spxentry{popitem()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.popitem:paramagpy.dataparse.DataContainer.popitem}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{popitem}}}{\emph{\DUrole{n}{last}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Remove and return a (key, value) pair from the dictionary.

\sphinxAtStartPar
Pairs are returned in LIFO order if last is true or FIFO order if false.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.setdefault}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault:paramagpy-dataparse-datacontainer-setdefault}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault::doc}}\index{setdefault() (paramagpy.dataparse.DataContainer method)@\spxentry{setdefault()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.setdefault:paramagpy.dataparse.DataContainer.setdefault}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{setdefault}}}{\emph{\DUrole{n}{key}}, \emph{\DUrole{n}{default}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Insert key with a value of default if key is not in the dictionary.

\sphinxAtStartPar
Return the value for key if key is in the dictionary, else default.

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.update}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update:paramagpy-dataparse-datacontainer-update}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update::doc}}\index{update() (paramagpy.dataparse.DataContainer method)@\spxentry{update()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.update:paramagpy.dataparse.DataContainer.update}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{update}}}{\sphinxoptional{\emph{E}}, \emph{**F}}{{ $\rightarrow$ None.  Update D from dict/iterable E and F.}}
\sphinxAtStartPar
If E is present and has a .keys() method, then does:  for k in E: D{[}k{]} = E{[}k{]}
If E is present and lacks a .keys() method, then does:  for k, v in E: D{[}k{]} = v
In either case, this is followed by: for k in F:  D{[}k{]} = F{[}k{]}

\end{fulllineitems}



\subparagraph{paramagpy.dataparse.DataContainer.values}
\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values:paramagpy-dataparse-datacontainer-values}}\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values::doc}}\index{values() (paramagpy.dataparse.DataContainer method)@\spxentry{values()}\spxextra{paramagpy.dataparse.DataContainer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.dataparse.DataContainer.values:paramagpy.dataparse.DataContainer.values}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DataContainer.}}\sphinxbfcode{\sphinxupquote{values}}}{}{{ $\rightarrow$ an object providing a view on D’s values}}
\end{fulllineitems}


\end{fulllineitems}


\end{fulllineitems}



\subsection{Fitting module}
\label{\detokenize{reference/index:fitting-module}}
\sphinxAtStartPar
This module handles the fitting of paramagnetic objects to experimental data.


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit:module-paramagpy.fit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit}}}}}
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\subsubsection{paramagpy.fit}
\label{\detokenize{reference/generated/paramagpy.fit:module-paramagpy.fit}}\label{\detokenize{reference/generated/paramagpy.fit:paramagpy-fit}}\label{\detokenize{reference/generated/paramagpy.fit::doc}}\index{module@\spxentry{module}!paramagpy.fit@\spxentry{paramagpy.fit}}\index{paramagpy.fit@\spxentry{paramagpy.fit}!module@\spxentry{module}}\subsubsection*{Functions}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy.fit.ensemble_average}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ensemble\_average}}}}}(dataArray)
&
\sphinxAtStartPar
Calculate the ensemble average for the calculated values in the column ‘cal’ of the argument \textless{}dataArray\textgreater{} over models of the PDB file.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_atom_data:paramagpy.fit.extract_atom_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_atom\_data}}}}}(data{[}, csa, separateModels{]})
&
\sphinxAtStartPar
Extract values required for PCS/PRE calculations
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_ccr_data:paramagpy.fit.extract_ccr_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_ccr\_data}}}}}(data{[}, separateModels{]})
&
\sphinxAtStartPar
Extract values required for CCR calculations
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.extract_rdc_data:paramagpy.fit.extract_rdc_data}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{extract\_rdc\_data}}}}}(data{[}, separateModels{]})
&
\sphinxAtStartPar
Extract values required for RDC calculations
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.fit_error_bootstrap:paramagpy.fit.fit_error_bootstrap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fit\_error\_bootstrap}}}}}(fittingFunction, …)
&
\sphinxAtStartPar
Perform uncertainty analysis sourcing noise from fractioning the experimental data.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.fit_error_models:paramagpy.fit.fit_error_models}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fit\_error\_models}}}}}(fittingFunction, **kwargs)
&
\sphinxAtStartPar
Perform uncertainty analysis sourcing noise from cooridinates as defined by models of the PDB structure.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.fit_error_monte_carlo:paramagpy.fit.fit_error_monte_carlo}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{fit\_error\_monte\_carlo}}}}}(fittingFunction, …)
&
\sphinxAtStartPar
Perform uncertainty analysis sourcing noise from experimental uncertainties This function takes a fitting routine \textless{}fittingFunction\textgreater{} and repeats it for the specified iterations in a Monte\sphinxhyphen{}Carlo approach.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_from_pcs:paramagpy.fit.gridsearch_fit_atom_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gridsearch\_fit\_atom\_from\_pcs}}}}}(metals, dataArrays)
&
\sphinxAtStartPar
Calculate likely regions for an atom on a grid using an experimental PCS value and multiple delta\sphinxhyphen{}chi\sphinxhyphen{}tensors.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance:paramagpy.fit.gridsearch_fit_atom_restrain_distance}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gridsearch\_fit\_atom\_restrain\_distance}}}}}(…)
&
\sphinxAtStartPar
Given two RMSD density maps, this function will compare all points pairwise and return only those within the bounds of a given distance cutoff and within a certain number of points that are that are sorted by RMSD value.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance_cutoff:paramagpy.fit.gridsearch_fit_atom_restrain_distance_cutoff}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{gridsearch\_fit\_atom\_restrain\_distance\_cutoff}}}}}(…)
&
\sphinxAtStartPar
Given two RMSD density maps, this function will compare all points pairwise and return only those within the bounds of a given distance cutoff and within a given RMSD cutoff.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.metal_standard_deviation:paramagpy.fit.metal_standard_deviation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{metal\_standard\_deviation}}}}}(metals, params)
&
\sphinxAtStartPar
Calculate the standard deviation in parameters \textless{}params\textgreater{} for a list of metal objects \textless{}metals\textgreater{}.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr:paramagpy.fit.nlr_fit_metal_from_ccr}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_ccr}}}}}(initMetals, dataArrays)
&
\sphinxAtStartPar
Fit Chi tensor to CCR values using non\sphinxhyphen{}linear regression.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_pcs}}}}}(initMetals, dataArrays)
&
\sphinxAtStartPar
Fit deltaChi tensor to PCS values using non\sphinxhyphen{}linear regression.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy.fit.nlr_fit_metal_from_pre}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nlr\_fit\_metal\_from\_pre}}}}}(initMetals, …{[}, …{]})
&
\sphinxAtStartPar
Fit Chi tensor to PRE values using non\sphinxhyphen{}linear regression.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_cross:paramagpy.fit.pcs_gradient_orthogonality_cross}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_gradient\_orthogonality\_cross}}}}}(metals, …)
&
\sphinxAtStartPar
An experimental metric for calculating the likelihood of a particular nuclear position being well localised from multiple tensors.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_dot:paramagpy.fit.pcs_gradient_orthogonality_dot}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pcs\_gradient\_orthogonality\_dot}}}}}(metals, position)
&
\sphinxAtStartPar
An experimental metric for calculating the likelihood of a particular nuclear position being well localised from multiple tensors.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.qfactor:paramagpy.fit.qfactor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{qfactor}}}}}(dataArray{[}, ensembleAverage, …{]})
&
\sphinxAtStartPar
Calculate the Q\sphinxhyphen{}factor to judge tensor fit quality
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.sphere_grid:paramagpy.fit.sphere_grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{sphere\_grid}}}}}(origin, radius, points)
&
\sphinxAtStartPar
Make a grid of cartesian points within a sphere
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs:paramagpy.fit.svd_calc_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs}}}}}(pos, pcs, idx, errors)
&
\sphinxAtStartPar
Solve PCS equation by single value decomposition.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset:paramagpy.fit.svd_calc_metal_from_pcs_offset}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs\_offset}}}}}(pos, pcs, …)
&
\sphinxAtStartPar
Solve PCS equation by single value decomposition with offset.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc:paramagpy.fit.svd_calc_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_calc\_metal\_from\_rdc}}}}}(vec, …)
&
\sphinxAtStartPar
Solve RDC equation by single value decomposition.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy.fit.svd_fit_metal_from_rdc}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_fit\_metal\_from\_rdc}}}}}(initMetals, dataArrays)
&
\sphinxAtStartPar
Fit deltaChi tensor to RDC values using Single Value Decomposition.
\\
\hline
\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{svd\_gridsearch\_fit\_metal\_from\_pcs}}}}}(…{[}, …{]})
&
\sphinxAtStartPar
Fit deltaChi tensor to PCS values using Single Value Decomposition over a grid of points in a sphere.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{paramagpy.fit.ensemble\_average}
\label{\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy-fit-ensemble-average}}\label{\detokenize{reference/generated/paramagpy.fit.ensemble_average::doc}}\index{ensemble\_average() (in module paramagpy.fit)@\spxentry{ensemble\_average()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.ensemble_average:paramagpy.fit.ensemble_average}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{ensemble\_average}}}{\emph{\DUrole{n}{dataArray}}}{}
\sphinxAtStartPar
Calculate the ensemble average for the calculated values in the
column ‘cal’ of the argument \textless{}dataArray\textgreater{} over models of the
PDB file.
Ensemble averaging behaviour is determined by the column ‘idx’
of the input array.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArray}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}) \textendash{} the input array for ensemble averaging

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{data} \textendash{} a smaller dataArray with ensemble averaged values

\item[{Return type}] \leavevmode
\sphinxAtStartPar
numpy array

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_atom\_data}
\label{\detokenize{reference/generated/paramagpy.fit.extract_atom_data:paramagpy-fit-extract-atom-data}}\label{\detokenize{reference/generated/paramagpy.fit.extract_atom_data::doc}}\index{extract\_atom\_data() (in module paramagpy.fit)@\spxentry{extract\_atom\_data()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_atom_data:paramagpy.fit.extract_atom_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_atom\_data}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{csa}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{separateModels}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Extract values required for PCS/PRE calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} a numpy structured array containing atomic information
and experimental data values
This is returned from.
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{csa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when True, calculates the CSA tensor for each atom
this may be required for RACS and CSAxDSA calculations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{separateModels}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when True, separates data into separate lists
by their model number. When False, returns only one list

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{arr} \textendash{} this has fields specified by structdtype
this array is core to all fitting algorithms

\item[{Return type}] \leavevmode
\sphinxAtStartPar
numpy.ndarra

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_ccr\_data}
\label{\detokenize{reference/generated/paramagpy.fit.extract_ccr_data:paramagpy-fit-extract-ccr-data}}\label{\detokenize{reference/generated/paramagpy.fit.extract_ccr_data::doc}}\index{extract\_ccr\_data() (in module paramagpy.fit)@\spxentry{extract\_ccr\_data()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_ccr_data:paramagpy.fit.extract_ccr_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_ccr\_data}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{separateModels}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Extract values required for CCR calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} a numpy structured array containing atomic information
and experimental data values
This is returned from
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{separateModels}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when True, separates data into separate lists
by their model number. When False, returns only one list

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{arr} \textendash{} this has fields specified by structdtype
this array is core to all fitting algorithms

\item[{Return type}] \leavevmode
\sphinxAtStartPar
numpy.ndarra

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.extract\_rdc\_data}
\label{\detokenize{reference/generated/paramagpy.fit.extract_rdc_data:paramagpy-fit-extract-rdc-data}}\label{\detokenize{reference/generated/paramagpy.fit.extract_rdc_data::doc}}\index{extract\_rdc\_data() (in module paramagpy.fit)@\spxentry{extract\_rdc\_data()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.extract_rdc_data:paramagpy.fit.extract_rdc_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{extract\_rdc\_data}}}{\emph{\DUrole{n}{data}}, \emph{\DUrole{n}{separateModels}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
\sphinxAtStartPar
Extract values required for RDC calculations
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{data}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray}}) \textendash{} a numpy structured array containing atomic information
and experimental data values
This is returned from
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{separateModels}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when True, separates data into separate lists
by their model number. When False, returns only one list

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{arr} \textendash{} this has fields specified by structdtype
this array is core to all fitting algorithms

\item[{Return type}] \leavevmode
\sphinxAtStartPar
numpy.ndarra

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.fit\_error\_bootstrap}
\label{\detokenize{reference/generated/paramagpy.fit.fit_error_bootstrap:paramagpy-fit-fit-error-bootstrap}}\label{\detokenize{reference/generated/paramagpy.fit.fit_error_bootstrap::doc}}\index{fit\_error\_bootstrap() (in module paramagpy.fit)@\spxentry{fit\_error\_bootstrap()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.fit_error_bootstrap:paramagpy.fit.fit_error_bootstrap}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{fit\_error\_bootstrap}}}{\emph{\DUrole{n}{fittingFunction}}, \emph{\DUrole{n}{iterations}}, \emph{\DUrole{n}{fraction}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Perform uncertainty analysis sourcing noise from fractioning the
experimental data. This function takes a fitting routine \textless{}fittingFunction\textgreater{}
and repeats it for the specified iterations in a Bootstrap approach.
With each iteration, a random subset of the experimental data is sampled as
specified by the \textless{}fraction\textgreater{} argument. The standard deviation in the fitted
parameters is then returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fittingFunction}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} the fitting routine to be used.
This could be ‘nlr\_fit\_metal\_from\_ccr’ for example

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the number of iterations for the Monte\sphinxhyphen{}Carlo simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fraction}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the proportion of data to be samples. Must be between 0 and 1.0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} all key\sphinxhyphen{}word arguments will be bundled into this variable and
parsed to the fittingFunction.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sample\_metals} (\sphinxstyleemphasis{list of list of metals}) \textendash{} the metals fitted to the data with noise at each iteration

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{std\_metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the standard deviation in fitted parameters over all iterations of the
Monte Carlo simulation.
These are stored within the metal object. All unfitted parameters
are zero.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.fit\_error\_models}
\label{\detokenize{reference/generated/paramagpy.fit.fit_error_models:paramagpy-fit-fit-error-models}}\label{\detokenize{reference/generated/paramagpy.fit.fit_error_models::doc}}\index{fit\_error\_models() (in module paramagpy.fit)@\spxentry{fit\_error\_models()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.fit_error_models:paramagpy.fit.fit_error_models}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{fit\_error\_models}}}{\emph{\DUrole{n}{fittingFunction}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Perform uncertainty analysis sourcing noise from cooridinates as defined
by models of the PDB structure.
This function takes a fitting routine \textless{}fittingFunction\textgreater{} and repeats it for
each model. The standard deviation in the fitted parameters is then returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fittingFunction}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} the fitting routine to be used.
This could be ‘nlr\_fit\_metal\_from\_ccr’ for example

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} all key\sphinxhyphen{}word arguments will be bundled into this variable and
parsed to the fittingFunction.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sample\_metals} (\sphinxstyleemphasis{list of list of metals}) \textendash{} the metals fitted to the data with noise at each iteration

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{std\_metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the standard deviation in fitted parameters over all iterations of the
Monte Carlo simulation.
These are stored within the metal object. All unfitted parameters
are zero.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.fit\_error\_monte\_carlo}
\label{\detokenize{reference/generated/paramagpy.fit.fit_error_monte_carlo:paramagpy-fit-fit-error-monte-carlo}}\label{\detokenize{reference/generated/paramagpy.fit.fit_error_monte_carlo::doc}}\index{fit\_error\_monte\_carlo() (in module paramagpy.fit)@\spxentry{fit\_error\_monte\_carlo()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.fit_error_monte_carlo:paramagpy.fit.fit_error_monte_carlo}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{fit\_error\_monte\_carlo}}}{\emph{\DUrole{n}{fittingFunction}}, \emph{\DUrole{n}{iterations}}, \emph{\DUrole{o}{**}\DUrole{n}{kwargs}}}{}
\sphinxAtStartPar
Perform uncertainty analysis sourcing noise from experimental uncertainties
This function takes a fitting routine \textless{}fittingFunction\textgreater{} and repeats it for
the specified iterations in a Monte\sphinxhyphen{}Carlo approach. With each iteration,
random noise sourced from a uniform distribution scaled by the experimental
uncertainties is added to the experimental values. The standard deviation in
the fitted parameters is then returned.

\sphinxAtStartPar
NOTE: the ‘err’ column of the dataArrays must be set to non\sphinxhyphen{}zero values for
this method to work.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{fittingFunction}} (\sphinxstyleliteralemphasis{\sphinxupquote{function}}) \textendash{} the fitting routine to be used.
This could be ‘nlr\_fit\_metal\_from\_ccr’ for example

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the number of iterations for the Monte\sphinxhyphen{}Carlo simulation

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kwargs}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} all key\sphinxhyphen{}word arguments will be bundled into this variable and
parsed to the fittingFunction.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sample\_metals} (\sphinxstyleemphasis{list of list of metals}) \textendash{} the metals fitted to the data with noise at each iteration

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{std\_metals} (\sphinxstyleemphasis{list of metals}) \textendash{} the standard deviation in fitted parameters over all iterations of the
Monte Carlo simulation.
These are stored within the metal object. All unfitted parameters
are zero.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.gridsearch\_fit\_atom\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_from_pcs:paramagpy-fit-gridsearch-fit-atom-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_from_pcs::doc}}\index{gridsearch\_fit\_atom\_from\_pcs() (in module paramagpy.fit)@\spxentry{gridsearch\_fit\_atom\_from\_pcs()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_from_pcs:paramagpy.fit.gridsearch_fit_atom_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{gridsearch\_fit\_atom\_from\_pcs}}}{\emph{\DUrole{n}{metals}}, \emph{\DUrole{n}{dataArrays}}, \emph{\DUrole{n}{mapSize}\DUrole{o}{=}\DUrole{default_value}{10.0}}, \emph{\DUrole{n}{mapDensity}\DUrole{o}{=}\DUrole{default_value}{1.0}}}{}
\sphinxAtStartPar
Calculate likely regions for an atom on a grid using
an experimental PCS value and multiple delta\sphinxhyphen{}chi\sphinxhyphen{}tensors.
The calculation returns a grid of PCS RMSD values for each atom
The smallest values on the grid indicated the likely positions
This function returns a dictionary with key/value pairs
associating the atoms/grids.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used for calculating the theoretical
PCS values used during the RMSD calculation
a list must always be provided, but may also contain
only one element.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArrays}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS dataArray}}) \textendash{} each PCS dataArray must correspond to an associated metal.
each PCS dataArray has structure determined by
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mapSize}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the edge length of the grid in angstrom
defaults to 10 Angstrom

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{mapDensity}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the density of points in the grid
defaults to 1 point per Angstrom

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{positions} \textendash{} a dictionary of density maps. Each key is an atom
as defined in \textless{}dataArrays\textgreater{} and corresponds to a value
which is the density map.
a density map defines the RMSD calculation on a grid

\item[{Return type}] \leavevmode
\sphinxAtStartPar
dict of {\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.DensityMap}}}}}

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.gridsearch\_fit\_atom\_restrain\_distance}
\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance:paramagpy-fit-gridsearch-fit-atom-restrain-distance}}\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance::doc}}\index{gridsearch\_fit\_atom\_restrain\_distance() (in module paramagpy.fit)@\spxentry{gridsearch\_fit\_atom\_restrain\_distance()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance:paramagpy.fit.gridsearch_fit_atom_restrain_distance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{gridsearch\_fit\_atom\_restrain\_distance}}}{\emph{\DUrole{n}{densityMapA}}, \emph{\DUrole{n}{densityMapB}}, \emph{\DUrole{n}{distUpper}}, \emph{\DUrole{n}{distLower}}, \emph{\DUrole{n}{number}}}{}
\sphinxAtStartPar
Given two RMSD density maps, this function will compare
all points pairwise and return only those within the bounds of
a given distance cutoff and within a certain number of points
that are that are sorted by RMSD value.
This might be useful if two density maps for separate atoms
in a molecule are known to be constrained w.r.t. one another
and you would like to use that restraint to further restrict
the space of PCS RMSD points.
The calculation first sorts the RMSD points and takes the bottom
\textless{}number\textgreater{} of points and then compares each point pariwise to
fulfill the distance condition. It then returns those points
from both maps. Unfortunately there is no correlation data
available between these two maps.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{densityMapA}} ({\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.DensityMap}}}}}) \textendash{} a density map of PCS RMSD values.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{densityMapB}} ({\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.DensityMap}}}}}) \textendash{} a second density map of PCS RMSD values.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{distUpper}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The upper limit for distance.
Any pairwise distances larger than this value
will be rejected from the final space of points

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{distLower}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The lower distance limit for distance
Any pairwise distance smaller than this value
will be rejectet from the final space of points

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{number}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The total number of positions to be considered
for the pairwise distance comparison.
This calculation first sorts points by RMSD
and takes \textless{}number\textgreater{} of points with minimum RMSD
and uses these for the pairwise distance calculation.
Note that the total number of points returned
could be significnalty more than this value after
the pairwise comparison

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{tuple} \textendash{} two lists of {[}x,y,z{]} coordinates are returned associated
with the inputs \textless{}densityMapA\textgreater{} and \textless{}densityMapB\textgreater{}.
The returned coordinates are taken from the original grids
and represent points that have another associated point in
the other grid which is within the distance bounds and
contained with an RMSD low enough to be within the lowest
\textless{}number\textgreater{} of points

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.ndarray of position coordinates

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.gridsearch\_fit\_atom\_restrain\_distance\_cutoff}
\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance_cutoff:paramagpy-fit-gridsearch-fit-atom-restrain-distance-cutoff}}\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance_cutoff::doc}}\index{gridsearch\_fit\_atom\_restrain\_distance\_cutoff() (in module paramagpy.fit)@\spxentry{gridsearch\_fit\_atom\_restrain\_distance\_cutoff()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.gridsearch_fit_atom_restrain_distance_cutoff:paramagpy.fit.gridsearch_fit_atom_restrain_distance_cutoff}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{gridsearch\_fit\_atom\_restrain\_distance\_cutoff}}}{\emph{\DUrole{n}{densityMapA}}, \emph{\DUrole{n}{densityMapB}}, \emph{\DUrole{n}{distUpper}}, \emph{\DUrole{n}{distLower}}, \emph{\DUrole{n}{cutoffValue}}}{}
\sphinxAtStartPar
Given two RMSD density maps, this function will compare
all points pairwise and return only those within the bounds of
a given distance cutoff and within a given RMSD cutoff.
This might be useful if two density maps for separate atoms
in a molecule are known to be constrained w.r.t. one another
and you would like to use that restraint to further restrict
the space of PCS RMSD points.
The calculation first selects points with an RMSD less than
the given cutoff value and then compares each point pariwise to
fulfill the distance condition. It then returns those points
from both maps. Unfortunately there is no correlation data
available between these two maps.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{densityMapA}} ({\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.DensityMap}}}}}) \textendash{} a density map of PCS RMSD values.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{densityMapB}} ({\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.fit.DensityMap}}}}}) \textendash{} a second density map of PCS RMSD values.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{distUpper}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The upper limit for distance.
Any pairwise distances larger than this value
will be rejected from the final space of points

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{distLower}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The lower distance limit for distance
Any pairwise distance smaller than this value
will be rejectet from the final space of points

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{cutoffValue}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The RMSD threshold for which points are taken
for the pairwise distance comparison.
Note that the total number of points returned
is significnalty influenced by this parameter
and should be chosen carefully

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{tuple} \textendash{} two lists of {[}x,y,z{]} coordinates are returned associated
with the inputs \textless{}densityMapA\textgreater{} and \textless{}densityMapB\textgreater{}.
The returned coordinates are taken from the original grids
and represent points that have another associated point in
the other grid which is within the distance bounds and
have an RMSD below the cutoff threshold.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
np.ndarray of position coordinates

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.metal\_standard\_deviation}
\label{\detokenize{reference/generated/paramagpy.fit.metal_standard_deviation:paramagpy-fit-metal-standard-deviation}}\label{\detokenize{reference/generated/paramagpy.fit.metal_standard_deviation::doc}}\index{metal\_standard\_deviation() (in module paramagpy.fit)@\spxentry{metal\_standard\_deviation()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.metal_standard_deviation:paramagpy.fit.metal_standard_deviation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{metal\_standard\_deviation}}}{\emph{\DUrole{n}{metals}}, \emph{\DUrole{n}{params}}}{}
\sphinxAtStartPar
Calculate the standard deviation in parameters \textless{}params\textgreater{} for a
list of metal objects \textless{}metals\textgreater{}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} the metals for which the standard deviation in parameters
will be calculated

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters for the standard deviation calculation.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{std\_metal} \textendash{} the returned metal object has attributes equal to the
standard deviation in the given parameter.
All other attributes are zero.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
metal object

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_ccr}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr:paramagpy-fit-nlr-fit-metal-from-ccr}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr::doc}}\index{nlr\_fit\_metal\_from\_ccr() (in module paramagpy.fit)@\spxentry{nlr\_fit\_metal\_from\_ccr()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_ccr:paramagpy.fit.nlr_fit_metal_from_ccr}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_ccr}}}{\emph{\DUrole{n}{initMetals}}, \emph{\DUrole{n}{dataArrays}}, \emph{\DUrole{n}{params}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}x\textquotesingle{}, \textquotesingle{}y\textquotesingle{}, \textquotesingle{}z\textquotesingle{})}}, \emph{\DUrole{n}{ensembleAverage}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{progress}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fit Chi tensor to CCR values using non\sphinxhyphen{}linear regression.
This algorithm applies to CSA/Curie spin cross\sphinxhyphen{}correlated relaxation
for R2 differential line broadening.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PRE dataset by index in \textless{}dataArrays,
but all are fitted to a common position.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArrays}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PRE dataArray}}) \textendash{} each PRE dataArray must correspond to an associated metal for fitting.
each PRE dataArray has structure determined by
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ensembleAverage}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, each model of the structure is fit independently.
The parameters for each fitted tensor are then averaged before
returning the final averaged tensor.
When True, the structure models are treated as an ensemble and
ensemble averaging of calculated PCS/PRE/RDC/CCR values is
conducted at all stages of fitting to fit a single tensor to all
models simultaneously. The ‘idx’ column of the dataArray
determines the ensemble averaging behaviour with common indices
for atoms between models resulting in their summation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 \sphinxhyphen{}\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fitMetals} (\sphinxstyleemphasis{list of metals}) \textendash{} a list of the fitted tensors.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dataArrays} (\sphinxstyleemphasis{list of dataArray}) \textendash{} each dataArray is copy of the original dataArray with
the ‘cal’ column populated with back\sphinxhyphen{}calculated values from the
fitted tensor.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy-fit-nlr-fit-metal-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs::doc}}\index{nlr\_fit\_metal\_from\_pcs() (in module paramagpy.fit)@\spxentry{nlr\_fit\_metal\_from\_pcs()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pcs:paramagpy.fit.nlr_fit_metal_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_pcs}}}{\emph{\DUrole{n}{initMetals}}, \emph{\DUrole{n}{dataArrays}}, \emph{\DUrole{n}{params}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}x\textquotesingle{}, \textquotesingle{}y\textquotesingle{}, \textquotesingle{}z\textquotesingle{}, \textquotesingle{}ax\textquotesingle{}, \textquotesingle{}rh\textquotesingle{}, \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}g\textquotesingle{})}}, \emph{\DUrole{n}{ensembleAverage}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{userads}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{useracs}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{progress}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fit deltaChi tensor to PCS values using non\sphinxhyphen{}linear regression.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PCS dataset by index in \textless{}dataArrays,
but all are fitted to a common position.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArrays}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS dataArray}}) \textendash{} each PCS dataArray must correspond to an associated metal for fitting.
each PCS dataArray has structure determined by
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ensembleAverage}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, each model of the structure is fit independently.
The parameters for each fitted tensor are then averaged before
returning the final averaged tensor.
When True, the structure models are treated as an ensemble and
ensemble averaging of calculated PCS/PRE/RDC/CCR values is
conducted at all stages of fitting to fit a single tensor to all
models simultaneously. The ‘idx’ column of the dataArray
determines the ensemble averaging behaviour with common indices
for atoms between models resulting in their summation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{userads}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic dipolar shielding (RADS) during fitting

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{useracs}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include residual anisotropic chemical shielding (RACS) during fitting.
CSA tensors are taken using the \textless{}csa\textgreater{} method of atoms.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 \sphinxhyphen{}\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fitMetals} (\sphinxstyleemphasis{list of metals}) \textendash{} a list of the fitted tensors.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dataArrays} (\sphinxstyleemphasis{list of dataArray}) \textendash{} each dataArray is copy of the original dataArray with
the ‘cal’ column populated with back\sphinxhyphen{}calculated values from the
fitted tensor.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.nlr\_fit\_metal\_from\_pre}
\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy-fit-nlr-fit-metal-from-pre}}\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre::doc}}\index{nlr\_fit\_metal\_from\_pre() (in module paramagpy.fit)@\spxentry{nlr\_fit\_metal\_from\_pre()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.nlr_fit_metal_from_pre:paramagpy.fit.nlr_fit_metal_from_pre}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{nlr\_fit\_metal\_from\_pre}}}{\emph{\DUrole{n}{initMetals}}, \emph{\DUrole{n}{dataArrays}}, \emph{\DUrole{n}{rtypes}}, \emph{\DUrole{n}{params}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}x\textquotesingle{}, \textquotesingle{}y\textquotesingle{}, \textquotesingle{}z\textquotesingle{})}}, \emph{\DUrole{n}{usesbm}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{usegsbm}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{usedsa}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{usecsa}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{ensembleAverage}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{progress}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fit Chi tensor to PRE values using non\sphinxhyphen{}linear regression.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PRE dataset by index in \textless{}dataArrays,
but all are fitted to a common position.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArrays}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PRE dataArray}}) \textendash{} each PRE dataArray must correspond to an associated metal for fitting.
each PRE dataArray has structure determined by
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rtypes}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the relaxtion type, either ‘r1’ or ‘r2’. A list must be provided with
each element corresponding to an associated dataset.
Defaults to ‘r2’ for all datasets of None is specified.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
For example {[}‘x’,’y’,’z’,’ax’,’rh’,’a’,’b’,’g’,’shift’{]}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usesbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include Solomon\sphinxhyphen{}Bloemenbergen\sphinxhyphen{}Morgan (Dipole\sphinxhyphen{}dipole) relaxation theory.
default is True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usegsbm}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include anisotropic dipolar relaxation theory.
note that the g\sphinxhyphen{}tensor must be set for this
default is False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usedsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include Dipolar\sphinxhyphen{}Shielding\sphinxhyphen{}Anisotropy (Curie Spin) relaxation theory.
default is True

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{usecsa}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} include Chemical\sphinxhyphen{}Shift\sphinxhyphen{}Anisotropy cross\sphinxhyphen{}correlated realxation theory.
default is False

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ensembleAverage}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, each model of the structure is fit independently.
The parameters for each fitted tensor are then averaged before
returning the final averaged tensor.
When True, the structure models are treated as an ensemble and
ensemble averaging of calculated PCS/PRE/RDC/CCR values is
conducted at all stages of fitting to fit a single tensor to all
models simultaneously. The ‘idx’ column of the dataArray
determines the ensemble averaging behaviour with common indices
for atoms between models resulting in their summation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 \sphinxhyphen{}\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fitMetals} (\sphinxstyleemphasis{list of metals}) \textendash{} a list of the fitted tensors.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dataArrays} (\sphinxstyleemphasis{list of dataArray}) \textendash{} each dataArray is copy of the original dataArray with
the ‘cal’ column populated with back\sphinxhyphen{}calculated values from the
fitted tensor.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.pcs\_gradient\_orthogonality\_cross}
\label{\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_cross:paramagpy-fit-pcs-gradient-orthogonality-cross}}\label{\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_cross::doc}}\index{pcs\_gradient\_orthogonality\_cross() (in module paramagpy.fit)@\spxentry{pcs\_gradient\_orthogonality\_cross()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_cross:paramagpy.fit.pcs_gradient_orthogonality_cross}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{pcs\_gradient\_orthogonality\_cross}}}{\emph{\DUrole{n}{metals}}, \emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
An experimental metric for calculating the likelihood
of a particular nuclear position being well localised
from multiple tensors.
The metric scores the orthogonality of the PCS
gradient vectors and accounts for their magnitude.
This algorithm calculates the PCS graident
vector arising at a given position from each tensor
provided. It then calculates the pairwise cross product
of each vector and averages their norm (length).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of paramagpy metal objects which define the
tensors.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray of floats}}) \textendash{} the {[}x,y,z{]} coordinate to calculated the
orthogonality score

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{score} \textendash{} the orthogonality score. This is necessarily
between greater than zero. A larger
score defines a more favourable orthogonality
between PCS gradient vectors and also score larger
PCS gradients more highly.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.pcs\_gradient\_orthogonality\_dot}
\label{\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_dot:paramagpy-fit-pcs-gradient-orthogonality-dot}}\label{\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_dot::doc}}\index{pcs\_gradient\_orthogonality\_dot() (in module paramagpy.fit)@\spxentry{pcs\_gradient\_orthogonality\_dot()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.pcs_gradient_orthogonality_dot:paramagpy.fit.pcs_gradient_orthogonality_dot}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{pcs\_gradient\_orthogonality\_dot}}}{\emph{\DUrole{n}{metals}}, \emph{\DUrole{n}{position}}}{}
\sphinxAtStartPar
An experimental metric for calculating the likelihood
of a particular nuclear position being well localised
from multiple tensors.
This algorithm calculates the normalised PCS graident
vector arising at a given position from each tensor
provided. It then calculates the pairwise dot product
of each vector and averages their absolute value.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{metals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of paramagpy metal objects which define the
tensors.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{position}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.ndarray of floats}}) \textendash{} the {[}x,y,z{]} coordinate to calculated the
orthogonality score

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{score} \textendash{} the orthogonality score. This is necessarily
between 0 and 1 for this metric. A lower
score defies a more favourable orthogonality
between PCS gradient vectors.
Note that a value of zero is not possible when
more than 4 metals are provided.

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.qfactor}
\label{\detokenize{reference/generated/paramagpy.fit.qfactor:paramagpy-fit-qfactor}}\label{\detokenize{reference/generated/paramagpy.fit.qfactor::doc}}\index{qfactor() (in module paramagpy.fit)@\spxentry{qfactor()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.qfactor:paramagpy.fit.qfactor}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{qfactor}}}{\emph{\DUrole{n}{dataArray}}, \emph{\DUrole{n}{ensembleAverage}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{calDenominator}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
\sphinxAtStartPar
Calculate the Q\sphinxhyphen{}factor to judge tensor fit quality

\sphinxAtStartPar
A lower value indicates a better fit. The Q\sphinxhyphen{}factor is calculated using
the following equation:
\begin{equation*}
\begin{split}Q = \sqrt{
        \frac{\sum_i\left[\left(\sum_m\left[
        PCS^{exp}_{m,i}-PCS^{calc}_{m,i}\right]\right)^2\right]}
        {\sum_i\left[
        \left(\sum_m\left[PCS^{exp}_{m,i}\right]\right)^2\right]}
}\end{split}
\end{equation*}
\sphinxAtStartPar
where \(m\) and \(i\) are usually indexed over models and atoms
respectively.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArray}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy array}}) \textendash{} the dataArray must contain the columns ‘exp’, ‘cal’ and ‘idx’
corresponding to the experimenta, calculated and index values
respectively. The index value determines the ensemble averaging
behaviour, and can be ignored if the argument \textless{}ensembleAverage\textgreater{}
is False.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ensembleAverage}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, the q\sphinxhyphen{}factor calculation squares each difference
independently.
When True, the q\sphinxhyphen{}factor calculates an ensemble average before
taking the square of differences. The ‘idx’ column of the dataArray
determines the ensemble averaging behaviour with common indices
for atoms between models resulting in their summation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{calDenominator}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, the standard Q\sphinxhyphen{}factor is calculated with only the sum
of squares for the experimental values used in the denominator
when True, the Q\sphinxhyphen{}factor established by Ubbink et al. is
calculated which has a sum of absolute values of exp and cal
values squared in the denominator.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{qfactor} \textendash{} the Q\sphinxhyphen{}factor

\item[{Return type}] \leavevmode
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.sphere\_grid}
\label{\detokenize{reference/generated/paramagpy.fit.sphere_grid:paramagpy-fit-sphere-grid}}\label{\detokenize{reference/generated/paramagpy.fit.sphere_grid::doc}}\index{sphere\_grid() (in module paramagpy.fit)@\spxentry{sphere\_grid()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.sphere_grid:paramagpy.fit.sphere_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{sphere\_grid}}}{\emph{\DUrole{n}{origin}}, \emph{\DUrole{n}{radius}}, \emph{\DUrole{n}{points}}}{}
\sphinxAtStartPar
Make a grid of cartesian points within a sphere
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the centre of the sphere

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the radius of the sphere

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the number of points per radius

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\sphinxstylestrong{array} \textendash{} the points within the sphere

\item[{Return type}] \leavevmode
\sphinxAtStartPar
array of {[}x,y,z{]} coordinates

\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_calc\_metal\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs:paramagpy-fit-svd-calc-metal-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs::doc}}\index{svd\_calc\_metal\_from\_pcs() (in module paramagpy.fit)@\spxentry{svd\_calc\_metal\_from\_pcs()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs:paramagpy.fit.svd_calc_metal_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pcs}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{errors}}}{}
\sphinxAtStartPar
Solve PCS equation by single value decomposition.
This function is generally called by higher methods like
\textless{}svd\_gridsearch\_fit\_metal\_from\_pcs\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{z}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{floats}}) \textendash{} the atomic positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pcs}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the PCS values in ppm. Note these should be weighted by the
experimental uncertainties.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}) \textendash{} an index assigned to each atom. Common indices determine summation
between models for ensemble averaging.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the standard deviation representing experimental uncertainty
in the measured value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{calc} (\sphinxstyleemphasis{array of floats}) \textendash{} the calculated PCS values from the fitted tensor

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sol} (\sphinxstyleemphasis{array of floats}) \textendash{} solution to the linearised PCS equation and
consists of the tensor 5 matrix elements

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_calc\_metal\_from\_pcs\_offset}
\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset:paramagpy-fit-svd-calc-metal-from-pcs-offset}}\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset::doc}}\index{svd\_calc\_metal\_from\_pcs\_offset() (in module paramagpy.fit)@\spxentry{svd\_calc\_metal\_from\_pcs\_offset()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_pcs_offset:paramagpy.fit.svd_calc_metal_from_pcs_offset}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_calc\_metal\_from\_pcs\_offset}}}{\emph{\DUrole{n}{pos}}, \emph{\DUrole{n}{pcs}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{errors}}}{}
\sphinxAtStartPar
Solve PCS equation by single value decomposition with offset.
An offset arising from referencing errors between diamagnetic
and paramagnetic datasets can be accounted for using this method.
This function is generally called by higher methods like
\textless{}svd\_gridsearch\_fit\_metal\_from\_pcs\textgreater{}

\sphinxAtStartPar
NOTE: the factor of 1E26 is required for floating point error mitigation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pos}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{z}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{floats}}) \textendash{} the atomic positions in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pcs}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the PCS values in ppm. Note these should be weighted by the
experimental uncertainties.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}) \textendash{} an index assigned to each atom. Common indices determine summation
between models for ensemble averaging.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the standard deviation representing experimental uncertainty
in the measured value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{calc} (\sphinxstyleemphasis{array of floats}) \textendash{} the calculated PCS values from the fitted tensor

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sol} (\sphinxstyleemphasis{array of floats}) \textendash{} solution to the linearised PCS equation and
consists of the tensor 5 matrix elements and offset values

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_calc\_metal\_from\_rdc}
\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc:paramagpy-fit-svd-calc-metal-from-rdc}}\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc::doc}}\index{svd\_calc\_metal\_from\_rdc() (in module paramagpy.fit)@\spxentry{svd\_calc\_metal\_from\_rdc()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_calc_metal_from_rdc:paramagpy.fit.svd_calc_metal_from_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_calc\_metal\_from\_rdc}}}{\emph{\DUrole{n}{vec}}, \emph{\DUrole{n}{rdc\_parameterised}}, \emph{\DUrole{n}{idx}}, \emph{\DUrole{n}{errors}}}{}
\sphinxAtStartPar
Solve RDC equation by single value decomposition.
This function is generally called by higher methods like
\textless{}svd\_fit\_metal\_from\_rdc\textgreater{}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{vec}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of}}\sphinxstyleliteralemphasis{\sphinxupquote{ {[}}}\sphinxstyleliteralemphasis{\sphinxupquote{x}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{y}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{z}}\sphinxstyleliteralemphasis{\sphinxupquote{{]} }}\sphinxstyleliteralemphasis{\sphinxupquote{floats}}) \textendash{} the internuclear vectors in meters

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{rdc\_parameterised}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the experimental RDC values, normalised by a prefactor

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{idx}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of ints}}) \textendash{} an index assigned to each atom. Common indices determine summation
between models for ensemble averaging.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{errors}} (\sphinxstyleliteralemphasis{\sphinxupquote{array of floats}}) \textendash{} the standard deviation representing experimental uncertainty
in the measured value

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{calc} (\sphinxstyleemphasis{array of floats}) \textendash{} the calculated RDC values from the fitted tensor

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{sol} (\sphinxstyleemphasis{array of floats}) \textendash{} sol is the solution to the linearised PCS equation and
consists of the tensor matrix elements

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_fit\_metal\_from\_rdc}
\label{\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy-fit-svd-fit-metal-from-rdc}}\label{\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc::doc}}\index{svd\_fit\_metal\_from\_rdc() (in module paramagpy.fit)@\spxentry{svd\_fit\_metal\_from\_rdc()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_fit_metal_from_rdc:paramagpy.fit.svd_fit_metal_from_rdc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_fit\_metal\_from\_rdc}}}{\emph{\DUrole{n}{initMetals}}, \emph{\DUrole{n}{dataArrays}}, \emph{\DUrole{n}{params}\DUrole{o}{=}\DUrole{default_value}{(\textquotesingle{}ax\textquotesingle{}, \textquotesingle{}rh\textquotesingle{}, \textquotesingle{}a\textquotesingle{}, \textquotesingle{}b\textquotesingle{}, \textquotesingle{}g\textquotesingle{})}}, \emph{\DUrole{n}{ensembleAverage}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{progress}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fit deltaChi tensor to RDC values using Single Value Decomposition.
Note this is a weighted SVD calculation which takes into account
experimental errors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective RDC dataset by index in \textless{}dataArrays\textgreater{}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArrays}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PRE dataArray}}) \textendash{} each RDC dataArray must correspond to an associated metal for fitting.
each RDC dataArray has structure determined by
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{params}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of str}}) \textendash{} the parameters to be fit.
NOTE: This is a dummy argument and does not influence the fitting.
The default parameters (‘ax’,’rh’,’a’,’b’,’g’) are the only option.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ensembleAverage}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, each model of the structure is fit independently.
The parameters for each fitted tensor are then averaged before
returning the final averaged tensor.
When True, the structure models are treated as an ensemble and
ensemble averaging of calculated PCS/PRE/RDC/CCR values is
conducted at all stages of fitting to fit a single tensor to all
models simultaneously. The ‘idx’ column of the dataArray
determines the ensemble averaging behaviour with common indices
for atoms between models resulting in their summation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 \sphinxhyphen{}\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fitMetals} (\sphinxstyleemphasis{list of metals}) \textendash{} a list of the fitted tensors.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dataArrays} (\sphinxstyleemphasis{list of dataArray}) \textendash{} each dataArray is copy of the original dataArray with
the ‘cal’ column populated with back\sphinxhyphen{}calculated values from the
fitted tensor.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\paragraph{paramagpy.fit.svd\_gridsearch\_fit\_metal\_from\_pcs}
\label{\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy-fit-svd-gridsearch-fit-metal-from-pcs}}\label{\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs::doc}}\index{svd\_gridsearch\_fit\_metal\_from\_pcs() (in module paramagpy.fit)@\spxentry{svd\_gridsearch\_fit\_metal\_from\_pcs()}\spxextra{in module paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.svd_gridsearch_fit_metal_from_pcs:paramagpy.fit.svd_gridsearch_fit_metal_from_pcs}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{svd\_gridsearch\_fit\_metal\_from\_pcs}}}{\emph{\DUrole{n}{initMetals}}, \emph{\DUrole{n}{dataArrays}}, \emph{\DUrole{n}{ensembleAverage}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{origin}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{radius}\DUrole{o}{=}\DUrole{default_value}{20.0}}, \emph{\DUrole{n}{points}\DUrole{o}{=}\DUrole{default_value}{16}}, \emph{\DUrole{n}{offsetShift}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{progress}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\sphinxAtStartPar
Fit deltaChi tensor to PCS values using Single Value Decomposition over
a grid of points in a sphere.
Note this uses a weighted SVD fit which takes into account
experimental errors
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{initMetals}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of Metal objects}}) \textendash{} a list of metals used as starting points for fitting.
a list must always be provided, but may also contain
only one element. If multiple metals are provided, each metal
is fitted to their respective PCS dataset by index in \textless{}dataArrays,
but all are fitted to a common position.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{dataArrays}} (\sphinxstyleliteralemphasis{\sphinxupquote{list of PCS dataArray}}) \textendash{} each PCS dataArray must correspond to an associated metal for fitting.
each PCS dataArray has structure determined by
{\hyperref[\detokenize{reference/generated/paramagpy.protein.CustomStructure.parse:paramagpy.protein.CustomStructure.parse}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{paramagpy.protein.CustomStructure.parse()}}}}}.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ensembleAverage}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} when False, each model of the structure is fit independently.
The parameters for each fitted tensor are then averaged before
returning the final averaged tensor.
When True, the structure models are treated as an ensemble and
ensemble averaging of calculated PCS/PRE/RDC/CCR values is
conducted at all stages of fitting to fit a single tensor to all
models simultaneously. The ‘idx’ column of the dataArray
determines the ensemble averaging behaviour with common indices
for atoms between models resulting in their summation.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the centre of the gridsearch of positions in Angstroms.
If None, the position of the first metal is used

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the radius of the gridsearch in Angstroms.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{points}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} the number of points per radius in the gridsearch

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{offsetShift}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} if True, an offset value added to all PCS values is included in
the SVD fitting. This may arise due to a referencing error between
diamagnetic and paramagnetic PCS datasets and may be used when
many data points are available.
Default False, no offset is included in the fitting.

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{progress}} (\sphinxstyleliteralemphasis{\sphinxupquote{object}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{optional}}) \textendash{} to keep track of the calculation, progress.set(x) is called each
iteration and varies from 0.0 \sphinxhyphen{}\textgreater{} 1.0 when the calculation is complete.

\end{itemize}

\item[{Returns}] \leavevmode
\sphinxAtStartPar
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{fitMetals} (\sphinxstyleemphasis{list of metals}) \textendash{} a list of the fitted tensors.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{dataArrays} (\sphinxstyleemphasis{list of dataArray}) \textendash{} each dataArray is copy of the original dataArray with
the ‘cal’ column populated with back\sphinxhyphen{}calculated values from the
fitted tensor.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Classes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DensityMap}}}}}(origin, size, density)
&
\sphinxAtStartPar
A class to help with calculations on a grid.
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}


\paragraph{paramagpy.fit.DensityMap}
\label{\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy-fit-densitymap}}\label{\detokenize{reference/generated/paramagpy.fit.DensityMap::doc}}\index{DensityMap (class in paramagpy.fit)@\spxentry{DensityMap}\spxextra{class in paramagpy.fit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{paramagpy.fit.}}\sphinxbfcode{\sphinxupquote{DensityMap}}}{\emph{\DUrole{n}{origin}}, \emph{\DUrole{n}{size}}, \emph{\DUrole{n}{density}}}{}
\sphinxAtStartPar
A class to help with calculations on a grid.
The grid can be setup by specifying the origin (centre)
edge size and density.
Arguments are given in Angstrom, but stored in metres
The grid positions are available for calculations
The density can be written out as a .ccp4 electron density map
Use this class for any contour plots to view in PyMol
\index{\_\_init\_\_() (paramagpy.fit.DensityMap method)@\spxentry{\_\_init\_\_()}\spxextra{paramagpy.fit.DensityMap method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap.__init__}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{\_\_init\_\_}}}{\emph{\DUrole{n}{origin}}, \emph{\DUrole{n}{size}}, \emph{\DUrole{n}{density}}}{}
\sphinxAtStartPar
Make a density map over a cubic grid of coordinates
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{origin}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray of floats}}) \textendash{} {[}x,y,z{]} position in Angstrom defining the centre of the cubic grid

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{size}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the grid edge size in Angstrom

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{density}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} grid density defined as points per angstrom

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\subsubsection*{Methods}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
{\hyperref[\detokenize{reference/generated/paramagpy.fit.DensityMap:paramagpy.fit.DensityMap.__init__}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{\_\_init\_\_}}}}}(origin, size, density)
&
\sphinxAtStartPar
Make a density map over a cubic grid of coordinates
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{boundary\_min}}()
&
\sphinxAtStartPar
Does the minimum value lie on the boundary of the grid?
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{boundary\_positions\_below\_density}}(cutoffValue)
&
\sphinxAtStartPar
Do any positions below \textless{}cutoffValue\textgreater{} lie on the grid boundary?
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{get\_positions\_below\_density}}(cutoffValue)
&
\sphinxAtStartPar
Returns all positions in the grid that are below the argument \textless{}cutoffValue\textgreater{}
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{minpos}}()
&
\sphinxAtStartPar
Fetch the grid point position with minimum density value
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{write}}(fileName)
&
\sphinxAtStartPar
Write density values to file in .ccp4 format Headers are accounted for from the given geometry of the grid
\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}
\subsubsection*{Attributes}


\begin{savenotes}\sphinxatlongtablestart\begin{longtable}[c]{\X{1}{2}\X{1}{2}}
\hline

\endfirsthead

\multicolumn{2}{c}%
{\makebox[0pt]{\sphinxtablecontinued{\tablename\ \thetable{} \textendash{} continued from previous page}}}\\
\hline

\endhead

\hline
\multicolumn{2}{r}{\makebox[0pt][r]{\sphinxtablecontinued{continues on next page}}}\\
\endfoot

\endlastfoot

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{CCP4\_HEADER\_DTYPE}}
&
\sphinxAtStartPar

\\
\hline
\end{longtable}\sphinxatlongtableend\end{savenotes}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{p}
\item\relax\sphinxstyleindexentry{paramagpy.dataparse}\sphinxstyleindexpageref{reference/dataparse:\detokenize{module-paramagpy.dataparse}}
\item\relax\sphinxstyleindexentry{paramagpy.fit}\sphinxstyleindexpageref{reference/generated/paramagpy.fit:\detokenize{module-paramagpy.fit}}
\item\relax\sphinxstyleindexentry{paramagpy.metal}\sphinxstyleindexpageref{reference/metal:\detokenize{module-paramagpy.metal}}
\item\relax\sphinxstyleindexentry{paramagpy.protein}\sphinxstyleindexpageref{reference/protein:\detokenize{module-paramagpy.protein}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}